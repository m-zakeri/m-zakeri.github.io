<!DOCTYPE html>
<html dir="rtl" lang="fa-IR" prefix="og: http://ogp.me/ns#">
<head>
        <meta charset="UTF-8" />
	<title>عنوان متن</title>
	<meta name="viewport" content="width=device-width, initial-scale=1">
         <link rel="stylesheet" href="../css/w3.css">
	
         <link rel="stylesheet" href="../css/farsi_site.css">

</head>
<body class="bodyclass">

<p><figure><img src="https://boute.s3.amazonaws.com/290-IUST_logo_color.png" alt="<b>دانشـکده مهندسی کامپیوتر</b>"><figcaption><b>دانشـکده مهندسی کامپیوتر</b></figcaption></figure></p>
<p><strong><h1 align = "center">یـادگیری توالی‌به‌توالی با شبکه‌های عصبی</h1></strong></p>
<h4 align="center">
<b> مرتــضی ذاکـری (M - Z A K E R I [ A T ] L I V E [ D O T ] C O M)
</b>
</h4><ul>
<li><p>ارایـه (<a href="https://www.dropbox.com/s/x8i9nwo8n1l3tlk/Zakeri_NLP961_project_p3_presentation.pdf?dl=0">اسلاید (1.92MB)</a>  |  <a href="https://www.dropbox.com/s/43xs7e0kmnil5ku/Zakeri_NLP961_project_p3_talk.mp4?dl=0">ویدئـو (53.50MB)</a>) <em>دی‌ماه 1396</em></p></li>
<li><p><a href="https://www.dropbox.com/s/mtngihanlci090r/Zakeri_NLP961_project_p2_rc02.pdf?dl=0">نسخه PDF (فاز دوم) (حجم 1.75MB)</a> <em>آذرماه 1396</em></p></li>
<li><p><a href="https://www.dropbox.com/s/b3n2nfc1hgmvkhh/Zakeri_NLP961_project_p1_rc01.pdf?dl=0">نسخه PDF (فاز اول) (حجم 1.23MB)</a> <em>آبان‌ماه 1396</em></p></li>
<li><p><a href="https://www.dropbox.com/s/xd5y5zxrvm9f67d/Zakeri_NLP961_project_figs.zip?dl=0">فایل ZIP کلیه تصاویر استفاده شده (حجم 2.22MB)</a> </p></li>
<li><p><a href="https://www.dropbox.com/s/ikyd12fytka91f3/2014_sequence-to-sequence-learning-with-neural-networks.pdf?dl=0">مرجع اصلی (حجم 165KB)</a></p></li>
</ul>
<hr>
<p><strong><h2>چکیده</h2></strong>یادگیری ژرف شاخه‌ای نسبتا جدید از یادگیری ماشین است که در آن توابع محاسباتی به‌شکل گراف‌های چند سطحی یا ژرف برای شناسایی و تخمین قانون حاکم بر حل یک مسئله پیچیده به‌کار بسته می‌شوند. شبکه‌های عصبی ژرف ابزاری برای طراحی و پیاده‌سازی این مدل یادگیری هستند. این شبکه‌ها در بسیاری از وظایف یادگیری ماشینی سخت، موفق ظاهر شده‌اند. به‌منظور استفاده از شبکه‌های ژرف در وظایفی که ترتیب ورودی داده‌ در انجام آن مؤثر است مانند اکثر وظایف حوزه پردازش زبان طبیعی، شبکه‌های عصبی مکرر ابداع گشتند که بازنمایی مناسبی از مدل‌های زبانی ارایه می‌دهند. این مدل‌ها در حالت ساده برای همه وظیفه‌های یک مدل زبانی مناسب نیستند. در این گزارش مدل خاصی از شبکه‌های مکرر تحت عنوان مدل توالی‌به‌توالی یا کدگذار-گدگشا بررسی می‌شود که برای وظایفی که شامل توالی‌های ورودی و خروجی با طول متفاوت هستند؛ نظیر ترجمه ماشینی، توسعه داده شده و توانسته است نتایج قابل قبولی را در این زمینه تولید کند.<br>
<strong>کلیدواژه‌ها:</strong> مدل توالی‌به‌توالی، شبکه عصبی مکرر، یادگیری ژرف، ترجمه ماشینی.</p>
<p><br/></p>
<h1><strong>مقدمه</strong></h1>
<p>مدل‌ها و روش‌های یادگیری به‌کمک شبکه‌های عصبی ژرف (DNNs)<sup class="footnote-ref" id="fnref-1"><a href="#fn-1" rel="footnote">1</a></sup> اخیرا، با افزایش قدرت محاسباتی سخت‌افزارها و نیز حل برخی از چالش‌های اساسی موجود بر سر راه آموزش و یادگیری این شبکه‌ها، بسیار مورد توجه واقع شده‌اند. DNNها در انجام وظایف سخت یادگیری ماشین مانند تشخیص گفتار، تشخیص اشیاء و غیره، فوق‌العاده قدرت‌مند ظاهر شده‌اند و در مواردی روش‌های سنتی را کاملاً کنار زده‌اند. قدرت بازنمایی زیاد DNNها به این دلیل است که قادر هستند محاسبات زیادی را به صورت موازی در چندین لایه انجام داده، با تعداد زیادی پارامتر پاسخ مسئله داده شده را تخمین زده و مدل مناسبی از آن ارایه دهند. درحال حاضر DNNهای بزرگ می‌توانند با استفاده از الگوریتم پس‌انتشار<sup class="footnote-ref" id="fnref-2"><a href="#fn-2" rel="footnote">2</a></sup> به‌صورت بانظارت<sup class="footnote-ref" id="fnref-3"><a href="#fn-3" rel="footnote">3</a></sup> روی یک مجموعه آموزش برچسب‌زده و به‌قدر کافی بزرگ آموزش ببینند. بنابراین در مواردی که ضابطه حاکم بر یک مسئله دارای پارامترهای بسیار زیادی است و یک مقدار بهینه از این پارامترها وجود دارد (صرفا با استناد به این که مغز انسان همین مسئله را خیلی سریع حل می‌کند)، روش یادگیری پس‌انتشار این تنظیم از پارامترها (مقدارهای بهینه) را یافته و مسئله را حل می‌کند [1].<br>
 بسیاری از وظایف یادگیری ماشین به حوزه پردازش زبان طبیعی (NLP)<sup class="footnote-ref" id="fnref-4"><a href="#fn-4" rel="footnote">4</a></sup> مربوط می‌شوند؛ جایی که در آن معمولا ترتیب ورودی‌ها و خروجی‌های یک مسئله مهم است. برای مثال در ترجمه ماشینی دو جمله با واژه‌های یکسان ولی ترتیب متفاوت، معانی (خروجی‌های) مختلفی دارند. این وظایف اصطلاحا مبتنی بر توالی<sup class="footnote-ref" id="fnref-5"><a href="#fn-5" rel="footnote">5</a></sup> هستند. در واقع ورودی آنها به صورت یک توالی است. شبکه‌های عصبی رو به جلو ژرف<sup class="footnote-ref" id="fnref-6"><a href="#fn-6" rel="footnote">6</a></sup>  برای این دسته از وظایف خوب عمل نمی‌کنند؛ چرا که قابلیتی برای به‌خاطر سپاری و مدل‌سازی ترتیب در آنها تعبیه نشده است.شبکه‌های عصبی مکرر (RNNs)<sup class="footnote-ref" id="fnref-7"><a href="#fn-7" rel="footnote">7</a></sup> خانواده‌ای از شبکه‌های عصبی برای پردازش وظایف مبتنی بر توالی هستند. همانطور که شبکه‌های عصبی پیچشی (CNNs)<sup class="footnote-ref" id="fnref-8"><a href="#fn-8" rel="footnote">8</a></sup>، ویژه پردازش یک تور<sup class="footnote-ref" id="fnref-9"><a href="#fn-9" rel="footnote">9</a></sup> از مقادیر، برای مثال یک تصویر، طراحی شده‌اند؛ یک RNN نیز همسو با پردازش یک توالی از مقادیر ورودی <div class="math" dir="ltr">x\quad =\quad <{ x }^{ (1) },\quad { x }^{ (2) },\quad ...,\quad { x }^{ (n) }></div>ساخته شده است [2]. خروجی RNNها نیز مانند ورودی آنها در اغلب وظایف یک توالی است. این قابلیت پردازش توالی توسط شبکه‌های عصبی، آنها را برای استفاده در وظایف NLP، بسیار درخور ساخته است.</p>
<h2><strong>شرح مسئله و اهمیت موضوع</strong></h2>
<p>برخلاف انعطاف پذیری و قدرت بالای RNNها، در حالت ساده این شبکه‌ها یک توالی ورودی با طول ثابت را به یک توالی خروجی با همان طول نگاشت می‌کنند. این موضوع اما یک محدودیت جدی است؛ زیرا، بسیاری از مسائل مهم، در قالب توالی‌هایی که طولشان از قبل مشخص نیست، به‌ بهترین شکل قابل بیان هستند و در نظر گرفتن یک طول ثابت از پیش تعیین شده برای ورودی و خروجی به خوبی مسئله را مدل نمی‌کند. برای مثال ترجمه ماشینی (MT)<sup class="footnote-ref" id="fnref-10"><a href="#fn-10" rel="footnote">10</a></sup> و تشخیص گفتار<sup class="footnote-ref" id="fnref-11"><a href="#fn-11" rel="footnote">11</a></sup> مسائلی از این دست هستند. همچنین سیستم پرسش و پاسخ را نیز می‌توان به صورت نگاشت یک توالی از واژه‌ها به‌عنوان پرسش، به یک توالی دیگر از واژه‌ها به عنوان پاسخ، در نظر گرفت. بنابراین پُر واضح است که ایجاد یک روش مستقل از دامنه برای یادگـیری نگاشت توالی‌به‌تولی مفید و قابل توجیه خواهد بود [1].</p>
<h2><strong>اهداف و راهکارها</strong></h2>
<p>همانطور که دیدیم طیف وسیعی از وظایف NLP مبتنی بر نگاشت توالی‌های با طول نامشخص و متغیر به یکدیگر است. همچنین روش‌های سنتی مثل n-garm دارای محدودیت‌های خاص خود در حل این دسته مسائل هستند و استفاده از روش‌های یادگیری ژرف به وضوح امید بخش بوده است. بنابراین هدف ارایه یک مدل مبتنی بر RNNها جهت نگاشت توالی‌به‌توالی است. در این گـزارش راهکار مطرح شده در [1] و نتایج آن به‌تفصیل شرح داده می‌شود.<br>
     Stuskever و همکاران [1] نشان دادند که چگونه یک کاربرد ساده از شبکه با معماری حافظه کوتاه‌مدت بلند (LSTM)<sup class="footnote-ref" id="fnref-12"><a href="#fn-12" rel="footnote">12</a></sup> می‌تواند مسائل نگاشت توالی‌به‌توالی را حل کند. ایده اصلی استفاده از یک LSTM برای خواندن توالی ورودی، به‌صورت یک نمونه در هر مرحله زمانی، جهت اقتباس برداری بزرگ با بعد ثابت و سپس استفاده از یک LSTM دیگر برای استخراج توالی خروجی از آن بردار است. LSTM دوم دقیقا یک مدل زبانی مبتنی بر RNN است با این تفاوت که حاوی احتمال شرطی نسبت به توالی ورودی نیز هست. قابلیت LSTM در یادگیری موفق وابستگی‌های مکانی طولانی مدت نهفته درون توالی‌ها، آن را برای استفاده در مدل پیشنهادی مناسب ساخته است. ‏شکل (1) یک طرح‌واره از این مدل را به صورت عام نشان می‌دهد.<br>
<figure><img src="https://boute.s3.amazonaws.com/290-fig1.PNG" alt="شکل (1) یک طرح‌واره از مدل توالی‌به‌توالی متشکل از دو RNN. این مدل توالی ABC را به‌عنوان ورودی خوانده و توالی WXYZ را به‌عنوان خروجی تولید می‌کند. مدل پس از تولید نشانه EOS روند پیش‌بینی خود را متوقف می‌کند [1]. "><figcaption>شکل (1) یک طرح‌واره از مدل توالی‌به‌توالی متشکل از دو RNN. این مدل توالی ABC را به‌عنوان ورودی خوانده و توالی WXYZ را به‌عنوان خروجی تولید می‌کند. مدل پس از تولید نشانه EOS روند پیش‌بینی خود را متوقف می‌کند [1]. </figcaption></figure></p>
<h2><strong>داده‌ها و نتایج</strong></h2>
<p>مدل پیشنهادی در بخش قبل، برروی وظیفه ترجمه ماشینی عصبی (NMT)<sup class="footnote-ref" id="fnref-13"><a href="#fn-13" rel="footnote">13</a></sup> مورد آزمایش قرار گرفته است. برای انجام آزمایش‌ها از مجموعه داده ترجمه انگلیسی به فرانسوی WMT’14 استفاده شده است [3]. همچنین مجموعه داده کوچکتری در [4] وجود دارد که برای آموزش مدل‌های آزمایشی و غیر واقعی مناسب است. این مجموعه شامل ترجمه‌های انگلیسی به فارسی نیز هست.<br>
 نتایج حاصل شده از این کار بدین قرار است. بر روی مجموعه داده WMT’14 با استخراج مستقیم ترجمه از پنج LSTM ژرف با 380 میلیون پارامتر، در نهایت امتیاز BLEU معادل 34.81 کسب گردیده است. این امتیاز بالاترین امتیازی است که تا زمان ارایه این مقاله از طریق NMT حاصل شده است. به‌عنوان مقایسه امتیاز BLEU برای ترجمه ماشینی آماری (SMT)<sup class="footnote-ref" id="fnref-14"><a href="#fn-14" rel="footnote">14</a></sup> برروی همین مجموعه داده برابر 33.30 است. این درحالی است که امتیاز 34.81 با احتساب اندازه واژه‌نامه 80هزار کلمه به‌دست آمده و هرجا که کلمه ظاهر شده در ترجمه مرجع در واژه‌نامه نبوده این امتیاز جریمه شده است. بنابراین نتایج نشان می‌دهد که یک معماری مبتنی بر شبکه عصبی تقریبا غیر بهینه، که نقاط زیادی برای بهبود دارد، قادر است تا روش‌های سنتی مبتنی بر عبارتِ سیستم SMT را شکست دهد [1].</p>
<p dir="ltr"> <br/></p>
<h1><strong>مفاهیم اولیه</strong></h1>
<p>در این قسمت پیرامون سه مفهوم اصلی گزارش پیشرو، یعنی مدل زبانی (LM)<sup class="footnote-ref" id="fnref-15"><a href="#fn-15" rel="footnote">15</a></sup>، شبکه‌های عصبی مکرر و ترجمه ماشینی عصبی، به‌صورت مختصر توضیحاتی ارایه می‌گردد. </p>
<h2><strong>مدل زبانی</strong></h2>
<p>مدل زبانی یک مفهوم پایه در NLP است که امکان پیش‌بینی نشانه بعدی در یک توالی را فراهم می‌کند. به‌بیان دقیق‌تر LM عبارت است از یک توزیع احتمالی روی یک توالی از نشانه‌ها (اغلب واژه‌ها) که احتمال وقوع یک توالی داده شده را مشخص می‌کند. در نتیجه می‌توان بین چندین توالی داده شده برای مثال چند جمله، آن را که محتمل‌تر است، انتخاب کرد [5]. LM برای توالی<br>
<div class="math" dir="ltr">x\quad =\quad <{ x }^{ (1) },\quad { x }^{ (2) },\quad ...,\quad { x }^{ (n) }></div><br>
عبارت است از:<br>
<figure><img src="https://boute.s3.amazonaws.com/290-rel1.PNG" alt=""></figure><br>
مدل‌های سنتی n-gram برای غلبه بر چالش‌های محاسباتی، با استفاده از فرض مارکوف رابطه ‏(1) را به درنظر گرفتن تنها n-1 نشانه قبلی محدود می‌کنند. به‌همین دلیل برای توالی‌های طولانی (بیشتر از 4 یا 5 نشانه) و دیده نشده مناسب نیستند. مدل‌های زبانی عصبی (NLMs)<sup class="footnote-ref" id="fnref-16"><a href="#fn-16" rel="footnote">16</a></sup> که بر مبنای شبکه‌های عصبی عمل پیش‌بینی واژه بعدی را انجام می‌دهند، در ابتدا برای کمک به n-gramها با آنها ترکیب شدند که منجر به ایجاد پیچیدگی‌های زیادی شد؛ در حالی که مشکل توالی‌های طولانی همچنان وجود داشت [5]. اخیرا اما، معماری‌های جدیدی برای LM که کاملا بر اساس DNNها است، ایجاد شده‌اند. سنگ‌بنای این مجموعه معماری‌ها RNNها بوده که در بخش بعدی معرفی می‌شوند.</p>
<h2><strong>شبکه‌های عصبی مکرر</strong></h2>
<p>شبکه‌های عصبی مکرر کلاسی از شبکه‌‌های عصبی هستند که به‌صورت یک <strong><em>گراف جهت‌دار دوری</em></strong> بیان می‌شوند. به‌عبارت دیگر ورودی هریک از لایه(های) پنهان یا خروجی علاوه بر خروجی لایه قبل، شامل ورودی از مرحله قبل به‌صورت بازخورد نیز می‌شود. شکل (2) یک RNN را نشان می‌دهد. همانطور که پیداست، لایه پنهان از مراحل قبلی هم بازخورد می‌گیرد. در هر مرحله‌زمانی t از (t=1  تا t=n) یک بردار x<sup>(t)</sup> از توالی ورودی<br>
<div class="math" dir="ltr">x\quad =\quad <{ x }^{ (1) },\quad { x }^{ (2) },\quad ...,\quad { x }^{ (n) }></div><br>
 پردازش می‌شود. در حالت کلی معادله‌های بروزرسانی (گذرجلو<sup class="footnote-ref" id="fnref-17"><a href="#fn-17" rel="footnote">17</a></sup>) یک RNN در t عبارتند از [2]:<br>
 <figure><img src="https://boute.s3.amazonaws.com/290-rel2_5.PNG" alt=""></figure><br>
 که در آن بردارهای b و c بایاس و ماتریس‌‌های <em>U</em>، <em>V</em> و <em>W</em> به‌ترتیب وزن یال‌‌های لایه ورودی به پنهان، پنهان به خروجی و پنهان به پنهان، تشکیل‌دهنده مجموعه پارامترهای شبکه هستند. &Phi; تابع انگیزش است که معمولا یکی از توابع ReLU<sup class="footnote-ref" id="fnref-18"><a href="#fn-18" rel="footnote">18</a></sup> یا سیگموید<sup class="footnote-ref" id="fnref-19"><a href="#fn-19" rel="footnote">19</a></sup> انتخاب می‌شود. لایه آخر را نیز تابع بیشینه هموار<sup class="footnote-ref" id="fnref-20"><a href="#fn-20" rel="footnote">20</a></sup> تشکیل می‌دهد که احتمال وقوع هر نشانه خروجی را مشخص می‌کند.<br>
<figure><img src="https://boute.s3.amazonaws.com/290-fig2.PNG" alt="شکل (2) گراف محاسباتی مربوط به یک نوع RNN که یک توالی ورودی از مقادیر x را به یک توالی خروجی از مقادیر o نگاشت می‌کند. فرض شده است که خروجی o احتمالات نرمال نشده است، بنابراین خروجی واقعی شبکه یعنی &ycirc; از اعمال تابع بیشینه هموار روی o حاصل می‌شود. چپ: RNN به‌صورت یال بازگشتی. راست: همان شبکه به‌صورت باز شده در زمان، به‌نحوی که هر گره با یک برچسب زمانی مشخص شده است [2]."><figcaption>شکل (2) گراف محاسباتی مربوط به یک نوع RNN که یک توالی ورودی از مقادیر x را به یک توالی خروجی از مقادیر o نگاشت می‌کند. فرض شده است که خروجی o احتمالات نرمال نشده است، بنابراین خروجی واقعی شبکه یعنی &ycirc; از اعمال تابع بیشینه هموار روی o حاصل می‌شود. چپ: RNN به‌صورت یال بازگشتی. راست: همان شبکه به‌صورت باز شده در زمان، به‌نحوی که هر گره با یک برچسب زمانی مشخص شده است [2].</figcaption></figure><br>
در ‏شکل (2)، RNN با یک لایه پنهان نشان داده شده است. اما می‌توان RNNژرف با چندین لایه پنهان نیز داشت. همچنین طول توالی‌‌های ورودی و خروجی می‌تواند بسته به مسئله مورد نظر متفاوت باشد. karpathy  در [6]  RNNها را از منظر طول توالی ورودی و طول توالی خروجی به چند دسته تقسیم‌بندی کرده است. شکل (3) این دسته‌بندی را نشان می‌دهد.<br>
<figure><img src="https://boute.s3.amazonaws.com/290-fig3.PNG" alt="شکل (3) طرح واره‌ای از حالت‌‌های مختلف RNN. (الف):شبکه عصبی استاندارد، (ب):شبکه یک به چند، (پ): شبکه چند به یک، (ت)و (ث): شبکه‌های چند به چند [6]."><figcaption>شکل (3) طرح واره‌ای از حالت‌‌های مختلف RNN. (الف):شبکه عصبی استاندارد، (ب):شبکه یک به چند، (پ): شبکه چند به یک، (ت)و (ث): شبکه‌های چند به چند [6].</figcaption></figure><br>
تصویر karpathy از حالت‌های مختلف RNN بعد از انتشار مقاله منتخب در این گزارش  می‌باشد؛ با این حال در بخش 4 خواهیم دید که چگونه می‌توان از ترکیب این طرح‌ها نیز برای ایده معماری توالی‌به‌تولی الهام گرفت.</p>
<h2><strong>ترجمه ماشینی عصبی</strong></h2>
<p>به‌طور کلی MT را می توان با یک LM که به جمله زبان مبدأ مشروط شده است، مدل‌سازی کرد. بر همین اساس NMT را می‌توان یک مدل زبانی مکرر در نظر گرفت که مستقیما احتمال شرطی p(y|x) را در ترجمه جمله زبان مبدأ<br>
<div class="math" dir="ltr">x\quad =\quad <{ x }^{ (1) },\quad { x }^{ (2) },\quad ...,\quad { x }^{ (n) }></div>به جمله زبان مقصد<br>
<div class="math" dir="ltr">y\quad =\quad <{y }^{ (1) },\quad { y }^{ (2) },\quad ...,\quad { y }^{ (m) }></div>مدل می‌کند. دقت شود که طول جمله مبدأ یعنی n و جمله مقصد یعنی m الزاما برابر نیست. بنابراین در NMT هدف محاسبه این احتمال و سپس استفاده از آن در تولید جمله به زبان مقصد، هر دو به کمک DNNها است [5].</p>
<p><br/></p>
<h1><strong>کارهای مرتبط</strong></h1>
<p>کارهای زیادی در زمینه NLMs انجام شده است. در بیشتر این کارها از شبکه‌های عصبی روبه‌جلو یا مکرر استفاده شده و کاربرد آن معمولا در یک وظیفه MT با امتیازدهی مجدد n فهرست بهتر<sup class="footnote-ref" id="fnref-21"><a href="#fn-21" rel="footnote">21</a></sup>، اعمال شده و نتایج آن معمولا نشان از بهبود امتیازهای قبلی داشته است [1].<br>
اخیرا کارهایی در زمینه فشردن اطلاعات زبان مبدأ در NLM انجام شده است. برای نمونه Auli و همکاران [7] NLM را با مدل عنوان<sup class="footnote-ref" id="fnref-22"><a href="#fn-22" rel="footnote">22</a></sup> جمله ورودی ترکیب کرده‌اند که نتایج بهبود بخشی داشته است. کار انجام شده در مقاله [1] به کار [8] بسیار نزدیک است. در مقاله [8] نویسندگان برای اولین بار توالی ورودی را در یک بردار فشرده کرده و سپس آن را به توالی خروجی تبدیل کردند. البته در این کار، برای تبدیل توالی به بردار، از CNNs استفاده شده که ترتیب واژه‌ها را حفظ نمی‌کند. چُـــو و همکاران [9] یک معماری شبهِ LSTM را برای نگاشت توالی ورودی به بردار و سپس استخراج توالی خروجی و نهایتا ترکیب آن با SMT استفاده کرده‌اند. معماری آنها از دو RNN با عنوان‌های کدگذار و کدگشا تشکیل شده که RNN اول وظیفه تبدیل یک توالی با طول متغیر به یک بردار با طول ثابت را قابل یک سلول زمینه c دارد و RNN دوم وظیفه تولید توالی خروجی را با لحاظ کردن c و نماد شروع جمله مقصد بر عهده دارد. معماری پیشنهادی آنها تحت عنوان کلی  RNNکدگذار-کدگشا در ‏شکل (4) نشان داده شده است. چون آنها از LSTM استفاده نکرده و بیشتر تلاش خود را معطوف به ترکیب این روش با مدل‌های قبلی SMT کرده‌اند، برای توالی‌های ورودی و خروجی طولانی همچنان مشکل عدم حفظ حافظه وجود دارد.<br>
Bahdanau و همکاران [10] یک روش ترجمه مستقیم با استفاده از شبکه عصبی پیشنهاد داده‌اند که از سازوکار <em>attention</em> برای غلبه بر کارآمدی ضعیف روش [9] روی جملات طولانی استفاده می‌کند و به نتایج مطلوبی دست یافتند. </p>
<p><figure><img src="https://boute.s3.amazonaws.com/290-fig4.PNG" alt="شکل (4) مدل RNN کدگذار-کدگشا، که برای یادگـیری تولید توالی خروجی  y  از روی توالی ورودی x  با استخراج سلول حافظه c از توالی ورودی، به‌کار می‌رود [2]."><figcaption>شکل (4) مدل RNN کدگذار-کدگشا، که برای یادگـیری تولید توالی خروجی  y  از روی توالی ورودی x  با استخراج سلول حافظه c از توالی ورودی، به‌کار می‌رود [2].</figcaption></figure></p>
<p><br/></p>
<h1><strong>مدل توالی‌به‌توالی</strong></h1>
<p>در مدل توالی‌به‌توالی از دو RNN با واحدهای LSTM استفاده شده است. هدف LSTM در اینجا تخمین احتمال شرطی<br>
<div class="math" dir="ltr">p(<{ y }^{ (1) },\quad ...,\quad { y }^{ (m) }>\quad |\quad <{ x }^{ (1) },\quad ...,\quad { x }^{ (n) }>)</div><br>
است که قبلا هم دیده بودیم (بخش 2-3). LSTM این احتمال شرطی را ابتدا با اقتباس بازنمایی بعد ثابت v برای توالی ورودی<br>
<div class="math" dir="ltr"><{ x }^{ (1) },\quad ...,\quad { x }^{ (n) }></div><br>
از آخرین مقدار حالت پنهان و در ادامه با محاسبه احتمال<br>
<div class="math" dir="ltr"><{ y }^{ (1) },\quad ...,\quad { y }^{ (m) }></div><br>
از رابطه استاندارد مطرح در LM (رابطه (1)) و درنظر گرفتن  برای حالت پنهان آغازین به‌صورت داده شده در رابطه زیر، حساب می‌کند:<br>
<figure><img src="https://boute.s3.amazonaws.com/290-rel6.PNG" alt=""></figure><br>
در رابطه ‏(6) هر توزیع احتمالی<br>
<div class="math" dir="ltr">p({ y }^{ (t) }\quad |\quad v,\quad y^{ (1) },\quad ...,\quad y^{ (t-1) })</div><br>
به‌وسیله یک تابع بیشینه هموار روی همه واژه‌های داخل واژه‌نامه بازنمایی می‌شود. برای LSTM از روابط [11] استفاده شده است. هر جمله در این مدل نیاز است تا با یک علامت خاص مثل EOS خاتمه یابد. این امر مدل را قادر می‌سازد تا بتواند توزیع احتمالی را روی توالی با هر طول دلخواهی تعریف کند. شمای کلی مدل در شکل (1) نشان داده شده است. در این شکل LSTM بازنمایی توالی ورودی<br>
<div class="math" dir="ltr"><'A','B','C',EOS></div>را حساب و سپس از این بازنمایی برای محاسبه احتمال توالی خروجی<br>
<div class="math" dir="ltr"><'W','X','Y','Z',EOS></div><br>
استفاده می‌کند. در عین حال این مدل را می‌توان ترکیبی از قسمت‌های پ و ت شکل (3) دانست.<br>
مدل پیاده‌سازی شده در عمل از سه جنبه با مدل معرفی شده در بالا تفاوت دارد. اول، از دو LSTM جداگانه استفاده شده است: یکی برای توالی ورودی و دیگری برای توالی خروجی؛ زیرا، انجام این کار پارامترهای مدل را با هزینه محاسباتی اندکی، به تعداد بسیار زیادی افزایش می‌دهد. دوم اینکه LSTMهای ژرف به‌شکل قابل توجهی LSTMهای سطحی را شکست می‌دهند، به همین دلیل LSTM با ژرفای چهار لایه به‌کار گرفته شده است. سوم اینکه نویسندگان در این مقاله یافته‌اند که وارون کردن توالی ورودی در سرعتِ همگرایی آموزش شبکه و نیز دقت پیش‌بینی آن تأثیر شگرفی ایفا می‌کند. بنابراین به‌جای نگاشت مستقیم توالی  a,b,c  به توالی &alpha;, &beta;, &gamma;  شبکه LSTM برای نگاشت c,b,a به &alpha;, &beta;, &gamma; آموزش داده می‌شود که در آن &alpha;, &beta;, &gamma;  ترجمه یا خروجی متناظر با همان a,b,c است. توجیه علت این پدیده آن است که در نگاشت به شیوه وارون ابتدای عبارت‌ها که متناظر با یکدیگر هستند به‌هم نزدیک شده و این امر سبب زودتر همگرا شدن الگوریتم  کاهش گرادیان تصادفی (SGD) و نزدیک شدن به مقادیر بهینه می‌شود [1].</p>
<h2><strong>آموزش شبکه</strong></h2>
<p>مدل توالی‌‌به‌توالی پس از معرفی توسط Sutskever و همکاران [1]، بارها و بارها تا به امروز مورد ارجاع دیگران قرار گرفته و تبدیل به یک مدل مرجع در NMT شده است. این مدل در رساله دکتری آقای لانگ [5] به‌تفصیل و همراه با برخی اصلاحات توضیح داده شده است. در این بخش به برخی جزئیات آموزش شبکه مدل توالی‌به‌توالی می‌پردازیم.<br>
شکل (5) یک نمایش دقیق‌تر از مدل ذکر شده در شکل (1) را نشان می‌دهد. آموزش شبکه بدین نحو است: ابتدا جمله زبان مقصد، سمت راست جمله متناظر خود در زبان مبدأ قرار داده می‌شود. نشان ‘-‘ در اینجا نقش EOS را دارد که البته می‌تواند پایان جمله مبدأ یا آغاز جمله مقصد را مشخص کند. بنابراین به هر کدام از دو گروه قابل تعلق است. LSTM سمت چپ یا همان شبکه کدگذار، در هر مرحله‌زمانی یک واژه از جمله زبان مبدأ را خوانده پس از تبدیل به نمایش مناسب حالت داخلی لایه پنهان را بروزرسانی می‌کند. در مرحله پردازش آخرین واژه مقادیر لایه‌های پنهان بردار ثابت که اکنون نماینده کل جمله ورودی زبان مبدأ است را تشکیل می‌دهد. سپس LSTM دوم یا شبکه کدگشا اولین واژه زبان مقصد را به همراه بردار v، به‌عنوان ورودی دریافت می‌کند و پیشبینی خود را انجام می‌دهد. برچسب واقعی این داده در واقع واژه بعدی در جمله زبان مقصد است. پس از مقایسه و محاسبه خطا، الگوریتم پس‌انتشار روی هر دو شبکه با شروع از شبکه کدگشا اجرا می‌شود و پارامترها را در خلاف جهت گرادیان تنظیم می‌کند. این روند تا پایان یافتن جمله زبان مقصد ادامه پیدا می‌کند. البته در عمل ممکن است ورودی به صورت یک دسته<sup class="footnote-ref" id="fnref-23"><a href="#fn-23" rel="footnote">23</a></sup> به شبکه داده شود.<br>
<figure><img src="https://boute.s3.amazonaws.com/290-fig5wc.PNG" alt="شکل (5) نمایش نحوه عملکرد و آموزش مدل‌ توالی‌‌به‌توالی روی وظیفه ترجمه ماشینی عصبی  [5]."><figcaption>شکل (5) نمایش نحوه عملکرد و آموزش مدل‌ توالی‌‌به‌توالی روی وظیفه ترجمه ماشینی عصبی  [5].</figcaption></figure><br>
در مرحله آزمون به جای مقایسه با برچسب و محاسبه خطا فقط احتمال آمدن واژه بعدی محاسبه و واژه از روی واژگان پیدا می‌شود. سپس خروجی مرحله t به عنوان ورودی مرحله t+1 به شبکه کدگشا داده می‌شود. این روش اصطلاحا teacher forcing نامیده می‌شود[2].</p>
<h2><strong>جزئیات آموزش شبکه</strong></h2>
<p>در مقاله [1] از LSTMژرف با چهار لایه و 1000 سلول حافظه در هر لایه استفاده شده است. همچنین اندازه واژگان ورودی 160هزار و اندازه واژگان خروجی 80هزار کلمه است. حاصل کار یک شبکه LSTM با مجموع 380میلیون پارامتر بوده که 64میلیون آن اتصالات برگشتی هستند. دیگر جزئیات پارامترها و آموزش شبکه عبارتند از:</p>
<ul>
<li><p>پارامترها با مقادیر تصادفی از توزیع یکنواخت در بازه [0.08+ و 0.08-] مقداردهی اولیه شده‌اند.</p></li>
<li><p>برای آموزش از SGD استاندارد با نرخ یادگیری 0.7 استفاده شده است. بعد از گذشت پنج دوره<sup class="footnote-ref" id="fnref-24"><a href="#fn-24" rel="footnote">24</a></sup>، نرخ یادگیری در هر نیم‌دور، نصف می‌شود. در ضمن تعداد کل دوره‌های آموزش برابر 7.5 بوده است.</p></li>
<li><p>گرادیان بر روی دسته‌های 128تایی از توالی‌ها محاسبه شده و به اندازه دسته، یعنی 128، تقسیم می‌شود.</p></li>
<li><p>هرچند LSTMها از معضل میرایی گرادیان<sup class="footnote-ref" id="fnref-25"><a href="#fn-25" rel="footnote">25</a></sup> رنج نمی‌برند، اما ممکن است مشکل انفجار گرادیان<sup class="footnote-ref" id="fnref-26"><a href="#fn-26" rel="footnote">26</a></sup> را داشته باشند. بنابراین محدودیت سختی بر مقدار نورم گرادیان اعمال می‌شود به‌این نحو که هنگامی که نورم از مقدار آستانه‌ای بیشتر شد، مجددا تنظیم شود. برای هر دسته در مجموعه آموزش مقدار<br>
<div class="math" dir="ltr">s={ ||g|| }_{ 2 }</div></p></li>
</ul>
<p>محاسبه می‌شود که در آن g مقدار گرادیان پس از تقسیم بر 128 است. اگر  s&gt;5 شد آنگاه قرار داده می‌شود:<br>
<div class="math" dir="ltr">g=\frac { 5g }{ s }.</div> </p>
<ul>
<li><p>جملات مختلف طول‌های مختلفی دارند. بیشتر آنها کوتاه هستند (طولی بین 20 تا 30 دارند) اما برخی از آنها طولانی هستند (طولی بیشتر از 100 دارند)؛ بنابراین دسته‌های 128تایی از جملات که تصادفی انتخاب می‌شوند تعداد کمی جمله طولانی داشته و تعداد زیادی جمله کوتاه و در نتیجه سبب می‌شود تا بیشتر محاسبات داخل هر دسته هدر روند. برای غلبه بر این موضوع سعی شده است همه جملات داخل یک دسته طول تقریبا مساوی داشته باشند. این امر انجام محاسبات را تا 2 برابر تسریع کرده ‌است.</p></li>
</ul>
<p><br/></p>
<h1><strong>آزمایش‌ها</strong></h1>
<p>روش یادگیری توالی‌به‌توالی معرفی شده روی وظیفه ترجمه ماشینی انگلیسی به فرانسوی در دو حالت مختلف آزمایش گردیده است. در حالت اول مدل، برای ترجمه مستقیم جملات انگلیسی به فرانسوی به‌کار گرفته شده و در حالت دوم برای امتیاز دهی مجدد n فهرست بهتر از جملات در وظیفه SMT استفاده شده است. در این قسمت نتایج آزمایش‌های انجام گرفته در قالب امتیازهای ترجمه کسب شده، نمونه جملات ترجمه شده و بلاخره مصورسازی بازنمایی جملات ورودی، بیان شده است.</p>
<h2><strong>پیاده‌سازی</strong></h2>
<p>پیاده‌سازی مدل اولیه با زبان ++C انجام شده است. این پیاده‌سازی از LSTM ژرف با پیکربندی شرح داده شده در بخش 4-1-2 روی یک GPU، تقریبا 1700 واژه بر ثانیه را پردازش می‌کند. این سرعت برای پردازش حجم داده  زیادی مثل مجموعه WMT بسیار پایین است. برای این منظور مدل به صورت موازی شده روی 8 عدد GPU اجرا می‌گردد. هر لایه از LSTM روی یک GPU اجرا شده و فعالیت‌های خود را به محض محاسبه به GPU یا لایه بعدی می‌دهد. چون مدل چهار لایه دارد، چهار GPU دیگر برای موازی‌سازی بیشینه هموار استفاده شده‌اند بنابراین هر GPU مسئول محاسبه یک ضرب ماتریسی (ماتریس با اندازه 2000 × 1000) است. نتیجه حاصل از این موازی‌سازی در سطح GPU، رسیدن به سرعت پردازش 6300 واژه بر ثانیه است. فرایند آموزش در این شیوه پیاده‌سازی، 10 روز به طول انجامید [1].<br>
علاوه بر پیاده‌سازی اولیه، پیاده‌سازی‌های دیگری نیز از این مدل در زبان‌ها و چهارچوب‌های مختلف ارایه شده است؛ از جمله دو پیاده‌سازی خوب با زبان پایتون و روی چهارچوب‌های کاری Tensorflow و Keras. پیاده‌سازی Tensorflow سازوکارهای جدیدتر مثل سازوکار <em>attention</em> را نیز اضافه کرده است [12]. پیاده‌سازی Keras هم به جای واژه، در <strong>سطح کاراکتر</strong> انجام شده است [13]. اگرچه در همه پیاده‌سازی‌ها  ترجمه ماشینی، به‌عنوان وظیفه انتخاب شده است. اما این مدل عام بود و برای هر وظیفه‌ای که شامل نگاشت یک توالی ورودی به یک توالی خروجی با طول‌های متفاوت است، قابل اعمال خواهد بود.</p>
<h2><strong>جزئیات مجموعه داده</strong></h2>
<p>همانطور که قبلا گفته شد (بخش ‏3-1) از مجموعه داده ترجمه انگلیسی به فرانسوی WMT’14 در آزمایش‌ها استفاده شده است [3]. مدل توصیف شده روی یک زیرمجموعه 12میلیون جمله‌ای، شامل 348میلیون واژه فرانسوی و 340میلیون واژه انگلیسی، آموزش داده شده است. وظیفه ترجمه ماشینی و همچنین این مجموعه داده خاص، به خاطر دردسترس بودن عمومی یک مجموعه آموزش و یک مجموعه آزمون نشانه‌گذاری شده<sup class="footnote-ref" id="fnref-29"><a href="#fn-29" rel="footnote">27</a></sup> جهت اهداف آموزش و ارزیابی مدل انتخاب شده است و مدل توالی‌به‌تولی مستقل از یک وظیفه خاص است.<br>
همچنان‌که مدل‌های زبانی عصبی معمولی روی یک بازنمایی برداری در نمایش هر کلمه تکیه می‌کنند، در اینجا نیز یک واژه‌نامه با اندازه ثابت، برای هر دو زبان به‌کار گرفته شده است. برای این منظور، 160هزار واژه از پر استفاده‌ترین واژه‌های زبان مبدأ (انگلیسی) و نیز 80هزار واژه از پر استفاده‌ترین واژه‌های زبان مقصد (فرانسوی) برگزیده شده‌اند. هر واژه خارج از این واژه‌نامه‌ها که در جمله‌ها ظاهر شده باشد، با نشانه خاص “UNK” جایگزین شده است.<br>
برای پیاده‌سازی [12] از مجموعه داده ترجمه آلمانی-انگلیسی WMT’16 [14] استفاده شده است و همچنین مدل نمونه پیاده‌سازی شده در [13] از مجموعه داده کوچکتر موجود در [4] استفاده کرده است که قابل جایگزین کردن با مجموعه‌های ذکر شده در بالا نیز هست. ایراد اساسی پیاده‌سازی در سطح کاراکتر [13] این است که معمولا در ترجمه ماشینی واژه‌ها به یکدیگر متناظر می‌شوند نه کاراکترها لذا این مدل از دقت مدل‌های در سطح واژه برخوردار نیست اما ایده خوبی در مورد استفاده در سایر وظایف مبتنی بر نگاشت توالی‌به‌توالی نظیر تولید متن به دست می‌دهد.</p>
<h2><strong>کدگشایی و امتیازدهی مجدد</strong></h2>
<p>هسته اصلی آزمایش‌های انجام شده در [1]، آموزش یک LSTM ژرف بزرگ روی تعداد زیادی جفت از جمله‌های زبان مبدأ و زبان مقصد است. آموزش با بیشینه کردن احتمال لگاریتمی یک ترجمه صحیح T برای جمله مبدأ داده شده S انجام می‌شود. بنابراین هدف آموزش عبارت است از:<br>
<figure><img src="https://boute.s3.amazonaws.com/290-rel7.PNG" alt=""></figure><br>
که در آن <strong>S</strong> مجموعه آموزش است. وقتی آموزش کامل شد، ترجمه‌ها با یافتن درست‌ترین ترجمه از روی LSTM تولید می‌شوند:<br>
<figure><img src="https://boute.s3.amazonaws.com/290-rel8.PNG" alt=""></figure><br>
برای یافتن درست‌ترین ترجمه از یک کدگشای ساده با جست‌وجوی پرتوی محلی<sup class="footnote-ref" id="fnref-30"><a href="#fn-30" rel="footnote">28</a></sup> چپ به راست استفاده شده است که تعداد B فرضیه جزئی<sup class="footnote-ref" id="fnref-31"><a href="#fn-31" rel="footnote">29</a></sup> را نگه‌داری می‌کند. هر فرضیه جزئی پیشوندی از تعدادی ترجمه است. در هر مرحله زمانی، هر فرضیه جزئی با واژه‌های محتمل از داخل واژه‌نامه گسترش داده می‌شود. این روند تعداد فرایض جزئی را به‌سرعت افزایش می‌دهد. با توجه به مدل احتمال لگاریتمی، تمام این فرضیه‌ها به غیر از B فرضیه محتمل اول کنار گذاشته می‌شوند. به‌مجرد اینکه نشانه “EOS” به یک فرضیه الصاق شد، از جست‌وجوی پرتوی محلی حذف و به مجموعه فرایض کامل افزوده می‌گردد. هرچند این روش کدگشایی تقریبی است؛ اما، برای پیاده‌سازی راحت خواهد بود. سیستم پیشنهادی حتی با اندازه پرتوی 1 و نیز اندازه پرتوی 2 بیشترین مزایای این روش جست‌وجو را فراهم می‌آورد. امتیازهای BLEU حاصله از آزمایش‌های انجام شده روی مدل، در جدول (1) ذکر شده‌ است.</p>
<h2><strong>وارون‌سازی جملات مبدأ</strong></h2>
<p>درحالی‌که LSTM قابلیت حل مسائل با وابستگی‌های طولانی مدت را دارد، در طول آزمایش‌های انجام شده در [1] پژوهشگران یافته‌اند که وقتی جمله‌های مبدأ وارون شده و به‌عنوان ورودی به  شبکه کدگذار داده می‌شوند، LSTM بهتر آموزش می‌بیند. توجه شود که جملات مقصد وارون نمی‌شوند. با انجام این عمل ساده، مقدار سرگشتگی<sup class="footnote-ref" id="fnref-32"><a href="#fn-32" rel="footnote">30</a></sup> مدل از 5.8 به 4.7 کاهش یافته‌است و مقدار امتیاز BLEU کسب شده از ترجمه‌های کدگشایی شده مدل نیز از 25.9 به 30.6 افزایش داشته است.<br>
نویسندگان [1] توضیح کاملی برای توجیه اثر این پدیده نداشته‌اند. توجیه اولیه آنها بدین ترتیب است که عمل وارون‌سازی جملات زبان مبدأ باعث معرفی بسیاری از وابستگی‌های کوتاه مدت به مجموعه داده می‌شود. وقتی جمله‌های زبان مبدأ را با جمله‌های زبان مقصد الحاق می‌کنیم، هر واژه در جمله مبدأ از واژه نظیرش در جمله مقصد دور می‌افتد. در نتیجه، مسئله یک دارای یک <em>تأخیر زمانی کمینه</em><sup class="footnote-ref" id="fnref-33"><a href="#fn-33" rel="footnote">31</a></sup> خیلی بزرگ می‌شود [1]. با وارون‌سازی واژه‌ها در جمله مبدأ فاصله میانگین بین واژه‌های نظیر به نظیر در جمله‌ مبدأ با جمله مقصد تغییر نمی‌کند. هرچند تعداد کمی از واژه‌های آغازین جمله مبدأ در این حالت به واژه‌های آغازین جمله مقصد بسیار نزدیک می‌شوند؛ بنابراین تأخیر زمانی کمینه مسئله تا حد زیادی کاهش می‌یابد و الگوریتم پس‌انتشار زمان کمتری را برای استقرار ارتباط میان واژه‌های جمله‌های مبدأ و جمله‌های مقصد سپری خواهد نمود. این امر درنهایت منجربه بهبود قابل توجه کارآمدی کلی مدل می‌گردد.<br>
ایده وارون‌سازی جمله‌های ورودی از این مهم نشئت گرفته است که در ابتدا تصور شده وارون‌سازی فقط به پیش‌بینی با اطمینان‌تر واژه‌های آغازین در زبان مقصد کمک می‌کند و منجربه پیش‌بینی کم اطمینان‌تر واژه‌های پایانی می‌شود. هرچند LSTMای که روی جملات مبدأ وارون شده آموزش دیده، در مقایسه با LSTM معمولی، روی جمله‌های طولانی عملکرد بهتری از خود نشان داده است (رجوع شود به بخش ‏1-6). </p>
<h2><strong>ارزیابی نـتایج</strong></h2>
<p>به‌منظور ارزیابی کیفیت ترجمه‌های صورت گرفته توسط مدل از روش امتیازدهی خودکار BLEU [16] استفاده شده است. برای محاسبه امتیاز BLEU، اسکریپت آماده multi-bleu.pl<sup class="footnote-ref" id="fnref-34"><a href="#fn-34" rel="footnote">32</a></sup> به‌کار رفته است. این نوع امتیاز دهی در کارهای قبلی مشابه نیز استفاده شده است [9] و [10]، بنابراین قابل اطمینان خواهد بود و مقایسه مدل‌ها را امکان‌پذیر می‌سازد. به‌عنوان نمونه، این اسکریپت برای [10] امتیاز 28.45 را تولید کرده است. نتایج در جدول‌های (1) و (2) ارایه شده‌اند. بهترین نتیجه از مجموعه LSTMهایی که در مقداردهی اولیه تصادفی و ترتیب تصادفی ریزدسته‌ها تفاوت داشته‌اند، حاصل شده است. هرچند سازوکار کدگشایی ترجمه به‌کار برده شده در اینجا (جست‌وجوی پرتوی محلی)، سازوکار ساده و ضعیفی است؛ با این حال نخستین بار است که یک سیستم ترجمه ماشینی عصبی خالص، سیستم ترجمه ماشینی مبتنی بر عبارات را با اختلاف قابل توجهی شکست می‌دهد. این سیستم همچنین فاقد قابلیت کنترل واژه‌های خارج از واژه‌نامه است و همان‌طور که قبلا هم بیان شد کلیه واژه‌های بیرون از واژه‌نامه با واژه “UNK” جایگزین شده‌اند. بنابراین در صورتی که سازوکاری برای کنترل این واژه‌ها نیز به مدل اضافه شود یا اندازه واژه‌نامه افزایش یابد، عملکرد این سیستم باز هم جای بهبود خواهد داشت.</p>
<p><br/></p>
<p align="center">
جدول (1) کارآمدی LSTM روی مجموعه آزمون ترجمه انگلیسی به فرانسوی WMT’14 (ntst14). توجه شود که یک مجموعه متشکل از پنج LSTM با اندازه پرتوی 2، ارزان‌تر (سبک‌تر) از یک LSTM تنها با اندازه پرتوی 12 است [1].
</p><table>
<thead><tr>
<th align="center"><strong>روش</strong></th>
<th align="center"><strong>امتیاز BLEU (ntst14)</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">Bahdanau و همکاران [10]</td>
<td align="center">28.45</td>
</tr>
<tr>
<td align="center">یک LSTM روبه‌جلو، اندازه پرتوی 12</td>
<td align="center">26.17</td>
</tr>
<tr>
<td align="center">یک LSTM با ورودی وارون، اندازه پرتوی 12</td>
<td align="center">30.59</td>
</tr>
<tr>
<td align="center">پنج LSTM با ورودی وارون، اندازه پرتوی 1</td>
<td align="center">33.00</td>
</tr>
<tr>
<td align="center">دو LSTM با ورودی وارون، اندازه پرتوی 12</td>
<td align="center">33.27</td>
</tr>
<tr>
<td align="center">پنج LSTM با ورودی وارون، اندازه پرتوی 21</td>
<td align="center">34.50</td>
</tr>
<tr>
<td align="center">پنج LSTM با ورودی وارون، اندازه پرتوی 12</td>
<td align="center"><strong>34.81</strong></td>
</tr>
</tbody>
</table>
<p><br/></p>
<p align="center">
جدول (2) روش‌های مشابه که شبکه‌های عصبی را در کنار ترجمه ماشینی سنتی روی مجموعه داده WMT’14 در ترجمه انگلیسی به فرانسوی استفاده کرده‌اند [1].
</p><table>
<thead><tr>
<th align="center"><strong>روش</strong></th>
<th align="center"><strong>امتیاز BLEU (ntst14)</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">لـبه پژوهش [15]</td>
<td align="center"><strong>37.00</strong></td>
</tr>
<tr>
<td align="center">چــو و همکاران [9]</td>
<td align="center">34.54</td>
</tr>
<tr>
<td align="center">امتیازدهی مجدد 1000فهرست بهتر با یک LSTM روبه‌جلو</td>
<td align="center">35.61</td>
</tr>
<tr>
<td align="center">امتیازدهی مجدد1000فهرست بهتر با یک LSTM وارون</td>
<td align="center">35.85</td>
</tr>
<tr>
<td align="center">امتیازدهی مجدد1000فهرست بهتر با پنج LSTM وارون</td>
<td align="center"><strong>36.50</strong></td>
</tr>
<tr>
<td align="center">پیش‌گویی امتیازدهی مجدد 1000فهرست بهتر</td>
<td align="center">45~</td>
</tr>
</tbody>
</table>
<h2><strong>تحلیل مدل</strong></h2>
<p>یکی از ویژگی‌های جذاب مدل توالی‌به‌توالی ارایه شده در [1]، توانایی تبدیل یک توالی از واژه‌ها به یک بردار با ابعاد ثابت است. شکل (6) تعدادی از بازنمایی‌های یادگرفته شده در روند آموزش را مصورسازی کرده است. این تصویر به وضوح نشان می‌دهد که بازنمایی‌های ایجاد شده به ترتیب واژه‌ها حساس هستند؛ زیرا از جمله‌هایی با واژه‌های یکسان و ترتیب متفاوت در تصویر استفاده شده است. بازنمایی واقعی مدل در ابعاد بالاتری بود و برای نگاشت روی دو بعد روش PCA به‌کار برده شده است.</p>
<p><figure><img src="https://boute.s3.amazonaws.com/290-fig6.PNG" alt="شکل (6) این شکل یک تصویر PCA دوبعدی از حالت‌های پنهان LSTM را نشان می‌دهد که پس از پردازش جمله‌های نشان داده شده در شکل، گرفته شده است. عبارات با توجه به معنایشان خوشه‌بندی شده‌اند که معنا در این مثال به طور عمده تابعی از ترتیب ظاهر شدن واژه‌ها در عبارت است. رسیدن به چنین خوشه‌بندی با روش‌های سنتی موجود، سخت است. توجه شود که در همه جمله‌ها واژه‌های یکسانی استفاده شده و تنها ترتیب ظاهر شدن آنها،  تفاوت ایجاد کرده است [1]. دایره‌های کوچک در شکل اعداد دو بعد تصویر شده جمله را نشان می‌دهند."><figcaption>شکل (6) این شکل یک تصویر PCA دوبعدی از حالت‌های پنهان LSTM را نشان می‌دهد که پس از پردازش جمله‌های نشان داده شده در شکل، گرفته شده است. عبارات با توجه به معنایشان خوشه‌بندی شده‌اند که معنا در این مثال به طور عمده تابعی از ترتیب ظاهر شدن واژه‌ها در عبارت است. رسیدن به چنین خوشه‌بندی با روش‌های سنتی موجود، سخت است. توجه شود که در همه جمله‌ها واژه‌های یکسانی استفاده شده و تنها ترتیب ظاهر شدن آنها،  تفاوت ایجاد کرده است [1]. دایره‌های کوچک در شکل اعداد دو بعد تصویر شده جمله را نشان می‌دهند.</figcaption></figure></p>
<h2><strong>کارآمدی روی جملات طولانی</strong></h2>
<p>خروجی مدل روی جمله‌های طولانی (از منظر تعداد واژه) کارآمدی بسیار خوب LSTM را در این زمینه تأیید می‌کند. یک مقایسه کمی از نتایج حاصل شده در شکل (7) نشان داده شده است. همچنین جدول (3) چندین جمله طولانی و ترجمه‌های تولید شده توسط مدل برای آنها را ارایه می‌کند.<br>
<br/></p>
<p><figure><img src="https://boute.s3.amazonaws.com/290-fig7.PNG" alt="شکل (7) نمودار سمت چپ کارآمدی سیستم را به‌عنوان تابعی از طول جمله‌ها نشان می‌دهد که محور افقی در آن طول واقعی جمله‌ها بر حسب تعداد واژه‌های آنها است. کاهش امتیازی در جملاتی با طول کمتر از 35 واژه وجود ندارد. تنها یک کاهش جزئی در جمله‌های خیلی طولانی مشاهده می‌شود. نمودار سمت راست کارآمدی LSTM را روی جمله‌هایی با واژه‌های کمتر به‌کار رفته نشان می‌دهد که محور افقی در آن جمله‌های آزمایش شده برحسب میانگین تکرار واژه‌هایشان است [1]."><figcaption>شکل (7) نمودار سمت چپ کارآمدی سیستم را به‌عنوان تابعی از طول جمله‌ها نشان می‌دهد که محور افقی در آن طول واقعی جمله‌ها بر حسب تعداد واژه‌های آنها است. کاهش امتیازی در جملاتی با طول کمتر از 35 واژه وجود ندارد. تنها یک کاهش جزئی در جمله‌های خیلی طولانی مشاهده می‌شود. نمودار سمت راست کارآمدی LSTM را روی جمله‌هایی با واژه‌های کمتر به‌کار رفته نشان می‌دهد که محور افقی در آن جمله‌های آزمایش شده برحسب میانگین تکرار واژه‌هایشان است [1].</figcaption></figure></p>
<p><p align="center">جدول (3) سه مثال از ترجمه‌های طولانی تولید شده توسط مدل توالی‌به‌توالی در مقایسه با ترجمه صحیح. خواننده می‌تواند صحت نتایج را با استفاده از مترجم گوگل تا حد خوبی درک کند [1].</p><figure><img src="https://boute.s3.amazonaws.com/290-table3.PNG" alt=" "><figcaption> </figcaption></figure><br>
<br/></p>
<h1><strong>نتیجه‌گیری و کارهای آتی</strong></h1>
<p>در این گزارش یک مدل یادگیری ژرف جدید برای یادگیری و نگاشت توالی از ورودی‌ها به توالی از خروجی‌ها مطرح و بحث گردید. نشان داده شد که یک شبکه LSTM ژرف با واژگان محدود روی وظیفه ترجمه ماشینی، قادر به شکست سیستم‌های ترجمه ماشینی استاندارد مبتنی بر عبارات با واژگان نامحدود است. موفقیت این رویکرد نسبتا ساده روی وظیفه ترجمه ماشینی نشان دهنده این است که این مدل باید روی دیگر وظیفه‌های مبتنی بر توالی نیز در صورت فراهم بودن مجموعه داده‌های آموزش کافی، بسیار خوب عمل کند.<br>
در طی فرایند آموزش این اصل نیز کشف شده که وارون سازی توالی مبدأ سبب افزایش دقت و بهبود کارآمدی مدل می‌شود. می‌توان نتیجه گرفت پیدا کردن روشی که وابستگی‌های کوتاه مدت را زودتر معرفی کند در هر صورت آموزش مدل را خیلی ساده‌تر می‌کند. لذا به نظر می‌رسد که حتی آموزش یک RNN استاندارد (مدل غیر توالی‌به‌توالی) نیز با این روش بهتر باشد. البته این مورد در عمل مورد آزمایش قرار نگرفته است و بنابراین به صورت یک فرضیه باقی است.<br>
نتیجه قابل ذکر دیگر، قابلیت LSTM در یادگیری صحیح ترجمه توالی‌های طولانی است. در ابتدا تصور می‌شد که LSTM به دلیل حافظه محدود خود در یادگیری جمله‌های طولانی شکست بخورد؛ همچنان‌که پژوهشگران دیگر در کارهای مشابه عملکرد ضعیفی را برای LSTM گزارش کرده بودند. با این حال اما روی جمله‌های خیلی طولانی در حالت وارون همچنان مشکل تضعیف حافظه پابرجاست و احتمالا قابلیت بهبود داشته باشد.   در نهایت نتایج رضایت بخش این مدل یادگیری نشان دهنده این است که یک مدل ساده از شبکه‌های عصبی ژرف، که هنوز جای بهبود و بهینه‌سازی‌های زیادی در خود دارد، قادر به شکست بالغ‌ترین سیستم‌های ترجمه ماشینی سنتی است. کارهای آتی می‌تواند بر روی افزایش دقت مدل توالی‌به‌توالی و پیچیده‌تر کردن آن در راستای یادگیری بهتر توالی‌های طولانی باشد. در آینده نزدیک این مدل‌ها روش‌های سنتی را کاملا منسوخ می‌کنند. نتایج همچنین نشان می‌دهد این رویکرد روی دیگر وظیفه‌های مبتنی بر نگاشت توالی‌به‌توالی می‌تواند موفقیت آمیز ظاهر شود. این مهم، زمینه را برای حل مسائل مختلفی در دیگر حوزه‌های علوم آماده می‌سازد.</p>
<p><br/></p>
<p><strong><h2>مراجع</h2></strong></p>
<p dir="ltr">[1]      Q.V. Le Ilya Sutskever, Oriol Vinyals, I. Sutskever, O. Vinyals, and Q. V. Le, “Sequence to sequence learning with neural networks,” <em>Nips</em>, pp. 1–9, 2014.<br>
[2]      I. Goodfellow, Y. Bengio, and A. Courville, <em>Deep learning</em>. MIT Press, 2016.<br>
[3]      “ACL 2014 ninth workshop on statistical machine translation.” [Online]. Available: <a href="http://www.statmt.org/wmt14/medical-task/index.html">http://www.statmt.org/wmt14/medical-task/index.html</a>. [Accessed: 13-Nov-2017].<br>
[4]      “Tab-delimited bilingual bentence pairsfrom the tatoeba project (good for anki and similar flashcard applications).”[Online]. Available: <a href="http://www.manythings.org/anki/">http://www.manythings.org/anki/</a>. [Accessed: 13-Nov-2017].<br>
[5]      M. T. Luong, “Neural machine translation,” Stanford university, 2016.<br>
[6]      A. Karpathy, “Connecting images and natural language,” Stanford University, 2016.<br>
[7]      M. Auli, M. Galley, C. Quirk, and G. Zweig, “Joint language and translation modeling with recurrent neural networks.,” <em>Emnlp</em>, no. October, pp. 1044–1054, 2013.<br>
[8]      N. Kalchbrenner and P. Blunsom, “Recurrent continuous translation models,” <em>Emnlp</em>, no. October, pp. 1700–1709, 2013.<br>
[9]      K. Cho <em>et al.</em>, “Learning phrase representations using RNN encoder-decoder for statistical machine translation,” 2014.<br>
[10]    D. Bahdanau, K. Cho, and Y. Bengio, “Neural machine translation by jointly learning to align and translate,” pp. 1–15, 2014.<br>
[11]    A. Graves, “Generating sequences with recurrent neural networks,” pp. 1–43, 2013.<br>
[12]    M.-T. Luong, E. Brevdo, and R. Zhao, “Neural machine translation (seq2seq) tutorial,” <em><a href="https://github.com/tensorflow/nmt">https://github.com/tensorflow/nmt</a></em>, 2017.<br>
[13]    “Sequence to sequence example in Keras (character-level),” 2017. [Online]. Available: <a href="https://github.com/fcholle/keras/blob/master/examples/lstm_seq2seq.py">https://github.com/fcholle/keras/blob/master/examples/lstm_seq2seq.py</a>. [Accessed: 13-Nov-2017].<br>
[14]    “Index of /wmt16/translation-task.” [Online]. Available: <a href="http://data.statmt.org/wmt16/translation-task/.[Accessed">http://data.statmt.org/wmt16/translation-task/.[Accessed</a>: 04-Dec-2017].<br>
[15]    N. Durrani, B. Haddow, P. Koehn, and K. Heafield, “Edinburgh’s phrase-based machine translation systems for WMT-14,” <em>Proc. Ninth Work. Stat. Mach. Transl.</em>, pp. 97–104, 2014.<br>
[16]    K. Papineni, S. Roukos, T. Ward, and W. Zhu, “BLEU: A method for automatic evaluation of machine translation,” <em>… 40Th Annu. Meet. …</em>, no. July, pp. 311-318,2002.</p>
<p><br/></p>
<hr>
<p><strong><h2>واژه‌نامه</h2></strong></p>
<p><strong><h3 align = "center">واژه‌نامه فـارســی به انگلـیسی</h3></strong></p>
<table>
<thead><tr>
<th align="center"><strong>واژه‌‌ی فـارسی</strong></th>
<th align="center"></th>
<th align="center"><strong>معادل انگلیسی</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">انفجار گرادیان</td>
<td align="center"></td>
<td align="center">Exploding Gradient</td>
</tr>
<tr>
<td align="center">بانظارت</td>
<td align="center"></td>
<td align="center">Supervised</td>
</tr>
<tr>
<td align="center">پردازش زبان طبیعی</td>
<td align="center"></td>
<td align="center">Natural Language Processing (NLP)</td>
</tr>
<tr>
<td align="center">پس‌انتشار</td>
<td align="center"></td>
<td align="center">Backpropagation</td>
</tr>
<tr>
<td align="center">تابع بیشینه هموار</td>
<td align="center"></td>
<td align="center">Softmax Function</td>
</tr>
<tr>
<td align="center">تأخیر زمانی کمینه</td>
<td align="center"></td>
<td align="center">Minimal Time Lag</td>
</tr>
<tr>
<td align="center">ترجمه ماشینی</td>
<td align="center"></td>
<td align="center">Machine Translation (MT)</td>
</tr>
<tr>
<td align="center">ترجمه ماشینی آماری</td>
<td align="center"></td>
<td align="center">Statistical Machine Translation (SMT)</td>
</tr>
<tr>
<td align="center">ترجمه ماشینی عصبی</td>
<td align="center"></td>
<td align="center">Neural Machine Translation (NMT)</td>
</tr>
<tr>
<td align="center">تشخیص گفتار</td>
<td align="center"></td>
<td align="center">Speech Recognition</td>
</tr>
<tr>
<td align="center">توالی</td>
<td align="center"></td>
<td align="center">Sequence</td>
</tr>
<tr>
<td align="center">جست‌وجوی پرتوی محلی</td>
<td align="center"></td>
<td align="center">Beam Search</td>
</tr>
<tr>
<td align="center">حافظه کوتاه مدت بلند</td>
<td align="center"></td>
<td align="center">Long-Short Term Memory (LSTM)</td>
</tr>
<tr>
<td align="center">دسته</td>
<td align="center"></td>
<td align="center">Batch</td>
</tr>
<tr>
<td align="center">دوره</td>
<td align="center"></td>
<td align="center">Epoch</td>
</tr>
<tr>
<td align="center">سرگشتگی</td>
<td align="center"></td>
<td align="center">Perplexity</td>
</tr>
<tr>
<td align="center">شبکه عصبی پیچشی</td>
<td align="center"></td>
<td align="center">Convolutional Neural Network (CNN)</td>
</tr>
<tr>
<td align="center">شبکه عصبی رو به جلو ژرف</td>
<td align="center"></td>
<td align="center">Deep Feed-forward Neural Network</td>
</tr>
<tr>
<td align="center">شبکه عصبی ژرف</td>
<td align="center"></td>
<td align="center">Deep Neural Network (DNN)</td>
</tr>
<tr>
<td align="center">شبکه عصبی مکرر</td>
<td align="center"></td>
<td align="center">(RNN) Recurrent Neural Network</td>
</tr>
<tr>
<td align="center">فرضیه جزئی</td>
<td align="center"></td>
<td align="center">Partial Hypothesis</td>
</tr>
<tr>
<td align="center">کدگذار</td>
<td align="center"></td>
<td align="center">Encoder</td>
</tr>
<tr>
<td align="center">کدگشا</td>
<td align="center"></td>
<td align="center">Decoder</td>
</tr>
<tr>
<td align="center">گذر جلو</td>
<td align="center"></td>
<td align="center">Forward Pass</td>
</tr>
<tr>
<td align="center">مدل زبانی</td>
<td align="center"></td>
<td align="center">Language Model (LM)</td>
</tr>
<tr>
<td align="center">مدل زبانی عصبی</td>
<td align="center"></td>
<td align="center">Neural Language Model (NLM)</td>
</tr>
<tr>
<td align="center">میرایی گرادیان</td>
<td align="center"></td>
<td align="center">Vanishing Gradient</td>
</tr>
<tr>
<td align="center">نشانه‌گذاری شده</td>
<td align="center"></td>
<td align="center">Tokenized</td>
</tr>
</tbody>
</table>
<p><br/></p>
<p><strong> پانوشت‌ها</strong></p>
<div class="footnotes">
<hr>
<ol><li dir="ltr" id="fn-1"><p dir="ltr">deep neural networks</p>
</li>
<li dir="ltr" id="fn-2"><p dir="ltr">backpropagation</p>
</li>
<li dir="ltr" id="fn-3"><p dir="ltr">supervised</p>
</li>
<li dir="ltr" id="fn-4"><p dir="ltr">natural language processing</p>
</li>
<li dir="ltr" id="fn-5"><p dir="ltr">sequence</p>
</li>
<li dir="ltr" id="fn-6"><p dir="ltr">deep feed-forward neural networks</p>
</li>
<li dir="ltr" id="fn-7"><p dir="ltr">recurrent neural networks</p>
</li>
<li dir="ltr" id="fn-8"><p dir="ltr">convolutional neural networks</p>
</li>
<li dir="ltr" id="fn-9"><p dir="ltr">grid</p>
</li>
<li dir="ltr" id="fn-10"><p dir="ltr">machine translation</p>
</li>
<li dir="ltr" id="fn-11"><p dir="ltr">speech recognition</p>
</li>
<li dir="ltr" id="fn-12"><p dir="ltr">long-short term memory</p>
</li>
<li dir="ltr" id="fn-13"><p dir="ltr">neural machine translation</p>
</li>
<li dir="ltr" id="fn-14"><p dir="ltr">statistical machine translation</p>
</li>
<li dir="ltr" id="fn-15"><p dir="ltr">language model</p>
</li>
<li dir="ltr" id="fn-16"><p dir="ltr">neural language models</p>
</li>
<li dir="ltr" id="fn-17"><p dir="ltr">forward pass</p>
</li>
<li dir="ltr" id="fn-18"><p dir="ltr">rectified linear unit</p>
</li>
<li dir="ltr" id="fn-19"><p dir="ltr">sigmoid</p>
</li>
<li dir="ltr" id="fn-20"><p dir="ltr">softmax function</p>
</li>
<li dir="ltr" id="fn-21"><p dir="ltr">n-best list</p>
</li>
<li dir="ltr" id="fn-22"><p dir="ltr">topic model</p>
</li>
<li dir="ltr" id="fn-23"><p dir="ltr">batch</p>
</li>
<li dir="ltr" id="fn-24"><p dir="ltr">epoch</p>
</li>
<li dir="ltr" id="fn-25"><p dir="ltr">vanishing gradient</p>
</li>
<li dir="ltr" id="fn-26"><p dir="ltr">exploding gradient</p>
</li>
<li dir="ltr" id="fn-29"><p dir="ltr">tokenized</p>
</li>
<li dir="ltr" id="fn-30"><p dir="ltr">beam search</p>
</li>
<li dir="ltr" id="fn-31"><p dir="ltr">partial hypothesis</p>
</li>
<li dir="ltr" id="fn-32"><p dir="ltr">perplexity</p>
</li>
<li dir="ltr" id="fn-33"><p dir="ltr">minimal time lag</p>
</li>
<li id="fn-34"><p>چندین نوع محاسبه از امتیاز BLEU وجود دارد کــه هر نوع با یک اسکریپت زبان perl تعریف شده است.</p>
</li>
</ol>
</div>
</body> 
 </html>