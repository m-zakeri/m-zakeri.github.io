<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Morteza Zakeri</title><link href="https://m-zakeri.github.io/" rel="alternate"></link><link href="https://m-zakeri.github.io/feeds/all.atom.xml" rel="self"></link><id>https://m-zakeri.github.io/</id><updated>2025-03-20T20:30:00+03:30</updated><subtitle>PhD in Computer Science</subtitle><entry><title>Services of the Intelligent Software Engineering Laboratory</title><link href="https://m-zakeri.github.io/services-of-the-intelligent-software-engineering-laboratory.html" rel="alternate"></link><published>2025-03-20T20:30:00+03:30</published><updated>2025-03-20T20:30:00+03:30</updated><author><name>Morteza</name></author><id>tag:m-zakeri.github.io,2025-03-20:/services-of-the-intelligent-software-engineering-laboratory.html</id><summary type="html">&lt;p&gt;Find all of our services here.&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;strong&gt;Amirkabir University of Technology (Tehran Polytechnic)&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;Author:&lt;/strong&gt; &lt;a href="https://www.m-zakeri.ir/pages/contact-me.html" target="_blank"&gt;Morteza Zakeri&lt;/a&gt;
&lt;strong&gt;Version:&lt;/strong&gt; 1.0 (March 2025)&lt;/p&gt;
&lt;h2&gt;Introduction&lt;/h2&gt;
&lt;p&gt;This document presents a comprehensive list of services offered by the Intelligent Software Engineering Laboratory at Amirkabir University of Technology (Tehran Polytechnic). The services span multiple facets of software engineering—including testing, quality assurance, secure coding, requirements engineering, and development methodologies. The items listed herein are categorized by group, level, and service code to facilitate both clarity and ease of ordering.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.m-zakeri.ir/pages/contact-me.html" target="_blank"&gt;&lt;strong&gt;Contact and order now&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2&gt;Services&lt;/h2&gt;
&lt;h3&gt;Group 1: Software Product Testing and Quality Assurance (Group Code: 1)&lt;/h3&gt;
&lt;h4&gt;Level 1: Basic Practical Training Courses (Level 1) (Order Code: 11)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Service 1.1.1: Functional Testing of Software&lt;/strong&gt;&lt;br&gt;
&lt;em&gt;Details:&lt;/em&gt; Testing levels, testing culture, tester roles, unit testing, integration testing, and system testing.&lt;br&gt;
&lt;em&gt;Order Code:&lt;/em&gt; 111&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Service 1.1.2: Security Testing&lt;/strong&gt;&lt;br&gt;
&lt;em&gt;Details:&lt;/em&gt; Stress testing, fault injection, fuzz testing, penetration testing, and penetration test scenarios.&lt;br&gt;
&lt;em&gt;Order Code:&lt;/em&gt; 112&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Service 1.1.3: Performance Testing&lt;/strong&gt;&lt;br&gt;
&lt;em&gt;Details:&lt;/em&gt; Basic testing, smoke tests, load testing, stress testing, capacity testing, load increase, stability assessment, breaking point determination, rapid change and stress testing, performance evaluation metrics, and performance test scenarios.&lt;br&gt;
&lt;em&gt;Order Code:&lt;/em&gt; 113&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Level 2: Advanced Practical Training Courses (Level 2) (Order Code: 12)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Service 1.2.1: Advanced Software Testing&lt;/strong&gt;&lt;br&gt;
&lt;em&gt;Details:&lt;/em&gt; Mutation testing, regression testing, model-based testing, model-driven testing, continuous testing, testing and evaluation of machine learning models (Software 2.0), test suite augmentation and optimization, and super testing.&lt;br&gt;
&lt;em&gt;Order Code:&lt;/em&gt; 121&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Service 1.2.2: Automated Software Testing&lt;/strong&gt;&lt;br&gt;
&lt;em&gt;Details:&lt;/em&gt; Automated test generation, injection and monitoring of test data, random-adaptive testing, search-based testing, symbolic (execution) testing, and concrete-symbolic (execution) testing.&lt;br&gt;
&lt;em&gt;Order Code:&lt;/em&gt; 122&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Service 1.2.3: Software Debugging&lt;/strong&gt;&lt;br&gt;
&lt;em&gt;Details:&lt;/em&gt; Dynamic analysis, spot analysis, fault localization, fault prediction, and program repair.&lt;br&gt;
&lt;em&gt;Order Code:&lt;/em&gt; 123&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Service 1.2.4: Deployment of Tools for Testing, Debugging, and Dynamic Analysis&lt;/strong&gt;&lt;br&gt;
&lt;em&gt;Details:&lt;/em&gt; Identification and deployment of tools, frameworks, platforms, and studios for testing, debugging, and dynamic analysis.&lt;br&gt;
&lt;em&gt;Order Code:&lt;/em&gt; 124&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Level 3: Customized Training in Software Testing and Quality Assurance (Order Code: 13)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Service 1.3:&lt;/strong&gt; Customized training course—tailored selection from the above topics.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Level 4: Engineering, Consulting, and Product Development Services (Order Code: 14)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Service 1.4.1: Functional Testing for Legacy Codebases&lt;/strong&gt;&lt;br&gt;
&lt;em&gt;Details:&lt;/em&gt; Applicable to web, mobile, and desktop applications.&lt;br&gt;
&lt;em&gt;Order Code:&lt;/em&gt; 141&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Service 1.4.2: Functional Testing for Codebases Under Development&lt;/strong&gt;&lt;br&gt;
&lt;em&gt;Details:&lt;/em&gt; Applicable to web, mobile, and desktop applications.&lt;br&gt;
&lt;em&gt;Order Code:&lt;/em&gt; 142&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Service 1.4.3: Installation and Deployment of Automated Testing Tools&lt;/strong&gt;&lt;br&gt;
&lt;em&gt;Details:&lt;/em&gt; Tools installed in accordance with the product development stack (including LLM-based tools and compilers).&lt;br&gt;
&lt;em&gt;Order Code:&lt;/em&gt; 143&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Service 1.4.4: Evaluation of Testing Efficiency and Estimation of Test Code Technical Debt&lt;/strong&gt;&lt;br&gt;
&lt;em&gt;Details:&lt;/em&gt; Measurement of testability for web, mobile, desktop, embedded systems, and Software 2.0 projects and estimation of associated technical debt.&lt;br&gt;
&lt;em&gt;Order Code:&lt;/em&gt; 144&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Service 1.4.5: Optimization and Enhancement of Test Suites, and Vulnerability Remediation&lt;/strong&gt;&lt;br&gt;
&lt;em&gt;Details:&lt;/em&gt; Optimization and strengthening of the test suite for software projects (web, mobile, desktop, embedded systems, Software 2.0) with a reduction of test code technical debt and remediation of vulnerabilities.&lt;br&gt;
&lt;em&gt;Order Code:&lt;/em&gt; 145&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Service 1.4.6: Security Testing Service&lt;/strong&gt;&lt;br&gt;
&lt;em&gt;Details:&lt;/em&gt; Applicable to web, mobile, desktop, embedded systems, and Software 2.0.&lt;br&gt;
&lt;em&gt;Order Code:&lt;/em&gt; 146&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Service 1.4.7: Performance Testing Service&lt;/strong&gt;&lt;br&gt;
&lt;em&gt;Details:&lt;/em&gt; Applicable to web, mobile, desktop, embedded systems, and Software 2.0.&lt;br&gt;
&lt;em&gt;Order Code:&lt;/em&gt; 147&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Service 1.4.8: Consulting on Quality Assurance and Testing Standards&lt;/strong&gt;&lt;br&gt;
&lt;em&gt;Details:&lt;/em&gt; Guidance on recognizing and implementing software product quality assurance and testing standards.&lt;br&gt;
&lt;em&gt;Order Code:&lt;/em&gt; 148&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Level 5: Issuance of Software Product Quality Certificate (External Quality) (Order Code: 15)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Service 1.5:&lt;/strong&gt; Quality Certification Service.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Level 6: Customized Engineering, Consulting, and Product Development in Testing and Quality Assurance (Order Code: 16)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Service 1.6:&lt;/strong&gt; Customized services as selected from the above topics.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3&gt;Group 2: Software Development Quality Assurance Group (Group Code: 2)&lt;/h3&gt;
&lt;h4&gt;Level 1: Basic Practical Training Courses (Level 1) (Order Code: 21)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Service 2.1.1: Clean Code&lt;/strong&gt;&lt;br&gt;
&lt;em&gt;Details:&lt;/em&gt; Naming conventions, SOLID principles, functions, classes, comments, and code formatting.&lt;br&gt;
&lt;em&gt;Order Code:&lt;/em&gt; 211&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Service 2.1.2: Clean Architecture&lt;/strong&gt;&lt;br&gt;
&lt;em&gt;Details:&lt;/em&gt; Architecture types, architectural styles, architectural descriptions, the 4+1 view, clean architecture principles, and distance from the main sequence.&lt;br&gt;
&lt;em&gt;Order Code:&lt;/em&gt; 212&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Service 2.1.3: Clean Coder&lt;/strong&gt;&lt;br&gt;
&lt;em&gt;Details:&lt;/em&gt; Decision-making (knowing when to say yes or no), teamwork, time management, estimation, pressure management, and version control for both product and test code.&lt;br&gt;
&lt;em&gt;Order Code:&lt;/em&gt; 213&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Service 2.1.4: Secure Coding&lt;/strong&gt;&lt;br&gt;
&lt;em&gt;Details:&lt;/em&gt; Data validation, authentication and authorization, encryption, session management, exception handling, meeting security requirements, and code obfuscation.&lt;br&gt;
&lt;em&gt;Order Code:&lt;/em&gt; 214&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Level 2: Advanced Practical Training Courses (Level 2) (Order Code: 22)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Service 2.2.1: Principles and Patterns in Software Engineering&lt;/strong&gt;&lt;br&gt;
&lt;em&gt;Details:&lt;/em&gt; Topics include SOLID, PHAME, analysis patterns, design patterns, architecture patterns, anti-patterns, and refactoring patterns.&lt;br&gt;
&lt;em&gt;Order Code:&lt;/em&gt; 221&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Service 2.2.2: Techniques for Program Transformation and Automated Software Refactoring&lt;/strong&gt;&lt;br&gt;
&lt;em&gt;Details:&lt;/em&gt; Program transformation, repackaging, automated refactoring, and automatic measurement of software quality attributes.&lt;br&gt;
&lt;em&gt;Order Code:&lt;/em&gt; 222&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Service 2.2.3: Software Reengineering and Migration Techniques&lt;/strong&gt;&lt;br&gt;
&lt;em&gt;Details:&lt;/em&gt; Software clustering, extraction and migration of software architecture, and migration to System 2.0.&lt;br&gt;
&lt;em&gt;Order Code:&lt;/em&gt; 223&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Service 2.2.4: Deployment of Tools for Static Analysis and Quality Assurance&lt;/strong&gt;&lt;br&gt;
&lt;em&gt;Details:&lt;/em&gt; Identification and deployment of tools, frameworks, platforms, and studios for static analysis, refactoring, and ensuring the quality of software development.&lt;br&gt;
&lt;em&gt;Order Code:&lt;/em&gt; 224&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Level 3: Customized Training in Software Development Quality Assurance (Order Code: 23)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Service 2.3:&lt;/strong&gt; Customized training course—selection from the above topics.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Level 4: Engineering, Consulting, and Product Development Services (Order Code: 24)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Service 2.4.1: Evaluation of Internal Quality Attributes&lt;/strong&gt;&lt;br&gt;
&lt;em&gt;Details:&lt;/em&gt; Assessing software maintainability and evolvability through metrics such as testability, understandability, reusability, readability, modifiability, flexibility, rigidity, and analyzability.&lt;br&gt;
&lt;em&gt;Order Code:&lt;/em&gt; 241&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Service 2.4.2: Improvement of Internal Quality Attributes&lt;/strong&gt;&lt;br&gt;
&lt;em&gt;Details:&lt;/em&gt; Implementing measures to enhance maintainability and evolvability considering the aforementioned quality metrics.&lt;br&gt;
&lt;em&gt;Order Code:&lt;/em&gt; 242&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Service 2.4.3: Evaluation of External Quality Attributes – Dependability&lt;/strong&gt;&lt;br&gt;
&lt;em&gt;Details:&lt;/em&gt; Assessment of reusability, efficiency and scalability, security, safety, reliability, and accessibility.&lt;br&gt;
&lt;em&gt;Order Code:&lt;/em&gt; 243&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Service 2.4.4: Improvement of External Quality Attributes – Dependability&lt;/strong&gt;&lt;br&gt;
&lt;em&gt;Details:&lt;/em&gt; Enhancing reusability, efficiency and scalability, security, safety, reliability, and accessibility.&lt;br&gt;
&lt;em&gt;Order Code:&lt;/em&gt; 244&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Service 2.4.5: Implementation of Design by Contract and Source Code Clean-Up&lt;/strong&gt;&lt;br&gt;
&lt;em&gt;Details:&lt;/em&gt; Aligning development practices with Clean Code principles and reducing technical debt in the code.&lt;br&gt;
&lt;em&gt;Order Code:&lt;/em&gt; 245&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Service 2.4.6: Refactoring of Software Design and Source Code&lt;/strong&gt;&lt;br&gt;
&lt;em&gt;Details:&lt;/em&gt; Applying Clean Architecture principles to minimize design-related technical debt.&lt;br&gt;
&lt;em&gt;Order Code:&lt;/em&gt; 246&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Service 2.4.7: Software Reengineering and Architectural Migration&lt;/strong&gt;&lt;br&gt;
&lt;em&gt;Details:&lt;/em&gt; Migrating software architecture to scalable systems while reducing architectural technical debt.&lt;br&gt;
&lt;em&gt;Order Code:&lt;/em&gt; 247&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Service 2.4.8: Consulting and Mentoring on Software Quality Standards&lt;/strong&gt;&lt;br&gt;
&lt;em&gt;Details:&lt;/em&gt; Guidance on the implementation of standards such as ISO/IEC 25010.&lt;br&gt;
&lt;em&gt;Order Code:&lt;/em&gt; 248&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Level 5: Issuance of Software Development Quality Certificate (Internal Quality) (Order Code: 25)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Service 2.5:&lt;/strong&gt; Quality Certification Service.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Level 6: Customized Engineering, Consulting, and Product Development in Software Development Quality (Order Code: 26)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Service 2.6:&lt;/strong&gt; Customized services—selection from the above topics.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3&gt;Group 3: Software Requirements Engineering and Development Methodologies Group (Group Code: 3)&lt;/h3&gt;
&lt;h4&gt;Level 1: Basic Practical Training Courses (Level 1) (Order Code: 31)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Service 3.1.1: Agile Requirements Engineering&lt;/strong&gt;&lt;br&gt;
&lt;em&gt;Details:&lt;/em&gt; Extraction, analysis, and specification of requirements; use of requirement templates in agile software development; evaluation and improvement of requirement quality.&lt;br&gt;
&lt;em&gt;Order Code:&lt;/em&gt; 311&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Service 3.1.2: Introduction to Agile Software Development Approaches&lt;/strong&gt;&lt;br&gt;
&lt;em&gt;Details:&lt;/em&gt; Overview of practices such as TDD, BDD, DevOps, MLOps, and CICD.&lt;br&gt;
&lt;em&gt;Order Code:&lt;/em&gt; 312&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Service 3.1.3: Management of Software and IT Projects&lt;/strong&gt;&lt;br&gt;
&lt;em&gt;Details:&lt;/em&gt; Size and cost estimation, project status monitoring, and management of various types of technical debt.&lt;br&gt;
&lt;em&gt;Order Code:&lt;/em&gt; 313&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Level 2: Advanced Practical Training Courses (Level 2) (Order Code: 32)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Service 3.2.1: Automated Requirements Engineering&lt;/strong&gt;&lt;br&gt;
&lt;em&gt;Details:&lt;/em&gt; Detection and repair of requirement smells, generation of acceptance tests, creation of conceptual models from requirements, code generation from requirements, generating explanations from code, and repair of traceability links.&lt;br&gt;
&lt;em&gt;Order Code:&lt;/em&gt; 321&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Service 3.2.2: Systematic Research and Presentation in Software Engineering&lt;/strong&gt;&lt;br&gt;
&lt;em&gt;Details:&lt;/em&gt; Techniques such as SMS, SLR, MVLR, alongside computational thinking and reverse computation methods.&lt;br&gt;
&lt;em&gt;Order Code:&lt;/em&gt; 322&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Service 3.2.3: Compiler Engineering, Large Language Models, and Domain-Specific Languages&lt;/strong&gt;&lt;br&gt;
&lt;em&gt;Details:&lt;/em&gt; Design and development of DSLs for specialized querying, guided engineering, and data description.&lt;br&gt;
&lt;em&gt;Order Code:&lt;/em&gt; 323&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Service 3.2.4: Deployment of Tools for Requirements Engineering and Documentation&lt;/strong&gt;&lt;br&gt;
&lt;em&gt;Details:&lt;/em&gt; Identification and deployment of frameworks, platforms, and studios for managing requirements and project documents.&lt;br&gt;
&lt;em&gt;Order Code:&lt;/em&gt; 324&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Level 3: Customized Training Course (Order Code: 33)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Service 3.3:&lt;/strong&gt; Customized training course—selection from the above topics.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Level 4: Engineering, Consulting, and Product Development Services (Order Code: 34)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Service 3.4.1: Extraction and Modeling of Software Requirements Documentation&lt;/strong&gt;&lt;br&gt;
&lt;em&gt;Details:&lt;/em&gt; Analysis and modeling of requirements for new software systems.&lt;br&gt;
&lt;em&gt;Order Code:&lt;/em&gt; 341&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Service 3.4.2: Business Process Modeling (BPMN) and Creation of Services Based on System 2.0&lt;/strong&gt;&lt;br&gt;
&lt;em&gt;Details:&lt;/em&gt; Utilizing large language models to innovate service creation.&lt;br&gt;
&lt;em&gt;Order Code:&lt;/em&gt; 342&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Service 3.4.3: Designing Checklists and Generating Acceptance Tests for Software Validation&lt;/strong&gt;&lt;br&gt;
&lt;em&gt;Order Code:&lt;/em&gt; 343&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Service 3.4.4: Creating UML Conceptual Models from Requirements Documentation&lt;/strong&gt;&lt;br&gt;
&lt;em&gt;Order Code:&lt;/em&gt; 344&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Service 3.4.5: Database Design and Normalization&lt;/strong&gt;&lt;br&gt;
&lt;em&gt;Details:&lt;/em&gt; Designing and normalizing software databases in accordance with the software requirements documentation.&lt;br&gt;
&lt;em&gt;Order Code:&lt;/em&gt; 345&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Service 3.4.6: Creation and Deployment of Domain-Specific Languages (DSLs)&lt;/strong&gt;&lt;br&gt;
&lt;em&gt;Details:&lt;/em&gt; DSLs for development, guided engineering, and querying/reporting.&lt;br&gt;
&lt;em&gt;Order Code:&lt;/em&gt; 346&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Service 3.4.7: Extraction and Repair of Legacy Code Documentation&lt;/strong&gt;&lt;br&gt;
&lt;em&gt;Details:&lt;/em&gt; Addressing requirements, design, and implementation documentation for legacy codebases.&lt;br&gt;
&lt;em&gt;Order Code:&lt;/em&gt; 347&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Service 3.4.8: Creation and Repair of Traceability Links for Legacy Codebases&lt;/strong&gt;&lt;br&gt;
&lt;em&gt;Order Code:&lt;/em&gt; 348&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Level 5: Issuance of Software Requirements and Documentation Quality Certificate (Validation) (Order Code: 35)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Service 3.5:&lt;/strong&gt; Quality Certification Service.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Level 6: Customized Engineering, Consulting, and Product Development in Requirements Engineering and Software Methodologies (Order Code: 36)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Service 3.6:&lt;/strong&gt; Customized services—selection from the above topics.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;The Intelligent Software Engineering Laboratory at Amirkabir University of Technology (Tehran Polytechnic) provides a diverse range of services aimed at improving the efficiency, quality, and reliability of software systems. Our offerings encompass comprehensive training courses, targeted consulting services, and custom engineering solutions that address both current challenges and future requirements in software engineering. Whether your focus is on testing, quality assurance, secure development, or requirements engineering, our expertise can help guide your organization toward excellence.&lt;/p&gt;
&lt;h2&gt;Future Work&lt;/h2&gt;
&lt;p&gt;Looking ahead, our laboratory is committed to expanding our service portfolio by:
- Integrating advanced AI and machine learning techniques into testing and quality assurance processes.
- Developing cutting-edge tools and frameworks for automated refactoring and requirements engineering.
- Broadening our training programs to include emerging methods and best practices in modern software development.
- Enhancing our consulting services to better address the complexities of legacy systems and large-scale software infrastructures.&lt;/p&gt;
&lt;p&gt;We eagerly anticipate collaborating with industry partners and academic institutions to drive innovation and excellence in software engineering.&lt;/p&gt;
&lt;hr&gt;</content><category term="services"></category><category term="services"></category><category term="laboratory"></category></entry><entry><title>Advanced Software Testing</title><link href="https://m-zakeri.github.io/advanced-software-testing.html" rel="alternate"></link><published>2025-03-17T20:45:00+03:30</published><updated>2025-03-17T20:45:00+03:30</updated><author><name>Morteza</name></author><id>tag:m-zakeri.github.io,2025-03-17:/advanced-software-testing.html</id><summary type="html">&lt;p&gt;Advanced Software Testing, Graduate course.&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Advanced Software Testing&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;Graduate Course&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Course Description&lt;/h2&gt;
&lt;p&gt;This course delves into advanced topics and cutting-edge techniques in software testing, empowering students to design and implement rigorous testing strategies for modern software systems. By covering methods such as automatic test data generation, metamorphic testing, fuzzing, hyper-property testing, and program analysis, the course equips students with tools to detect, isolate, and resolve complex software issues. Emphasis is placed on automation, scalability, and the theoretical foundations of testing to address real-world challenges in software quality assurance.&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Course Objectives&lt;/h2&gt;
&lt;p&gt;By the end of this course, students will:
1. Understand the theoretical underpinnings of advanced software testing methodologies.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Develop practical skills in automated testing, including test data generation and fuzzing.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Apply advanced techniques such as metamorphic testing and abstract interpretation to tackle testing challenges.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Analyze and verify software properties using program analysis and hyper-property testing.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Explore state-of-the-art tools and frameworks to enhance software reliability and security.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2&gt;Syllabus&lt;/h2&gt;
&lt;h3&gt;Week 1-2: Fundamentals of Advanced Software Testing&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Recap of basic software testing concepts&lt;/li&gt;
&lt;li&gt;Challenges in modern software testing&lt;/li&gt;
&lt;li&gt;Introduction to test automation and advanced testing methodologies&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Week 3-4: Automatic Test Data Generation&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Theory and algorithms for test data generation&lt;/li&gt;
&lt;li&gt;Symbolic execution and constraint solving&lt;/li&gt;
&lt;li&gt;Tools for automated test generation&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Week 5-6: Metamorphic Testing&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Addressing the oracle problem in software testing&lt;/li&gt;
&lt;li&gt;Designing and applying metamorphic relations&lt;/li&gt;
&lt;li&gt;Applications of metamorphic testing in various domains&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Week 7-8: Fuzz Testing&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Introduction to fuzzing techniques: black-box, gray-box, and white-box fuzzing&lt;/li&gt;
&lt;li&gt;Coverage-guided fuzzing and mutation-based testing&lt;/li&gt;
&lt;li&gt;Case studies of fuzzing tools (e.g., AFL, libFuzzer)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Week 9-10: Hyper-Property Testing&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Understanding hyper-properties and their significance&lt;/li&gt;
&lt;li&gt;Techniques for verifying and validating hyper-properties&lt;/li&gt;
&lt;li&gt;Applications in security, privacy, and concurrency testing&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Week 11-12: Program Analysis and Abstract Interpretation&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Static and dynamic program analysis techniques&lt;/li&gt;
&lt;li&gt;Abstract interpretation and its role in bug detection&lt;/li&gt;
&lt;li&gt;Tools for program analysis (e.g., Clang Static Analyzer, CodeQL)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Week 13: Testing in the Real World&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Integration of advanced testing techniques in agile and DevOps environments&lt;/li&gt;
&lt;li&gt;Testing frameworks and automation pipelines&lt;/li&gt;
&lt;li&gt;Challenges and opportunities in adopting advanced testing practices&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Week 14: Capstone Project and Review&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Designing and implementing a comprehensive testing strategy for a real-world software system&lt;/li&gt;
&lt;li&gt;Final presentations and peer reviews&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2&gt;Course Assessment&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Assignments (25%)&lt;/strong&gt;: Hands-on exercises in test automation, fuzzing, and program analysis.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Paper-based Exam (40%)&lt;/strong&gt;: Theoretical evaluation of advanced testing methodologies.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Capstone Project (25%)&lt;/strong&gt;: Group project involving the application of advanced testing techniques.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Participation (10%)&lt;/strong&gt;: Contributions to discussions, code reviews, and peer learning.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2&gt;Resources&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Textbooks&lt;/strong&gt;:&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Fuzzing: Brute Force Vulnerability Discovery&lt;/em&gt; by Michael Sutton, Adam Greene, and Pedram Amini&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Introduction to Software Testing&lt;/em&gt; by Paul Ammann and Jeff Offutt&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Online Platforms&lt;/strong&gt;:&lt;/li&gt;
&lt;li&gt;Tools and frameworks such as AFL, libFuzzer, Z3 (solver), and Clang Static Analyzer&lt;/li&gt;
&lt;li&gt;Open-source repositories for testing datasets&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Research Papers&lt;/strong&gt;:&lt;/li&gt;
&lt;li&gt;Recent studies on advanced testing techniques from top-tier conferences (ICSE, FSE, ASE, ICPC, and ISSTA)&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2&gt;Prerequisites&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Familiarity with basic software testing principles and techniques.&lt;/li&gt;
&lt;li&gt;Knowledge of programming languages (e.g., Java, Python, C++) and data structures.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2&gt;Contact Information&lt;/h2&gt;
&lt;p&gt;For inquiries, feel free to reach out via my webpage: &lt;a href="http://www.m-zakeri.github.io" target="_blank"&gt;www.m-zakeri.github.io&lt;/a&gt;.&lt;/p&gt;</content><category term="courses"></category><category term="courses"></category><category term="teaching"></category></entry><entry><title>Software Architectures</title><link href="https://m-zakeri.github.io/software-architectures.html" rel="alternate"></link><published>2025-03-07T21:00:00+03:30</published><updated>2025-03-07T21:00:00+03:30</updated><author><name>Morteza</name></author><id>tag:m-zakeri.github.io,2025-03-07:/software-architectures.html</id><summary type="html">&lt;p&gt;Software Architectures, Graduate course.&lt;/p&gt;</summary><content type="html">&lt;h2&gt;Course Description&lt;/h2&gt;
&lt;p&gt;This course offers an in-depth study of software architectures, emphasizing their role in creating scalable, maintainable, and high-performing systems. Students will explore various architectural styles, principles of clean architecture, and cutting-edge AI-driven architectural frameworks. By combining theoretical concepts with practical case studies, the course equips students with the skills to design robust architectures tailored to diverse application domains.&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Course Objectives&lt;/h2&gt;
&lt;p&gt;By the end of this course, students will:
1. Understand the principles and best practices of modern software architecture.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Explore various architectural patterns, including monolithic, layered, microservices, and event-driven architectures.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Learn and apply clean architecture principles for maintainable and testable systems.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Design AI-driven architectures tailored to intelligent systems and applications.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Evaluate and adapt architectural decisions to meet real-world challenges in scalability, security, and performance.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2&gt;Syllabus&lt;/h2&gt;
&lt;h3&gt;Week 1-2: Introduction to Software Architecture&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;The role of architecture in software development&lt;/li&gt;
&lt;li&gt;Core concepts and trade-offs in architectural decisions&lt;/li&gt;
&lt;li&gt;Overview of architecture evaluation frameworks&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Week 3-4: Classical Architectural Styles&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Monolithic architecture: Advantages and limitations&lt;/li&gt;
&lt;li&gt;Layered architecture: Principles and practical applications&lt;/li&gt;
&lt;li&gt;Event-driven architecture: Asynchronous communication and scalability&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Week 5-6: Component-Based and Service-Oriented Architectures&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Component-based design principles&lt;/li&gt;
&lt;li&gt;Introduction to microservices architecture&lt;/li&gt;
&lt;li&gt;Best practices for service-oriented systems and RESTful APIs&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Week 7-8: Principles of Clean Architecture&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Introduction to clean architecture principles&lt;/li&gt;
&lt;li&gt;Designing for testability and maintainability&lt;/li&gt;
&lt;li&gt;Practical applications and refactoring for clean architecture&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Week 9-10: AI-Driven Architectures&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Architectural patterns for machine learning and AI systems&lt;/li&gt;
&lt;li&gt;Designing scalable AI pipelines and inference systems&lt;/li&gt;
&lt;li&gt;Challenges and solutions for deploying AI in production&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Week 11-12: Advanced Topics in Software Architecture&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Architecture for distributed systems and cloud-native applications&lt;/li&gt;
&lt;li&gt;Security considerations in architectural design&lt;/li&gt;
&lt;li&gt;Case studies: E-commerce, IoT, and healthcare systems&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Week 13: Emerging Trends in Architecture&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Exploring serverless architectures and function-as-a-service (FaaS)&lt;/li&gt;
&lt;li&gt;Domain-driven design (DDD) and its applications&lt;/li&gt;
&lt;li&gt;Future directions in architectural practices&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Week 14: Capstone Project and Review&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Designing a software architecture for a real-world problem&lt;/li&gt;
&lt;li&gt;Final presentations and feedback from peers and instructors&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2&gt;Course Assessment&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Assignments (25%)&lt;/strong&gt;: Hands-on tasks to design and evaluate architectural styles.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Paper-based Exam (40%)&lt;/strong&gt;: Theoretical evaluation of architectural principles and practices.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Capstone Project (25%)&lt;/strong&gt;: Collaborative design and implementation of a software architecture.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Participation (10%)&lt;/strong&gt;: Engagement in discussions, case studies, and peer reviews.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2&gt;Resources&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Textbooks&lt;/strong&gt;:&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Software Architecture in Practice&lt;/em&gt; by Len Bass, Paul Clements, and Rick Kazman&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Clean Architecture: A Craftsman's Guide to Software Structure and Design&lt;/em&gt; by Robert C. Martin&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Online Platforms&lt;/strong&gt;:&lt;/li&gt;
&lt;li&gt;Tools for architectural design and modeling, such as ArchiMate and UML tools&lt;/li&gt;
&lt;li&gt;Cloud platforms (AWS, Azure, GCP) for hands-on exercises&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Research Papers&lt;/strong&gt;:&lt;/li&gt;
&lt;li&gt;Recent studies on software architectures from conferences such as WICSA and ECSA&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2&gt;Prerequisites&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Basic understanding of software engineering and system design principles.&lt;/li&gt;
&lt;li&gt;Familiarity with programming and fundamental development methodologies.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2&gt;Contact Information&lt;/h2&gt;
&lt;p&gt;For inquiries, feel free to reach out via my webpage: &lt;a href="http://www.m-zakeri.github.io" target="_blank"&gt;www.m-zakeri.github.io&lt;/a&gt;.&lt;/p&gt;</content><category term="courses"></category><category term="courses"></category><category term="teaching"></category></entry><entry><title>A gentle introduction to search-based software refactoring</title><link href="https://m-zakeri.github.io/a-gentle-introduction-to-search-based-software-refactoring.html" rel="alternate"></link><published>2022-05-05T00:45:00+04:30</published><updated>2022-05-05T00:45:00+04:30</updated><author><name>Morteza</name></author><id>tag:m-zakeri.github.io,2022-05-05:/a-gentle-introduction-to-search-based-software-refactoring.html</id><summary type="html">&lt;p&gt;Finding the best sequence of the refactoring operation to ab applied to a software system is an optimization problem. It can be solved by search techniques in the field known as search-based software engineering (SBSE). In this approach, refactorings are applied stochastically to the original software solution, and then the software is measured using a fitness function consisting of one or more software quality measures. Unfortunately, there is no technical document describing an implementation of decent search-based refactoring. In this tutorial, I am going to explain the implementation of search-based refactoring at the source code level from scratch.&lt;/p&gt;</summary><content type="html">&lt;h2&gt;An Introduction to Search-Based Refactoring&lt;/h2&gt;
&lt;p&gt;Identifying the optimal sequence of refactoring operations to apply to a software system is a challenging optimization problem. This problem falls within the domain of &lt;em&gt;Search-Based Software Engineering (SBSE)&lt;/em&gt;, which leverages search techniques to address software engineering challenges. In the context of search-based refactoring, refactorings are applied stochastically to an initial software solution, which is then evaluated using a fitness function comprising one or more software quality metrics.&lt;/p&gt;
&lt;p&gt;Despite the growing interest in SBSE, there is a notable lack of comprehensive technical documentation that details the implementation of robust search-based refactoring methodologies. This article aims to bridge this gap by discussing the principles of search-based refactoring and outlining its practical implementation at the source code level.&lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;Search-Based Refactoring: A Comprehensive Guide&lt;/h3&gt;
&lt;h3&gt;What is Search-Based Refactoring?&lt;/h3&gt;
&lt;p&gt;Refactoring is the process of improving the internal structure of software without altering its external behavior. This process ensures that the code becomes more maintainable, scalable, and efficient. However, finding the most effective sequence of refactoring steps is inherently complex due to the vast search space of possible transformations.&lt;/p&gt;
&lt;p&gt;Search-based refactoring approaches this complexity as an optimization problem. The core idea is to model the software system, apply refactoring operations iteratively or stochastically, and evaluate the result using a fitness function. This function serves as the guiding metric, assessing various qualities of the software, such as modularity, code readability, or coupling and cohesion.&lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;Why Search-Based Refactoring?&lt;/h3&gt;
&lt;p&gt;Search-based methods hold several advantages over manual or rule-based refactoring:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Automation&lt;/strong&gt;: It reduces the effort and time required to identify and apply effective refactorings.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Scalability&lt;/strong&gt;: Search-based techniques can handle large codebases where manual refactoring is impractical.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Optimization&lt;/strong&gt;: By leveraging heuristic or metaheuristic search techniques (e.g., genetic algorithms, simulated annealing), it often identifies refactoring sequences that outperform human-crafted approaches in improving software quality.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3&gt;Core Components of Search-Based Refactoring&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Refactoring Operations&lt;/strong&gt;: These are the transformations applied to the code, such as renaming a class, extracting a method, or replacing magic numbers with constants. Each operation must preserve the software's external behavior.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Fitness Function&lt;/strong&gt;: The fitness function evaluates the quality of the refactored code. Common software quality metrics include cyclomatic complexity, code duplication, maintainability index, and coupling/cohesion ratios.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Search Algorithm&lt;/strong&gt;: Metaheuristic algorithms such as genetic algorithms (GAs), particle swarm optimization (PSO), or hill-climbing methods are commonly used. These techniques explore the search space of possible refactoring sequences to maximize the fitness function.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Stopping Criteria&lt;/strong&gt;: A predefined stopping condition, such as the number of iterations or a target fitness value, determines when the search process concludes.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3&gt;My Refactoring Services for Large and Legacy Codebases&lt;/h3&gt;
&lt;p&gt;I specialize in providing professional refactoring services for companies dealing with large and legacy codebases. Such systems often present unique challenges, including outdated architecture, high coupling, and lack of documentation. Leveraging search-based refactoring and my expertise in software engineering, I offer the following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Code Analysis and Assessment&lt;/strong&gt;: Conducting an in-depth evaluation of the codebase to identify critical areas for improvement.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Custom Refactoring Solutions&lt;/strong&gt;: Applying search-based refactoring techniques tailored to the specific needs and objectives of the client.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Software Quality Enhancement&lt;/strong&gt;: Improving maintainability, scalability, and performance while preserving the functional integrity of the software.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Consulting and Training&lt;/strong&gt;: Providing guidance and training to internal teams on adopting modern refactoring practices and integrating computational thinking into their workflows.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;By addressing the challenges inherent in large and legacy systems, I empower organizations to modernize their software infrastructure and enhance its long-term value.&lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;Future Work in Search-Based Refactoring&lt;/h3&gt;
&lt;p&gt;Search-based refactoring is a dynamic and evolving field, with several opportunities for future research and development:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Enhanced Fitness Functions&lt;/strong&gt;: Developing multi-objective fitness functions that account for emerging software quality attributes such as energy efficiency and resilience.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Scalability Improvements&lt;/strong&gt;: Designing algorithms that can efficiently handle ever-growing codebases in modern software systems.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Integration with CI/CD Pipelines&lt;/strong&gt;: Automating search-based refactoring within continuous integration and deployment workflows to enable seamless updates.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;AI-Driven Refactoring&lt;/strong&gt;: Leveraging advanced AI models to predict optimal refactoring paths and adaptively learn from previous iterations.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Domain-Specific Refactoring&lt;/strong&gt;: Exploring how search-based refactoring can be customized for specialized domains, such as embedded systems or high-performance computing.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;Search-based refactoring represents a powerful methodology for addressing the complexity of modern software systems. By framing refactoring as an optimization problem and leveraging advanced search techniques, this approach can significantly enhance software quality and maintainability. &lt;/p&gt;
&lt;p&gt;My professional services aim to bring this transformative technology to companies, particularly those burdened by large and legacy codebases. The future of search-based refactoring lies in its continued evolution to meet the demands of emerging technologies and industries. By fostering innovation and collaboration, we can unlock the full potential of computational thinking in software engineering.&lt;/p&gt;
&lt;hr&gt;</content><category term="blog"></category><category term="blog"></category><category term="ANTLR"></category><category term="compiler"></category><category term="tutorial"></category></entry><entry><title>CodART: Automated Source Code Refactoring Toolkit</title><link href="https://m-zakeri.github.io/codart-automated-source-code-refactoring-toolkit.html" rel="alternate"></link><published>2022-05-02T23:58:00+04:30</published><updated>2022-05-02T23:58:00+04:30</updated><author><name>Morteza</name></author><id>tag:m-zakeri.github.io,2022-05-02:/codart-automated-source-code-refactoring-toolkit.html</id><summary type="html">&lt;p&gt;Refactoring engines are tools that automate the application of refactorings: first, the user chooses a refactoring to apply, then the engine checks if the transformation is safe, and if so, transforms the program.&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;strong&gt;Abstract—&lt;/strong&gt; Software refactoring is performed by changing the software structure without modifying its external behavior. Many software quality attributes can be enhanced through the source code refactoring, such as reusability, flexibility, understandability, and testability. Refactoring engines are tools that automate the application of refactorings: first, the user chooses a refactoring to apply, then the engine checks if the transformation is safe, and if so, transforms the program. Refactoring engines are a key component of modern Integrated Development Environments (IDEs), and programmers rely on them to perform refactorings. In this project, an open-source software toolkit for refactoring Java source codes, namely CodART, will be developed. ANTLR parser generator is used to create and modify the program syntax-tree and produce the refactored version of the program. To the best of our knowledge, CodART is the first open-source refactoring toolkit based on ANTLR.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Index Terms:&lt;/strong&gt; Software refactoring, refactoring engine, search-based refactoring, ANTLR, Java.&lt;/p&gt;
&lt;h2&gt;1 Introduction&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;R&lt;/strong&gt;efactoring is a behavior-preserving program transformation that improves the design of a program. Refactoring engines are tools that automate the application of refactorings. The programmer need only select which refactoring to apply, and the engine will automatically check the &lt;em&gt;preconditions&lt;/em&gt; and apply the transformations across the entire program if the preconditions are satisfied. Refactoring is gaining popularity, as evidenced by the inclusion of refactoring engines in modern IDEs such as &lt;a href="https://www.jetbrains.com/idea/"&gt;IntelliJ IDEA&lt;/a&gt;, &lt;a href="http://www.eclipse.org"&gt;Eclipse&lt;/a&gt;, or &lt;a href="http://www.netbeans.org"&gt;NetBeans&lt;/a&gt; for Java.&lt;/p&gt;
&lt;p&gt;Considering the &lt;em&gt;EncapsulateField&lt;/em&gt; refactoring as an illustrative example. This refactoring replaces all references to a field with accesses through setter and getter methods. The &lt;em&gt;EncapsulateField&lt;/em&gt; refactoring takes as input the name of the field to encapsulate and the names of the new getter and setter methods. It performs the following transformations:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Creates a public getter method that returns the field's value, &lt;/li&gt;
&lt;li&gt;Creates a public setter method that updates the field's value,
to a given parameter's value,&lt;/li&gt;
&lt;li&gt;Replaces all field reads with calls to the getter method,&lt;/li&gt;
&lt;li&gt;Replaces all field writes with calls to the setter method,&lt;/li&gt;
&lt;li&gt;Changes the field's access modifier to private.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The &lt;em&gt;EncapsulateField&lt;/em&gt; refactoring checks several preconditions, including that the code does not already contain accessor methods and that these methods are applicable to the expressions in which the field appears. Figure 1 shows a sample program before and after encapsulating the field &lt;code&gt;f&lt;/code&gt; into the &lt;code&gt;getF&lt;/code&gt; and &lt;code&gt;setF&lt;/code&gt; methods.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Figure 1. Example EncapsulateField refactoring" src="../static/img/codart_example.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Figure 1. Example EncapsulateField refactoring&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Refactoring engines must be reliable. A fault in a refactoring engine can silently introduce bugs in the refactored program and lead to challenging debugging sessions. If the original program compiles, but the refactored program does not, the refactoring is obviously incorrect and can be easily undone. However, if the refactoring engine erroneously produces a refactored program that compiles but does not preserve the semantics of the original program, this can have severe consequences. &lt;/p&gt;
&lt;p&gt;To perform refactoring correctly, the tool has to operate on the syntax tree of the code, not on the text. Manipulating the syntax tree is much more reliable to preserve what the code is doing. Refactoring is not just understanding and updating the syntax tree. The tool also needs to figure out how to rerender the code into text back in the editor view, called code transformation. All in all, implementing decent refactoring is a challenging programming exercise, required compiler knowledge. &lt;/p&gt;
&lt;p&gt;In this project, we develop CodART, a toolkit for applying a given refactoring on the source code and obtain the refactored code. To this aim, we will use ANTLR [1] to generate and modify the program syntax tree. CodART development consists of two phases: In the first phase, &lt;strong&gt;47 common refactoring operations&lt;/strong&gt; will be automated, and in the second phase, an algorithm to find the best sequence of refactorings to apply on a given software will be developed using many-objective search-based approaches.&lt;/p&gt;
&lt;p&gt;The rest of this &lt;em&gt;white-paper&lt;/em&gt; is organized as follows. Section 2 describes the refactoring operations in detail. Section 3 explains code smells in detail. Section 4 briefly discusses the search-based refactoring techniques and many-objective evolutionary algorithms. Section 5 explains the implementation details of the current version of CodART. Section 6 lists the Java project used to evaluate CodART. Section 7 articulates the proposals that existed behind the CodART projects. Finally, the conclusion and future works are discussed in Section 8.&lt;/p&gt;
&lt;h2&gt;2 Refactoring operations&lt;/h2&gt;
&lt;p&gt;This section explains the refactoring operations used in the project. A catalog of 72 refactoring operations has been proposed by Fowler [2]. We called this refactorings atomic refactoring operations. &lt;/p&gt;
&lt;p&gt;Each refactoring operation has a definition and is clearly specified by the entities in which it is involved and the role of each. Table 1 describes the desirable refactorings, which we aim to automate them. It worth noting that not all of these refactoring operations are introduced by Fowler [2]. A concrete example for most of the refactoring operations in the table is available at &lt;a href="https://refactoring.com/catalog/"&gt;https://refactoring.com/catalog/&lt;/a&gt;. Examples of other refactorings can be found at &lt;a href="https://refactoring.guru/refactoring/techniques"&gt;https://refactoring.guru/refactoring/techniques&lt;/a&gt; and &lt;a href="ttps://sourcemaking.com/refactoring/refactorings"&gt;https://sourcemaking.com/refactoring/refactorings&lt;/a&gt;. &lt;/p&gt;
&lt;p&gt;&lt;em&gt;Table 1. Refactoring operations&lt;/em&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Refactoring&lt;/th&gt;
&lt;th&gt;Definition&lt;/th&gt;
&lt;th&gt;Entities&lt;/th&gt;
&lt;th&gt;Roles&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Move   class&lt;/td&gt;
&lt;td&gt;Move   a class from a package to another&lt;/td&gt;
&lt;td&gt;package     class&lt;/td&gt;
&lt;td&gt;source   package, target package     moved   class&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Move   method&lt;/td&gt;
&lt;td&gt;Move   a method from a class to another.&lt;/td&gt;
&lt;td&gt;class     method&lt;/td&gt;
&lt;td&gt;source   class, target class     moved   method&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Merge   packages&lt;/td&gt;
&lt;td&gt;Merge   the elements of a set of packages in one of them&lt;/td&gt;
&lt;td&gt;package&lt;/td&gt;
&lt;td&gt;source   package, target package&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Extract/Split   package&lt;/td&gt;
&lt;td&gt;Add   a package to compose the elements of another package&lt;/td&gt;
&lt;td&gt;package&lt;/td&gt;
&lt;td&gt;source   package, target package&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Extract   class&lt;/td&gt;
&lt;td&gt;Create   a new class and move fields and methods from the old class to the new one&lt;/td&gt;
&lt;td&gt;class     method&lt;/td&gt;
&lt;td&gt;source   class, new class     moved   methods&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Extract   method&lt;/td&gt;
&lt;td&gt;Extract   a code fragment into a method&lt;/td&gt;
&lt;td&gt;method     statement&lt;/td&gt;
&lt;td&gt;source   method, new method     moved   statements&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Inline   class&lt;/td&gt;
&lt;td&gt;Move   all features of a class in another one and remove it&lt;/td&gt;
&lt;td&gt;class&lt;/td&gt;
&lt;td&gt;source   class, target class&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Move   field&lt;/td&gt;
&lt;td&gt;Move   a field from a class to another&lt;/td&gt;
&lt;td&gt;class     field&lt;/td&gt;
&lt;td&gt;source   class, target class     field&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href="refactorings/push_down_field.md"&gt;Push down field&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Move   a field of a superclass to a subclass&lt;/td&gt;
&lt;td&gt;class     field&lt;/td&gt;
&lt;td&gt;super   class, sub classes     move   field&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Push   down method&lt;/td&gt;
&lt;td&gt;Move   a method of a superclass to a subclass&lt;/td&gt;
&lt;td&gt;class     method&lt;/td&gt;
&lt;td&gt;super   class, sub classes     moved   method&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href="refactorings/pull_up_field.md"&gt;Pull up field&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Move   a field from subclasses to the superclass&lt;/td&gt;
&lt;td&gt;class     field&lt;/td&gt;
&lt;td&gt;sub   classes, super class     moved   field&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href="refactorings/pull_up_method.md"&gt;Pull up method&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Move   a method from subclasses to the superclass&lt;/td&gt;
&lt;td&gt;class     method&lt;/td&gt;
&lt;td&gt;sub   classes, super class     moved   method&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href="refactorings/increase_field_visibility.md"&gt;Increase field visibility&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Increase   the visibility of a field from public to protected, protected to package or   package to private&lt;/td&gt;
&lt;td&gt;class     field&lt;/td&gt;
&lt;td&gt;source   class     source   filed&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href="refactorings/decrease_field_visibility.md"&gt;Decrease field visibility&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Decrease   the visibility of a field from private to package, package to protected or   protected to public&lt;/td&gt;
&lt;td&gt;class     field&lt;/td&gt;
&lt;td&gt;source   class     source   filed&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href="refactorings/make_field_final.md"&gt;Make field final&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Make   a non-final field final&lt;/td&gt;
&lt;td&gt;class     field&lt;/td&gt;
&lt;td&gt;source   class     source   filed&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href="refactorings/make_field_non_final.md"&gt;Make field non-final&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Make   a final field non-final&lt;/td&gt;
&lt;td&gt;class     field&lt;/td&gt;
&lt;td&gt;source   class     source   filed&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Make   field static&lt;/td&gt;
&lt;td&gt;Make   a non-static field static&lt;/td&gt;
&lt;td&gt;class     field&lt;/td&gt;
&lt;td&gt;source   class     source   filed&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Make   field non-static&lt;/td&gt;
&lt;td&gt;Make   a static field non-static&lt;/td&gt;
&lt;td&gt;class     field&lt;/td&gt;
&lt;td&gt;source   class     source   filed&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Remove   field&lt;/td&gt;
&lt;td&gt;Remove   a field from a class&lt;/td&gt;
&lt;td&gt;class     field&lt;/td&gt;
&lt;td&gt;source   class     source   filed&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Increase   method visibility&lt;/td&gt;
&lt;td&gt;Increase   the visibility of a method from public to protected, protected to package or   package to private&lt;/td&gt;
&lt;td&gt;class     method&lt;/td&gt;
&lt;td&gt;source   class     source   method&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Decrease   method visibility&lt;/td&gt;
&lt;td&gt;Decrease   the visibility of a method from private to package, package to protected or   protected to public&lt;/td&gt;
&lt;td&gt;class     method&lt;/td&gt;
&lt;td&gt;source   class     source   method&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Make   method final&lt;/td&gt;
&lt;td&gt;Make   a non-final method final&lt;/td&gt;
&lt;td&gt;class     method&lt;/td&gt;
&lt;td&gt;source   class     source   method&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Make   method non-final&lt;/td&gt;
&lt;td&gt;Make   a final method non-final&lt;/td&gt;
&lt;td&gt;class     method&lt;/td&gt;
&lt;td&gt;source   class     source   method&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Make   method static&lt;/td&gt;
&lt;td&gt;Make   a non-static method static&lt;/td&gt;
&lt;td&gt;class     method&lt;/td&gt;
&lt;td&gt;source   class     source   method&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Make   method non-static&lt;/td&gt;
&lt;td&gt;Make   a static method non-static&lt;/td&gt;
&lt;td&gt;class     method&lt;/td&gt;
&lt;td&gt;source   class     source   method&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Remove   method&lt;/td&gt;
&lt;td&gt;Remove   a method from a class&lt;/td&gt;
&lt;td&gt;class     method&lt;/td&gt;
&lt;td&gt;source   class     source   method&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Make   class-final&lt;/td&gt;
&lt;td&gt;Make   a non-final class final&lt;/td&gt;
&lt;td&gt;class&lt;/td&gt;
&lt;td&gt;source   class&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Make   class non-final&lt;/td&gt;
&lt;td&gt;Make   a final class non-final&lt;/td&gt;
&lt;td&gt;class&lt;/td&gt;
&lt;td&gt;source   class&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Make   class abstract&lt;/td&gt;
&lt;td&gt;Change   a concrete class to abstract&lt;/td&gt;
&lt;td&gt;class&lt;/td&gt;
&lt;td&gt;source   class&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Make   class concrete&lt;/td&gt;
&lt;td&gt;Change   an abstract class to concrete&lt;/td&gt;
&lt;td&gt;class&lt;/td&gt;
&lt;td&gt;source   class&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Extract   subclass&lt;/td&gt;
&lt;td&gt;Create   a subclass for a set of features&lt;/td&gt;
&lt;td&gt;class     method&lt;/td&gt;
&lt;td&gt;source   class, new subclass     moved   methods&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href="refactorings/extract_interface.md"&gt;Extract interface&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Extract   methods of a class into an interface&lt;/td&gt;
&lt;td&gt;class     method&lt;/td&gt;
&lt;td&gt;source   class, new interface     interface   methods&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Inline   method&lt;/td&gt;
&lt;td&gt;Move   the body of a method into its callers and remove the method&lt;/td&gt;
&lt;td&gt;method&lt;/td&gt;
&lt;td&gt;source   method, callers method&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Collapse   hierarchy&lt;/td&gt;
&lt;td&gt;Merge   a superclass and a subclass&lt;/td&gt;
&lt;td&gt;class&lt;/td&gt;
&lt;td&gt;superclass,   subclass&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Remove   control flag&lt;/td&gt;
&lt;td&gt;Replace   control flag with a break&lt;/td&gt;
&lt;td&gt;class     method&lt;/td&gt;
&lt;td&gt;source   class     source   method&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Replace   nested conditional with guard clauses&lt;/td&gt;
&lt;td&gt;Replace   nested conditional with guard clauses&lt;/td&gt;
&lt;td&gt;class     method&lt;/td&gt;
&lt;td&gt;source   class     source   method&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Replace   constructor with a factory function&lt;/td&gt;
&lt;td&gt;Replace   constructor with a factory function&lt;/td&gt;
&lt;td&gt;class&lt;/td&gt;
&lt;td&gt;source   class&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Replace   exception with test&lt;/td&gt;
&lt;td&gt;Replace   exception with precheck&lt;/td&gt;
&lt;td&gt;class     method&lt;/td&gt;
&lt;td&gt;source   class     source   method&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Rename   field&lt;/td&gt;
&lt;td&gt;Rename   a field&lt;/td&gt;
&lt;td&gt;class     field&lt;/td&gt;
&lt;td&gt;source   class     source   filed&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href="refactorings/rename_method.md"&gt;Rename method&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Rename   a method&lt;/td&gt;
&lt;td&gt;class     method&lt;/td&gt;
&lt;td&gt;source   class     source   method&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Rename   class&lt;/td&gt;
&lt;td&gt;Rename   a class&lt;/td&gt;
&lt;td&gt;class&lt;/td&gt;
&lt;td&gt;source   class&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Rename   package&lt;/td&gt;
&lt;td&gt;Rename   a package&lt;/td&gt;
&lt;td&gt;package&lt;/td&gt;
&lt;td&gt;source   package&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Encapsulate   field&lt;/td&gt;
&lt;td&gt;Create   setter/mutator and getter/accessor methods for a private field&lt;/td&gt;
&lt;td&gt;class     field&lt;/td&gt;
&lt;td&gt;source   class     source   filed&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Replace   parameter with query&lt;/td&gt;
&lt;td&gt;Replace   parameter with query&lt;/td&gt;
&lt;td&gt;class     method&lt;/td&gt;
&lt;td&gt;source   class     source   method&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Pull   up constructor body&lt;/td&gt;
&lt;td&gt;Move   the constructor&lt;/td&gt;
&lt;td&gt;class     method&lt;/td&gt;
&lt;td&gt;subclass   class, superclass     constructor&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Replace   control flag with break&lt;/td&gt;
&lt;td&gt;Replace   control flag with break&lt;/td&gt;
&lt;td&gt;class     method&lt;/td&gt;
&lt;td&gt;source   class     source   method&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Remove   flag argument&lt;/td&gt;
&lt;td&gt;Remove   flag argument&lt;/td&gt;
&lt;td&gt;class     method&lt;/td&gt;
&lt;td&gt;source   class     source   method&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Total&lt;/td&gt;
&lt;td&gt;47&lt;/td&gt;
&lt;td&gt;—&lt;/td&gt;
&lt;td&gt;—&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;3 Code smells&lt;/h2&gt;
&lt;p&gt;Deciding when and where to start refactoring—and when and where to stop—is just as important to refactoring as knowing how to operate its mechanics [2]. To answer this important question, we should know the refactoring activities. The refactoring process consists of six distinct activities [9]:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Identify where the software should be refactored.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Determine which refactoring(s) should be applied to the identified places.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Guarantee that the applied refactoring preserves behavior.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Apply the refactoring.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Assess the effect of the refactoring on quality characteristics of the software (e.g., complexity, understandability, maintainability) or the process (e.g., productivity, cost, effort).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Maintain the consistency between the refactored program code and other software artifacts (such as documentation, design documents, requirements specifications, tests, etc.).&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;Table 2. Code smells&lt;/em&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Code smell&lt;/th&gt;
&lt;th&gt;Descriptions and other names&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;God class&lt;/td&gt;
&lt;td&gt;The class defines many data members (fields) and methods   and exhibits low cohesion. The god class smell occurs when a huge class surrounded   by many data classes acts as a controller (i.e., takes most of the decisions   and monopolizes the software's functionality).       Other names: Blob, large   class, brain class.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Long method&lt;/td&gt;
&lt;td&gt;This smell occurs when a method is too long to understand   and most presumably perform more than one responsibility.       Other names: God   method, brain method, large method.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Feature envy&lt;/td&gt;
&lt;td&gt;This smell occurs when a method seems more interested in a   class other than the one it actually is in.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Data class&lt;/td&gt;
&lt;td&gt;This smell occurs when a class contains only fields and   possibly getters/setters without any behavior (methods).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Shotgun surgery&lt;/td&gt;
&lt;td&gt;This smell characterizes the situation when one kind of   change leads to many changes to multiple different classes. When the changes   are all over the place, they are hard to find, and it is easy to miss a   necessary change.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Refused bequest&lt;/td&gt;
&lt;td&gt;This smell occurs when a subclass rejects some of the   methods or properties offered by its superclass.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Functional decomposition&lt;/td&gt;
&lt;td&gt;This smell occurs when the experienced developers coming   from procedural languages background write highly procedural and   non-object-oriented code in an object-oriented language.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Long parameter list&lt;/td&gt;
&lt;td&gt;This smell occurs when a method accepts a long list of   parameters. Such lists are hard to understand and difficult to use.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Promiscuous package&lt;/td&gt;
&lt;td&gt;A package can be considered promiscuous if it contains   classes implementing too many features, making it too hard to understand and   maintain. As for god class and long method, this smell arises when the   package has low cohesion since it manages different responsibilities.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Misplaced class&lt;/td&gt;
&lt;td&gt;A Misplaced Class smell suggests a class that is in a   package that contains other classes not related to it.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Switch statement&lt;/td&gt;
&lt;td&gt;This smell occurs when switch statements that switch on   type codes are spread across the software system instead of exploiting polymorphism.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Spaghetti code&lt;/td&gt;
&lt;td&gt;This smell refers to an unmaintainable, incomprehensible   code without any structure. The smell does not exploit and prevents the use   of object-orientation mechanisms and concepts.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Divergent change&lt;/td&gt;
&lt;td&gt;Divergent change occurs when one class is commonly changed   in different ways for different reasons.     Other names: Multifaceted abstraction&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Deficient encapsulation&lt;/td&gt;
&lt;td&gt;This smell occurs when the declared accessibility of one   or more members of abstraction is more permissive than actually required.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Swiss army knife&lt;/td&gt;
&lt;td&gt;This smell arises when the designer attempts to provide   all possible uses of the class and ends up in an excessively complex class   interface.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Lazy class&lt;/td&gt;
&lt;td&gt;Unnecessary abstraction&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Cyclically-dependent modularization&lt;/td&gt;
&lt;td&gt;This smell arises when two or more abstractions depend on   each other directly or indirectly.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Primitive obsession&lt;/td&gt;
&lt;td&gt;This smell occurs when primitive data types are used where   an abstraction encapsulating the primitives could serve better.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Speculative generality&lt;/td&gt;
&lt;td&gt;This smell occurs where abstraction is created based on   speculated requirements. It is often unnecessary that makes things difficult   to understand and maintain.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Message chains&lt;/td&gt;
&lt;td&gt;A message chain occurs when a client requests another   object, that object requests yet another one, and so on. These chains mean   that the client is dependent on navigation along with the class structure.   Any changes in these relationships require modifying the client.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Total&lt;/td&gt;
&lt;td&gt;20&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;4 Search-based refactoring&lt;/h2&gt;
&lt;p&gt;After refactoring operations were automated, we must decide which refactorings souled be performed in order to elevate software quality. The concern about using refactoring operations in Table 1 is whether each one of them has a positive impact on the refactored code quality or not. Finding the right sequence of refactorings to be applied in a software artifact is considered a challenging task since there is a wide range of refactorings. The ideal sequence is, therefore, must correlate to different quality attributes to be improved as a result of applying refactorings. &lt;/p&gt;
&lt;p&gt;Finding the best refactoring sequence is an optimization problem that can be solved by search techniques in the field known as Search-Based Software Engineering (SBSE) [3]. In this approach, refactorings are applied stochastically to the original software solution, and then the software is measured using a fitness function consisting of one or more software metrics. There are various metric suites available to measure characteristics like cohesion and coupling, but different metrics measure the software in different ways, and thus how they are applied will have a different effect on the outcome. &lt;/p&gt;
&lt;p&gt;The second phase of this project is to use a many-objective search algorithm to find the best sequence of refactoring on a given project. Recently, many-objective SBSE approach for refactoring [3]–[5] and remodularization, regrouping a set of classes C in terms of packages P, [6] has gained more attention due to its ability to find the best sequence of refactoring operations which is led to the improvement in software quality. Therefore, we first focus on implementing the proposed approach approaches in [3], [5], [6] as fundamental works in this area. Then, we will improve their approach. As a new contribution, we add new refactoring operations and new objective functions to improve the quality attribute of the software. We also evaluate our method on the new software projects which are not used in previous works.&lt;/p&gt;
&lt;h2&gt;5 Implementation&lt;/h2&gt;
&lt;p&gt;This section describes implementation details of the CodART. It includes CodART architecture, high-level repository directories structure, refactoring automation with ANTLR parser generator, and refactoring recommendation through many-objective search-based software engineering techniques. &lt;/p&gt;
&lt;h3&gt;5.1 CodART architecture&lt;/h3&gt;
&lt;p&gt;The high-level architecture of CodART is shown in Figure 2. The source code consists of several Python packages and directories. We briefly describe each component in CodART. &lt;/p&gt;
&lt;p&gt;&lt;img alt="CodART_Architecture" src="../static/img/CodART_architecture__v0.1.1.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Figure 2. CodART architecture&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;I. &lt;code&gt;grammars&lt;/code&gt;: This directory contains three ANTLR4 grammars for the Java programming language: &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Java9_v2.g4&lt;/code&gt;: This grammar was used in the initial version of CodART. The main problem of this grammar is that parsing large source code files is performed very slow due to some decisions used in grammar design. We have switched to the fast grammar &lt;code&gt;JavaParserLabled.g4&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;JavaLexer.g4&lt;/code&gt;: The lexer of Java fast grammar. This lexer is used for both fast parsers, i.e., &lt;code&gt;JavaParser.g4&lt;/code&gt; and JavaParserLabeled.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;JavaParser.g4&lt;/code&gt;: The original parser of Java fast grammar. This parser is currently used in some refactoring. In the future release, this grammar will be replaced with &lt;code&gt;JavaPaseredLabled.g4&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;JavaParserLabeled.g4&lt;/code&gt;: This file contains the same &lt;code&gt;JavaParsar.g4&lt;/code&gt; grammar. The only difference is that the rules with more than one extension are labled with a specific name. The ANTLR parser generator thus generates separate visitor and listener methods for each extension. This grammar facilitates the development of some refactoring. It is the preferred parser in CodART project.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;II. &lt;code&gt;gen&lt;/code&gt;: The &lt;code&gt;gen&lt;/code&gt; packages contain all generated source code for the parser, lexer, visitor, and listener for different grammars available in the grammars directory. To develop refactorings and code smells, &lt;code&gt;gen.JavaLabled&lt;/code&gt; package, which contains &lt;code&gt;JavaParserLabled.g4&lt;/code&gt; generated source code, must be used. The content of this package is generated &lt;em&gt;automatically&lt;/em&gt;, and therefore it should &lt;em&gt;not&lt;/em&gt; be modified &lt;em&gt;manually&lt;/em&gt;. Modules within this gen package are just for importing and using in other modules.&lt;/p&gt;
&lt;p&gt;III. &lt;code&gt;speedy&lt;/code&gt;: The python implementation for ANTLR is less efficient than Java or C++ implementation. The &lt;code&gt;speedy&lt;/code&gt; module implements a Java parser with a C++ back-end, improving the efficiency and speed of parsing. It uses speedy-antlr implementation with some minor changes.  The current version of the speedy module use &lt;code&gt;java9_v2.g4&lt;/code&gt; grammar, which inherently slow as described. To switch to C++ back-end, first, the speedy module must be installed on the client system. It requires a C++ compiler. We &lt;em&gt;recommended&lt;/em&gt; to CodART developers using the Python back-end as switching to C++ back-end would be done transparently in the future release. The Python back-end saves debugging and developing time.&lt;/p&gt;
&lt;p&gt;IV. &lt;code&gt;refactorings&lt;/code&gt;: The &lt;code&gt;refactorings&lt;/code&gt; package is the main package in the CodART project and contains numerous Python modules that form the kernel functionalities of CodART. Each module implements the automation of one refactoring operation according to standard practices. The modules may include several classes which &lt;em&gt;inherit&lt;/em&gt; from ANTLR listeners. Sub-packages in this module contain refactorings, which are in an early step of development or deprecated version of an existing refactoring. This package is under active development and testing. The module in the root packages can be used for testing purposes.&lt;/p&gt;
&lt;p&gt;V. &lt;code&gt;refactoring_design_patters&lt;/code&gt;: The refactoring_design_pattern packages contain modules that implement refactoring to a specific design pattern automatically. &lt;/p&gt;
&lt;p&gt;VI. &lt;code&gt;smells&lt;/code&gt;: The smell package implements the automatic detection of software code and design smells relevant to the refactoring operation supported by CodART. Each smell corresponds to one or more refactoring in the refactoring package.&lt;/p&gt;
&lt;p&gt;VII. &lt;code&gt;metrics&lt;/code&gt;: The metrics packages contain several modules that implement the computation of the most well-known source code metrics. These metrics used to detect code smells and measuring the quality of software in terms of quality attributed. &lt;/p&gt;
&lt;p&gt;VIII. &lt;code&gt;tests&lt;/code&gt;: The test directory contains individual test data and test cases that are used for developing specific refactorings. Typically, each test case is a single Java file that contains one or more Java classes.&lt;/p&gt;
&lt;p&gt;IX. &lt;code&gt;benchmark_projects&lt;/code&gt;: This directory contains several open-source Java projects formerly used in automated refactoring researches by many researchers. Once the implementation of refactoring is completed, it will be executed and tested on all projects in this benchmark to ensure the generalization of functionality proposed by the implementation.  &lt;/p&gt;
&lt;p&gt;X. &lt;strong&gt;Other packages&lt;/strong&gt;: The information of other packages will be announced in the future.  &lt;/p&gt;
&lt;h3&gt;5.2 Refactoring automation&lt;/h3&gt;
&lt;p&gt;Each refactoring operation in Table 1 is implemented as an API, with the refactoring name. The API receives the involved entities with their refactoring roles and other required data as inputs, checks the feasibility of the refactoring using refactoring preconditions described in [2], performs the refactoring if it is feasible, and returns the refactored code or return null if the refactoring is not feasible.&lt;/p&gt;
&lt;p&gt;The core of our refactoring engine is a syntax-tree modification algorithm.  Fundamentally, ANTLR is used to generate and modify the syntax-tree of a given program. Each refactoring API is an ANTLR &lt;em&gt;Listener&lt;/em&gt; or &lt;em&gt;visitor&lt;/em&gt; class, which required argument by its constructor and preform refactoring when call by parse-tree walker object. The refactoring target and input parameters must read from a configuration file, which can be expressed in JSON, XML, or YAML formats.&lt;/p&gt;
&lt;p&gt;The key to use ANTLR for refactoring tasks is the &lt;code&gt;TokenStreamRewriter&lt;/code&gt; object that knows how to give altered views of a token stream without actually modifying the stream. It treats all of the manipulation methods as "instructions" and queues them up for lazy execution when traversing the token stream to render it back as text. The rewriter &lt;em&gt;executes&lt;/em&gt; those instructions every time we call &lt;code&gt;getText()&lt;/code&gt;. This strategy is very effective for the general problem of source code instrumentation or refactoring. The &lt;code&gt;TokenStreamRewriter&lt;/code&gt; is a powerful and extremely efficient means of manipulating a token stream.&lt;/p&gt;
&lt;h3&gt;5.3 Refactoring recommendation&lt;/h3&gt;
&lt;p&gt;A solution consists of a sequence of n refactoring operations applied to different code elements in the source code to fix. In order to represent a candidate solution (individual/chromosome), we use a vector-based representation. Each vector’s dimension represents a refactoring operation where the order of applying these refactoring operations corresponds to their positions in the vector. The initial population is generated by randomly assigning a sequence of refactorings to some code fragments. Each generated refactoring solution is executed on the software system &lt;em&gt;S&lt;/em&gt;. Once all required data is computed, the solution is evaluated based on the quality of the resulting design.&lt;/p&gt;
&lt;h2&gt;6 Benchmark projects and testbed&lt;/h2&gt;
&lt;p&gt;To ensure CodART works properly, we are running it on many real-life software projects.
Refactorings are applied to the software systems listed in Table 3. Benchmark projects may update and extend in the future. For the time being, we use a set of well-known open-source Java projects that have been intensely studied in previous works. We have also added two new Java software programs, WEKA and ANTLR, to examine the versatility of CodART performance on real-life software projects. &lt;/p&gt;
&lt;p&gt;&lt;em&gt;Table 3. Software systems refactored in this project&lt;/em&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;System&lt;/th&gt;
&lt;th&gt;Release&lt;/th&gt;
&lt;th&gt;Previous releases&lt;/th&gt;
&lt;th&gt;Domain&lt;/th&gt;
&lt;th&gt;Reference&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href="https://github.com/apache/xerces2-j"&gt;Xerces-J&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;v2.7.0&lt;/td&gt;
&lt;td&gt;--&lt;/td&gt;
&lt;td&gt;software packages for parsing XML&lt;/td&gt;
&lt;td&gt;[3], [6]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href="https://github.com/vuze/vuze-remote-for-android"&gt;Azureus&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;v2.3.0.6&lt;/td&gt;
&lt;td&gt;--&lt;/td&gt;
&lt;td&gt;Java BitTorrent client for handling multiple torrents&lt;/td&gt;
&lt;td&gt;[3]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href="https://github.com/argouml-tigris-org/argouml"&gt;ArgoUML&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;v0.26 and v0.3&lt;/td&gt;
&lt;td&gt;--&lt;/td&gt;
&lt;td&gt;UML tool for object-oriented design&lt;/td&gt;
&lt;td&gt;[3]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href="https://github.com/apache/ant"&gt;Apache Ant&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;v1.5.0 and v1.7.0&lt;/td&gt;
&lt;td&gt;--&lt;/td&gt;
&lt;td&gt;Java build tool and library&lt;/td&gt;
&lt;td&gt;[3]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href="https://github.com/bardsoftware/ganttproject"&gt;GanttProject&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;v1.10.2 and v1.11.1&lt;/td&gt;
&lt;td&gt;--&lt;/td&gt;
&lt;td&gt;project management&lt;/td&gt;
&lt;td&gt;[3], [6], [5]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href="https://github.com/wumpz/jhotdraw"&gt;JHotDraw&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;v6.1 and v6.0b1 and v5.3&lt;/td&gt;
&lt;td&gt;--&lt;/td&gt;
&lt;td&gt;graphics tool&lt;/td&gt;
&lt;td&gt;[6], [5], [4]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href="https://github.com/jfree/jfreechart"&gt;JFreeChart&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;v1.0.9&lt;/td&gt;
&lt;td&gt;--&lt;/td&gt;
&lt;td&gt;chart tool&lt;/td&gt;
&lt;td&gt;[6]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href="https://github.com/svn2github/beaver-parser-generator-v09"&gt;Beaver&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;v0.9.11 and v0.9.8&lt;/td&gt;
&lt;td&gt;--&lt;/td&gt;
&lt;td&gt;parser generator&lt;/td&gt;
&lt;td&gt;[5], [4]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href="https://ws.apache.org/xmlrpc/"&gt;Apache XML-RPC&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;v3.1.1&lt;/td&gt;
&lt;td&gt;--&lt;/td&gt;
&lt;td&gt;B2B communications&lt;/td&gt;
&lt;td&gt;[5], [4]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href="http://jrdf.sourceforge.net/index.html"&gt;JRDF&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;v0.3.4.3&lt;/td&gt;
&lt;td&gt;--&lt;/td&gt;
&lt;td&gt;semantic web (resource management)&lt;/td&gt;
&lt;td&gt;[5]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href="https://github.com/elharo/xom"&gt;XOM&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;v1.2.1&lt;/td&gt;
&lt;td&gt;--&lt;/td&gt;
&lt;td&gt;XML tool&lt;/td&gt;
&lt;td&gt;[5]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href="https://github.com/stleary/JSON-java"&gt;JSON&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;v1.1&lt;/td&gt;
&lt;td&gt;--&lt;/td&gt;
&lt;td&gt;software packages for parsing JSON&lt;/td&gt;
&lt;td&gt;[4]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href="https://github.com/jflex-de/jflex"&gt;JFlex&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;v1.4.1&lt;/td&gt;
&lt;td&gt;--&lt;/td&gt;
&lt;td&gt;lexical analyzer generator&lt;/td&gt;
&lt;td&gt;[4]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href="https://github.com/jfaster/mango"&gt;Mango&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;v2.0.1&lt;/td&gt;
&lt;td&gt;--&lt;/td&gt;
&lt;td&gt;--&lt;/td&gt;
&lt;td&gt;[4]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href="https://github.com/ohmrefresh/Weka-Android-3.9.1-SNAPSHOT"&gt;Weka&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;v3.9&lt;/td&gt;
&lt;td&gt;--&lt;/td&gt;
&lt;td&gt;data mining tool&lt;/td&gt;
&lt;td&gt;New&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href="https://github.com/antlr/antlr4"&gt;ANTLR&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;v4.8.0&lt;/td&gt;
&lt;td&gt;--&lt;/td&gt;
&lt;td&gt;parser generator tool&lt;/td&gt;
&lt;td&gt;New&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;7 CodART in IUST&lt;/h2&gt;
&lt;p&gt;Developing a comprehensive refactoring engine required thousand of hours of programming. Refactoring is not just understanding and updating the syntax tree. The tool also needs to figure out how to rerender the code into text back in the editor view. According to a quote by Fowler [2] in his well-known refactoring book: “implementing decent refactoring is a challenging programming exercise—one that I’m mostly unaware of as I gaily use the tools.”&lt;/p&gt;
&lt;p&gt;We have defined the basic functionalities of the CodART system as several student projects with different proposals. Students who will take our computer science course, including compiler design and construction, advanced compilers, and advanced software engineering, must be worked on these proposals as part of their course fulfillments. These projects try to familiarize students with the practical usage of compilers from the software engineering point of view.
The detailed information of our current proposals are available in the following links:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="./proposals/core_refactorings_development.md"&gt;Core refactoring operations development&lt;/a&gt; (Fall 2020)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="./proposals/core_code_smell_development.md"&gt;Core code smells development&lt;/a&gt; Current semester (Winter and Spring 2021)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="./proposals/core_search_based_development.md"&gt;Core search-based development&lt;/a&gt; (Future semesters)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="./proposals/core_refactoring_to_design_patterns_development.md"&gt;Core refactoring to design patterns development&lt;/a&gt; (Future semesters)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; Students whose final project is confirmed by the reverse engineering laboratory have an opportunity to work on CodART as an independent and advanced research project. The only prerequisite is to pass the compiler graduate course by Dr. Saeed Parsa.&lt;/p&gt;
&lt;h2&gt;8 Conclusion and remarks&lt;/h2&gt;
&lt;p&gt;Software refactoring is used to reduce the costs and risks of software evolution. 
Automated software refactoring tools can reduce risks caused by manual refactoring, improve efficiency, and reduce software refactoring difficulties. Researchers have made great efforts to research how to implement and improve automated software refactoring tools. However, the results of automated refactoring tools often deviate from the intentions of the implementer. The goal of this project is to propose an open-source refactoring engine and toolkit that can automatically find the best refactoring sequence required for a given software and apply this sequence. Since the tool is work based on compiler principles, it is reliable to be used in practice and has many benefits for software developer companies. Students who participate in the project will learn compiler techniques such as lexing, parsing, source code analysis, and source code transformation. They also learn about software refactoring, search-based software engineering, optimization, software quality, and object-orient metrics. &lt;/p&gt;
&lt;h3&gt;Conflict of interest&lt;/h3&gt;
&lt;p&gt;The project is supported by the &lt;a href="http://reverse.iust.ac.ir"&gt;IUST Reverse Engineering Research Laboratory&lt;/a&gt;. 
Interested students may continue working on this project 
to fulfill their final bachelor and master thesis or their internship.&lt;/p&gt;
&lt;h2&gt;References&lt;/h2&gt;
&lt;p&gt;[1] T. Parr and K. Fisher, “LL(*): the foundation of the ANTLR parser generator,” Proc. 32nd ACM SIGPLAN Conf. Program. Lang. Des. Implement., pp. 425–436, 2011.&lt;/p&gt;
&lt;p&gt;[2] M. K. B. Fowler, Refactoring: improving the design of existing code, Second Edi. Addison-Wesley, 2018.&lt;/p&gt;
&lt;p&gt;[3] M. W. Mkaouer, M. Kessentini, S. Bechikh, M. Ó Cinnéide, and K. Deb, “On the use of many quality attributes for software refactoring: a many-objective search-based software engineering approach,” Empir. Softw. Eng., vol. 21, no. 6, pp. 2503–2545, Dec. 2016.&lt;/p&gt;
&lt;p&gt;[4] M. Mohan, D. Greer, and P. McMullan, “Technical debt reduction using search based automated refactoring,” J. Syst. Softw., vol. 120, pp. 183–194, Oct. 2016.&lt;/p&gt;
&lt;p&gt;[5] M. Mohan and D. Greer, “Using a many-objective approach to investigate automated refactoring,” Inf. Softw. Technol., vol. 112, pp. 83–101, Aug. 2019.&lt;/p&gt;
&lt;p&gt;[6] W. Mkaouer et al., “Many-Objective Software Remodularization Using NSGA-III,” ACM Trans. Softw. Eng. Methodol., vol. 24, no. 3, pp. 1–45, May 2015.&lt;/p&gt;
&lt;p&gt;[7] M. Mohan and D. Greer, “MultiRefactor: automated refactoring to improve software quality,” 2017, pp. 556–572.&lt;/p&gt;
&lt;p&gt;[8] N. Tsantalis, T. Chaikalis, and A. Chatzigeorgiou, “Ten years of JDeodorant: lessons learned from the hunt for smells,” in 2018 IEEE 25th International Conference on Software Analysis, Evolution and Reengineering (SANER), 2018, pp. 4–14.&lt;/p&gt;
&lt;p&gt;[9] T. Mens and T. Tourwe, “A survey of software refactoring,” IEEE Trans. Softw. Eng., vol. 30, no. 2, pp. 126–139, Feb. 2004.&lt;/p&gt;
&lt;h4&gt;Related links&lt;/h4&gt;
&lt;p&gt;&lt;a href="http://parsa.iust.ac.ir/courses/compilers/"&gt;IUST compiler course official webpage&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ANTLR slides: PART 1: &lt;a href="http://parsa.iust.ac.ir/download_center/courses_material/compilers/slides/ANTLR_part1_introduction.pdf"&gt;Introduction&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ANTLR slides: PART 2: &lt;a href="http://parsa.iust.ac.ir/download_center/courses_material/compilers/slides/ANTLR_part2_getting_started_in_Java.pdf"&gt;Getting started in Java&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ANTLR slides: PART 3: &lt;a href="http://parsa.iust.ac.ir/download_center/courses_material/compilers/slides/ANTLR_part3_getting_started_in_CSharp.pdf"&gt;Getting started in C#&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;Endnotes&lt;/h4&gt;
&lt;p&gt;[1] &lt;a href="https://www.jetbrains.com/idea/"&gt;https://www.jetbrains.com/idea/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[2] &lt;a href="http://www.eclipse.org"&gt;http://www.eclipse.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[3] &lt;a href="http://www.netbeans.org"&gt;http://www.netbeans.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[4] &lt;a href="https://github.com/mmohan01/MultiRefactor"&gt;https://github.com/mmohan01/MultiRefactor&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;[5] &lt;a href="http://sourceforge.net/projects/recoder"&gt;http://sourceforge.net/projects/recoder&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;[6] &lt;a href="http://reverse.iust.ac.ir"&gt;http://reverse.iust.ac.ir&lt;/a&gt; &lt;/p&gt;</content><category term="blog"></category><category term="blog"></category></entry><entry><title>Automated refactoring of the Java code using ANTLR in Python</title><link href="https://m-zakeri.github.io/automated-refactoring-of-the-java-code-using-antlr-in-python.html" rel="alternate"></link><published>2022-05-02T00:30:00+04:30</published><updated>2022-05-02T00:30:00+04:30</updated><author><name>Morteza</name></author><id>tag:m-zakeri.github.io,2022-05-02:/automated-refactoring-of-the-java-code-using-antlr-in-python.html</id><summary type="html">&lt;p&gt;Refactoring is a type of program transformation that preserves the program’s behavior. The goal of refactoring is to improve the program’s internal structure without changing its external behavior. In this way, the program quality, defined and measured in terms of quality attributes, is improved. The refactoring process could be automated to reduce the required time and cost and increase the reliability of applied transformation. In this tutorial, I give a short description of how we can automate the refactoring process with ANTLR in Python.&lt;/p&gt;</summary><content type="html">&lt;h2&gt;Introduction&lt;/h2&gt;
&lt;p&gt;Refactoring is a type of program transformation that preserves the program’s behavior. The goal of refactoring is to improve the program’s internal structure without changing its external behavior. In this way, the program quality, defined and measured in terms of quality attributes, is improved. Researchers have recently studied the improvement of different quality attributes through refactoring (Mkaouer et al. 2016; Mohan and Greer 2019).&lt;/p&gt;
&lt;p&gt;The refactoring process could be automated to reduce the required time and cost and increase the reliability of applied transformation. Refactoring engines are tools that automate the application of refactorings: first, the user chooses a refactoring to apply, then the engine checks if the transformation is safe and, if so, transforms the program. Refactoring engines are a key component of modern Integrated Development Environments (IDEs), and programmers rely on them to perform refactorings. The programmer need only select which refactoring to apply, and the engine will automatically check the preconditions and apply the transformations across the entire program if the preconditions are satisfied. Refactoring is gaining popularity, as evidenced by the inclusion of refactoring engines in modern IDEs such as IntelliJ IDEA, Eclipse, or NetBeans  for Java.&lt;/p&gt;
&lt;p&gt;According to Fowler (Fowler and Beck 2018), the biggest change to refactoring in the last decade is the availability of tools that support automated refactoring. Refactoring engines must be reliable. A fault in a refactoring engine can silently introduce bugs in the refactored program and lead to challenging debugging sessions. If the original program compiles, but the refactored program does not, the refactoring is obviously incorrect and can be easily undone. However, if the refactoring engine erroneously produces a refactored program that compiles but does not preserve the semantics of the original program, this can have severe consequences. Therefore, an automated refactoring tool must operate on the code’s syntax tree, not the text, to perform refactoring correctly. Manipulating the syntax tree is more reliable for preserving the program syntax, semantics, and behavior. For this reason, developing an automated refactoring tool requires deep knowledge of compiler techniques. Fowler (Fowler and Beck 2018) present a catalog of more than 70 refactoring in his book and state that &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;implementing decent refactoring is a challenging programming exercise—one that I am not mostly unaware of as I gaily use the tools.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Martin Fowler&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;ANTLR Background&lt;/h2&gt;
&lt;p&gt;Before reading this tutorial, I recommend looking at &lt;a href="antlr_basics.md"&gt;ANTLR basic tutorial&lt;/a&gt; where I describe the background of using ANTLR to generate and walk phase three and implement custom program analysis applications with the help of the ANTLR listener mechanism. 
The most important point is that we used the real-world programming languages grammars to show the parsing and analyzing process. The discussed approach forms the underlying concepts of our approach for automated refactoring. Indeed, we implement appropriate listeners that can perform the actions required to apply each refactoring. ANTLR provides &lt;code&gt;TokenStreamRewriter&lt;/code&gt; class which can manipulate program tokens at specific indices in the program. &lt;/p&gt;
&lt;h2&gt;Using ANTLR for automating refactoring&lt;/h2&gt;
&lt;p&gt;The &lt;em&gt;key&lt;/em&gt; to using ANTLR for refactoring tasks is the &lt;code&gt;TokenStreamRewriter&lt;/code&gt; class that knows how to give altered views of a token stream without actually modifying the stream. It treats all of manipulation methods as “instructions” and queues them up for lazy execution when traversing the token stream to render it back as text. The rewriter &lt;em&gt;executes&lt;/em&gt; those instructions every time we call the &lt;code&gt;getText()&lt;/code&gt; method. This strategy is very effective for the general problem of source code instrumentation or refactoring. The &lt;code&gt;TokenStreamRewriter&lt;/code&gt; is a powerful and extremely efficient means of manipulating a token stream.&lt;/p&gt;
&lt;p&gt;In the remaining sections of this post, I discuss different refactoring techniques and describe the automation of most important refactoring operation in Python based on the ANTLR library.&lt;/p&gt;
&lt;p&gt;Please note that the full implementation of the automation of any refactoring operations contains many details that are too complicated to describe here. Therefore, I only focused on the most important part of the automation process in this chapter. For the interested readers, the full implementation of discussed refactoring can be found on &lt;a href="https://github.com/m-zakeri/CodART"&gt;https://github.com/m-zakeri/CodART&lt;/a&gt;. &lt;/p&gt;
&lt;p&gt;CodART  is our recently developed open-source refactoring engine that has automated the application of 16 refactoring operations with ANTLR. The up-to-date documentation of CodART is available on &lt;a href="https://github.com/m-zakeri/CodART"&gt;https://m-zakeri.github.io/CodART/&lt;/a&gt;.
Each refactoring operation has a definition and is clearly specified by the entities in which it is involved and the role of each. I ask you to look at &lt;a href="(https://github.com/m-zakeri/CodART)"&gt;CodART's white&lt;/a&gt; paper to find a decent introduction to refactoring operation.&lt;/p&gt;
&lt;h2&gt;Encapsulate field&lt;/h2&gt;
&lt;p&gt;We begin with a simple yet important refactoring, encapsulate field, which provides information hiding as one of the basic principles of the object-oriented design (Booch et al. 2008). The encapsulate field refactoring replaces all references to a field with accesses through setter and getter methods. This refactoring takes as input the name of the field to encapsulate and the names of its enclosing class. It performs the following transformations:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Creates a public getter method that returns the field’s value, &lt;/li&gt;
&lt;li&gt;Creates a public setter method that updates the field’s value to a given parameter’s value,&lt;/li&gt;
&lt;li&gt;Replaces all field reads with calls to the getter method,&lt;/li&gt;
&lt;li&gt;Replaces all field writes with calls to the setter method,&lt;/li&gt;
&lt;li&gt;Changes the field’s access modifier to private.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Figure 1 shows an example of encapsulate field refactoring for field f in class A. &lt;/p&gt;
&lt;p&gt;&lt;img alt="Figure 1. Example EncapsulateField refactoring" src="../static/img/codart_example.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Figure 1: Example EncapsulateField refactoring&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;To perform this refactoring automatically, we develop a listener class, &lt;code&gt;EncapsulateFiledRefactoringListener&lt;/code&gt;, that implements the aforementioned transformations. The constructor of this class is shown in the following. The class takes an instance of &lt;code&gt;CommonTokenStream&lt;/code&gt; class, source class name, and field identifier as input. The first parameter is used to initialize an instance of &lt;code&gt;TokenStreamRewriter&lt;/code&gt; class which provides a set of methods to manipulate the syntax (parse) tree. The second and third parameters specify the entity to be refactored. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;_version_&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;0.1.0&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;_author_&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;Morteza Zakeri&amp;#39;&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;EncapsulateFiledRefactoringListener&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;JavaParserLabeledListener&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;    To implement the encapsulate field refactoring&lt;/span&gt;
&lt;span class="sd"&gt;    make a public field private and provide &lt;/span&gt;
&lt;span class="sd"&gt;    accessors and mutator methods.&lt;/span&gt;
&lt;span class="sd"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;common_token_stream&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;CommonTokenStream&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                 &lt;span class="n"&gt;source_class_name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                 &lt;span class="n"&gt;field_identifier&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;        :param common_token_stream: contains the program tokens&lt;/span&gt;
&lt;span class="sd"&gt;        :param source_class_name: contains the enclosing class of the field&lt;/span&gt;
&lt;span class="sd"&gt;        :param field_identifier: the field name to be encapsulated &lt;/span&gt;
&lt;span class="sd"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_stream&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;common_token_stream&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;source_class_name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;source_class_name&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;field_identifier&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;field_identifier&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;in_source_class&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;False&lt;/span&gt;

        &lt;span class="c1"&gt;# Move all the tokens in the source code in a buffer,&lt;/span&gt;
        &lt;span class="c1"&gt;# token_stream_rewriter.&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;common_token_stream&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_stream_rewriter&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; \
                &lt;span class="n"&gt;TokenStreamRewriter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;common_token_stream&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;raise&lt;/span&gt; &lt;span class="ne"&gt;TypeError&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;common_token_stream is None&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The entire refactoring application is performed in four steps: First, we should check whether the parse tree walker is visiting the class that contains the given field or not. We use a &lt;code&gt;flag&lt;/code&gt; variable &lt;code&gt;in_source_class&lt;/code&gt; to indicate that the walker is entered into the source class. This flag is set to &lt;code&gt;true&lt;/code&gt; when &lt;code&gt;enterClassDeclaration&lt;/code&gt; method is called and is set back to &lt;code&gt;false&lt;/code&gt; when &lt;code&gt;exitClassDeclaration&lt;/code&gt; method is called:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;enterClassDeclaration&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;JavaParserLabeled&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ClassDeclarationContext&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;IDENTIFIER&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getText&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;source_class_name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;in_source_class&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;True&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;exitClassDeclaration&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;JavaParserLabeled&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ClassDeclarationContext&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;in_source_class&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;False&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The second step is to change the access modifier of the field from public to private. We could perform this either when entering or exiting from the &lt;code&gt;fieldDeclartion&lt;/code&gt; rule in the Java grammar. It is required to ensure that we modify the given field, not other files in the class or program. The first and second &lt;code&gt;if&lt;/code&gt; statements in the following code perform this check. Afterward, the &lt;code&gt;replaceRange&lt;/code&gt; method of the &lt;code&gt;token_stream_rewriter&lt;/code&gt; is called to replace the “public” modifier token with the “private” modifier token, shown in the following code snippet. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;enterFieldDeclaration&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;JavaParserLabeled&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;FieldDeclarationContext&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;in_source_class&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;variableDeclarators&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;variableDeclarator&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
                &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;variableDeclaratorId&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getText&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;field_identifier&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parentCtx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parentCtx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;modifier&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getText&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;public&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_stream_rewriter&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;replaceRange&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
                  &lt;span class="n"&gt;from_idx&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parentCtx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parentCtx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;modifier&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;tokenIndex&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                  &lt;span class="n"&gt;to_idx&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parentCtx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parentCtx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;modifier&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stop&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;tokenIndex&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                  &lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;private&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="k"&gt;return&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Figure 2 shows the part of the parse tree generated for the code snippet in Figure 1. The parse tree visualization help understand the logic behind the implementation of the &lt;code&gt;enterFieldDeclaration&lt;/code&gt; method in the above code. Indeed, we write a fragment of code by observing the position of nodes in the corresponding parse tree. For example, when we enter the &lt;code&gt;fieldDeclartion&lt;/code&gt; rule (i.e., when ANTLR calls the above method), the ANTLR runtime library provides a ctx object of class &lt;code&gt;FieldDeclarationContext&lt;/code&gt;, which contains pointers &lt;code&gt;FieldDeclaration&lt;/code&gt; to parent and children. These pointers allow us to move between the different nodes in the parse tree, typically around our main node, which is &lt;code&gt;FieldDeclaration&lt;/code&gt; in our example. &lt;/p&gt;
&lt;p&gt;&lt;img alt="Figure 2. Part of the parse tree generated for the code is snipped in Figure 1." src="../static/img/refactoring/parse-tree-for-encapsulate-field.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Figure 2: Part of the parse tree generated for the code is snipped in Figure 1 (left).&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Our goal is to change the “public” token to “private,” which is the direct child of the &lt;code&gt;classOrInterfaceModifier&lt;/code&gt; node and the descendant of the modifier node. Therefore, we should access from &lt;code&gt;FieldDeclaration&lt;/code&gt; node to one of the modifier or &lt;code&gt;classOrInterfaceModifier&lt;/code&gt; nodes. The statement &lt;code&gt;ctx.parentCtx.parentCtx.modifier(0)&lt;/code&gt; give us to the first child of the modifier node, i.e., &lt;code&gt;classOrInterfaceModifier&lt;/code&gt;. The green arrow in Figure 2 shows how we can move from &lt;code&gt;FieldDeclaration&lt;/code&gt; node to the &lt;code&gt;classOrInterfaceModifier&lt;/code&gt; node.&lt;/p&gt;
&lt;p&gt;In the third step, we add the getter and setter methods for the encapsulated field to the class body. To this aim, we define the &lt;code&gt;new_code&lt;/code&gt; variable that holds the generated codes. The code can be generated based on a simple &lt;em&gt;template&lt;/em&gt; that accessor and mutator methods typically follow. When the generated code is completed, it is added to the class body after the encapsulated field declaration using the &lt;code&gt;insertAfter&lt;/code&gt; method of the &lt;code&gt;token_stream_rewriter&lt;/code&gt; object. We use the &lt;code&gt;exitFieldDeclaration&lt;/code&gt; method to put the described actions. The following code snippet shows generating and inserting accessor and mutator methods.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;exitFieldDeclaration&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;JavaParserLabeled&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;FieldDeclarationContext&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;in_source_class&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;variableDeclarators&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;variableDeclarator&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
                &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;variableDeclaratorId&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getText&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;field_identifier&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
   &lt;span class="c1"&gt;# Check if getter or setter methods already exist&lt;/span&gt;
   &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parentCtx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parentCtx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parentCtx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;classBodyDeclaration&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
         &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;memberDeclaration&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;methodDeclaration&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;IDENTIFIER&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; \
                &lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getText&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;get&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;capitalize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;field_identifier&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getter_exist&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;True&lt;/span&gt;

        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;memberDeclaration&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;methodDeclaration&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;IDENTIFIER&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; \
                &lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getText&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;set&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;capitalize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;field_identifier&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setter_exist&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;True&lt;/span&gt;

  &lt;span class="c1"&gt;# Generate accessor and mutator methods if not exist&lt;/span&gt;
  &lt;span class="c1"&gt;# Accessor body&lt;/span&gt;
  &lt;span class="n"&gt;new_code&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;#39;&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getter_exist&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
      &lt;span class="n"&gt;new_code&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;&lt;span class="se"&gt;\n\t&lt;/span&gt;&lt;span class="s1"&gt;// new getter method&lt;/span&gt;&lt;span class="se"&gt;\n\t&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;
      &lt;span class="n"&gt;new_code&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;public &amp;#39;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;typeType&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getText&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; \
                &lt;span class="s1"&gt;&amp;#39; get&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;capitalize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;field_identifier&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="n"&gt;new_code&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;() { &lt;/span&gt;&lt;span class="se"&gt;\n\t\t&lt;/span&gt;&lt;span class="s1"&gt;return this.&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;field_identifier&lt;/span&gt; 
             &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;;&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;&lt;span class="se"&gt;\n\t&lt;/span&gt;&lt;span class="s1"&gt;}&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;

  &lt;span class="c1"&gt;# Mutator body&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setter_exist&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
      &lt;span class="n"&gt;new_code&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;&lt;span class="se"&gt;\n\t&lt;/span&gt;&lt;span class="s1"&gt;// new setter method&lt;/span&gt;&lt;span class="se"&gt;\n\t&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;
      &lt;span class="n"&gt;new_code&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;public void set&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; \
                &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;capitalize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;field_identifier&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="n"&gt;new_code&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;(&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;typeType&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getText&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39; &amp;#39;&lt;/span&gt; \
                &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;field_identifier&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;) { &lt;/span&gt;&lt;span class="se"&gt;\n\t\t&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;
      &lt;span class="n"&gt;new_code&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;this.&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;field_identifier&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39; = &amp;#39;&lt;/span&gt; \
                &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;field_identifier&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;;&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;&lt;span class="se"&gt;\n\t&lt;/span&gt;&lt;span class="s1"&gt;}&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;
  &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_stream_rewriter&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;insertAfter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stop&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;tokenIndex&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;new_code&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The above code checks that getter and setter do not already exist. Thereafter, a new getter and setter method is added to the class body.
The fourth step is to update the references of the encapsulated field to replace the field usages with the appropriate setter or getter method. There are different rules in the grammar that describe access to the class fields. A complete encapsulate field refactoring should be considered all rules. However, the code for updating the field usages with getter and setter methods is almost the same. For example, by looking at Figure 3, which is part of the code shown in Figure 1, we can find that when the right-hand side brother of node &lt;code&gt;experssion1&lt;/code&gt; is a binary operator such as MUL, the child of &lt;code&gt;expression1&lt;/code&gt; must be replaced with the getter method. &lt;/p&gt;
&lt;p&gt;&lt;img alt="Figure 3. Part of the parse tree generated for the code is snipped in Figure 1 (left)" src="../static/img/refactoring/parse-tree-for-encapsulate-field-2.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Figure 3: Part of the parse tree generated for the code is snipped in Figure 1 (left)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;The following code snipped performs this transformation when the walker exit from the &lt;code&gt;expression1&lt;/code&gt; node.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;exitExpression1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;JavaParserLabeled&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Expression1Context&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;in_source_class&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;in_selected_package&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parentCtx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getChild&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getText&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; 
                     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;=&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;+=&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;-=&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;*=&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;/=&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;amp;=&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;|=&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;^=&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;gt;&amp;gt;=&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                     &lt;span class="s1"&gt;&amp;#39;&amp;gt;&amp;gt;&amp;gt;=&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;lt;&amp;lt;=&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;%=&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parentCtx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getChild&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="k"&gt;return&lt;/span&gt;
        &lt;span class="k"&gt;except&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;pass&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getText&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;this.&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;field_identifier&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;new_code&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;this.get&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;capitalize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;field_identifier&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;()&amp;#39;&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_stream_rewriter&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;replaceRange&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;tokenIndex&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                                                    &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stop&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;tokenIndex&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                                                    &lt;span class="n"&gt;new_code&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Other places where the encapsulated field is accessed or modified should be found and updated in a similar way described in this step. Once all fourth steps described in this section are applied, the code snippet shown in Figure 1 (left) is transformed to the code snippet shown in Figure 1 (right), and the encapsulated refactoring is completed.&lt;/p&gt;
&lt;h2&gt;Conclusion and remarks&lt;/h2&gt;
&lt;p&gt;Most of the techniques described in this section can be used to automate other refactoring operations. The only different things are the required actions, which are often unique to each refactoring. The overall process consists of looking at the relevant parts of the parse tree, choosing a relevant node, and implementing the required actions.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;ctx&lt;/code&gt; object of the &lt;code&gt;Context&lt;/code&gt; class contains all information we need to find and check or change when performing the refactoring. In addition, visualization of the parse tree helps choose which node can be chosen for which actions and how the actions should be programmed. &lt;/p&gt;
&lt;p&gt;It should be noted that selecting a pares tree node (or grammar rule) to put the required actions does not have a unique and deterministic answer. In other words, we can put our actions in a set of nodes when programming with ANTLR. For example, to change the “public” token to a “private” token, one may put the required actions in the &lt;code&gt;memberDeclartion&lt;/code&gt; node, which sightly changes our above code. The right node should be chosen that minimizes the implementation effort of that actions. As general advice, when automating refactoring operations, we write our actions on the node near the refactoring entities.&lt;/p&gt;
&lt;p&gt;I try to explain the automation of more refactoring operation to this tutorial. &lt;/p&gt;
&lt;p&gt;Stay hungry, stay incomplete :)&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;References&lt;/h2&gt;
&lt;p&gt;Booch G, Maksimchuk RA, Engle MW, et al (2008) Object-oriented analysis and design with applications, third edition. ACM SIGSOFT Softw Eng Notes 33:29–29. https://doi.org/10.1145/1402521.1413138&lt;/p&gt;
&lt;p&gt;Fowler M, Beck K (2018) Refactoring: improving the design of existing code, Second Edi. Addison-Wesley&lt;/p&gt;</content><category term="blog"></category><category term="blog"></category><category term="ANTLR"></category><category term="compiler"></category><category term="tutorial"></category></entry><entry><title>Do software engineers sacrifice themselves?</title><link href="https://m-zakeri.github.io/do-software-engineers-sacrifice-themselves.html" rel="alternate"></link><published>2021-04-05T12:00:00+04:30</published><updated>2021-04-05T12:00:00+04:30</updated><author><name>Morteza</name></author><id>tag:m-zakeri.github.io,2021-04-05:/do-software-engineers-sacrifice-themselves.html</id><summary type="html">&lt;p&gt;We all know about the advantages of agile software development methodologies, DevOps, and CICD. But, what are the negative impacts and the dark sides/dark corners of such highly accepted and recommended software development practices and mindsets on software engineers’ life?&lt;/p&gt;</summary><content type="html">&lt;p&gt;I am eager to know any related comments in response to the following questions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;(Q1)&lt;/strong&gt; What are the negative impacts and the dark side of agile developments on software engineers’ life?&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;(Q2)&lt;/strong&gt; Does agile software development put too much pressure on software engineers and developers?&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;(Q3)&lt;/strong&gt; What are the equivalents of agile methods in other engineering and science disciplines, such as civil engineering, chemical engineering, and medical science?&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;(Q4)&lt;/strong&gt; If there is any equivalent, then how is its popularity and acceptance among the experts in that field?&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;(Q5)&lt;/strong&gt; Should software developers refuse to work for employers that enforce agile methodologies?
Please also help me refine the topic and questions to make something useful for the software engineers’ community.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Dark Sides of the Agile Software Development Culture&lt;/h2&gt;
&lt;p&gt;Agile software development methodologies, along with DevOps and Continuous Integration/Continuous Deployment (CICD), have revolutionized the software industry. Their advantages—such as flexibility, faster delivery, and enhanced collaboration—are widely celebrated. However, beneath this success lies a less-discussed reality: the negative impacts and challenges these methodologies impose on software engineers. This article critically examines the "dark corners" of agile practices and their implications for the software engineering community.&lt;/p&gt;
&lt;h2&gt;The Negative Impacts of Agile Development on Software Engineers' Lives&lt;/h2&gt;
&lt;p&gt;While agile methodologies emphasize adaptability and collaboration, they often lead to unintended consequences:
- &lt;strong&gt;Burnout and Stress&lt;/strong&gt;: The iterative nature of agile, with its constant sprints and deadlines, can create a high-pressure environment. Engineers may feel overwhelmed by the relentless pace and the expectation to deliver continuously.
- &lt;strong&gt;Scope Creep&lt;/strong&gt;: Agile's flexibility can result in frequent changes to project requirements, leading to extended work hours and frustration.
- &lt;strong&gt;Erosion of Work-Life Balance&lt;/strong&gt;: The demand for constant availability and rapid responses to changes can blur the boundaries between personal and professional life.
- &lt;strong&gt;Reduced Creativity&lt;/strong&gt;: The focus on delivering "working software" in short cycles may stifle innovation, as engineers prioritize immediate goals over long-term vision.&lt;/p&gt;
&lt;h2&gt;Does Agile Put Too Much Pressure on Developers?&lt;/h2&gt;
&lt;p&gt;Agile methodologies can indeed exert significant pressure on developers:
- &lt;strong&gt;Effort-Reward Imbalance&lt;/strong&gt;: While agile practices may enhance job satisfaction, they can also increase stress, particularly when developers perceive an imbalance between their efforts and rewards.
- &lt;strong&gt;High Expectations&lt;/strong&gt;: Developers often face tight deadlines and are expected to integrate new tools and practices without compromising delivery.
- &lt;strong&gt;Team Dynamics&lt;/strong&gt;: Agile's reliance on collaboration can be challenging in teams with varying skill levels or communication styles.&lt;/p&gt;
&lt;h2&gt;Equivalents of Agile Methods in Other Disciplines&lt;/h2&gt;
&lt;p&gt;Agile principles have inspired similar approaches in other fields:
- &lt;strong&gt;Civil Engineering&lt;/strong&gt;: Lean construction methods, which emphasize waste reduction and continuous improvement, share similarities with agile.
- &lt;strong&gt;Medical Science&lt;/strong&gt;: Agile-like frameworks are used in clinical trials to adapt to new findings and improve patient outcomes.
- &lt;strong&gt;Chemical Engineering&lt;/strong&gt;: Iterative design processes in product development mirror agile's incremental approach.&lt;/p&gt;
&lt;h2&gt;Popularity and Acceptance in Other Fields&lt;/h2&gt;
&lt;p&gt;The adoption of agile-like methodologies varies across disciplines:
- &lt;strong&gt;Civil Engineering&lt;/strong&gt;: Lean construction is gaining traction but faces resistance due to the industry's traditional mindset.
- &lt;strong&gt;Medical Science&lt;/strong&gt;: Agile frameworks are well-received in research settings but are less common in clinical practice.
- &lt;strong&gt;Chemical Engineering&lt;/strong&gt;: Iterative methods are widely accepted in R&amp;amp;D but are less prevalent in large-scale production.&lt;/p&gt;
&lt;h2&gt;Should Developers Refuse Agile Workplaces?&lt;/h2&gt;
&lt;p&gt;While refusing to work in agile environments may not be practical, developers can advocate for healthier practices:
- &lt;strong&gt;Promote Sustainable Pace&lt;/strong&gt;: Encourage employers to prioritize work-life balance and avoid overloading teams.
- &lt;strong&gt;Seek Transparency&lt;/strong&gt;: Push for clear communication about project goals and expectations.
- &lt;strong&gt;Foster Collaboration&lt;/strong&gt;: Advocate for inclusive team dynamics that respect diverse perspectives.&lt;/p&gt;</content><category term="blog"></category><category term="blog"></category></entry><entry><title>Program dynamic analysis with ANTLR</title><link href="https://m-zakeri.github.io/program-dynamic-analysis-with-antlr.html" rel="alternate"></link><published>2021-03-30T23:45:00+04:30</published><updated>2021-03-30T23:45:00+04:30</updated><author><name>Morteza</name></author><id>tag:m-zakeri.github.io,2021-03-30:/program-dynamic-analysis-with-antlr.html</id><summary type="html">&lt;p&gt;Dynamic analysis refers to extracting specific information from the program related to the program's execution. Therefore, it requires to execute the program under analysis. Often the source code must be augmented in a way that executing the program outputs the additional information required for dynamic analysis. A well-known technique for this aim is program instrumentation. The ANTLR tool can be used to instrument the source code effectively. In this tutorial, I explain how we can use the ANTLR  tool to instrument the C++  program in the Python programming language.&lt;/p&gt;</summary><content type="html">&lt;h2&gt;Introduction&lt;/h2&gt;
&lt;p&gt;In this tutorial we describe a primary task in source code transformation, &lt;em&gt;i.e.&lt;/em&gt;, program instrumentation, which is one of the CodA features.&lt;/p&gt;
&lt;p&gt;The task can be performed by properly applying compiler techniques, adding required code snippets at specific source code places. Instrumentation is the fundamental prerequisite for almost all dynamic analysis types. Let us begin with a simple case in which the purpose of instrumentation is to log the executed path of the program control flow graph for each execution. Consider the following C++ program used to calculate the greatest common divider (GCD) of two integers:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;gcd&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Enter two integers: &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cin&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;// Checks if i is factor of both integers&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num1&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num2&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;gcd&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;G.C.D is &amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;gcd&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;Figure 1. Source code of GCD program.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Appropriate instrumentation will put a log statement at the beginning of each basic block. For simplicity, we add a print statement to write the number of the executed basic block in the console. In the GCD program, lines 6, 10, 13 shows the starting point of basic blocks. Therefore, the instrumented version of the GCD program is similar to the following code, in which print statement has been added manually:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;

&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;fstream&amp;gt;&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;ofstream&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;logFile&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;log_file.txt&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="n"&gt;logFile&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;p1&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;gcd&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Enter two integers: &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cin&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="n"&gt;logFile&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;p2&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;// Checks if i is factor of both integers&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num1&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num2&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;logFile&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;p3&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;gcd&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;//continue;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;G.C.D is &amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;gcd&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;//return 0;&lt;/span&gt;

&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;logFile&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;p4&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;Figure 2. Source code of GCD program after instrumenting.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;One can see the cout statements added in lines 6, 12, 15, i.e., at the beginning of each basic block. For large programs, it is impossible to add such statements manually. To perform this instrumentation by ANTLR, we just need to identify conditional statements, including if statements, loop statements, and switch-case statements. Besides, the beginning of each function should be recognized. ANTLR provides a listener interface that consists of an enter method and exit method for each non-terminal in target language grammar. The listener can be passed to the parse tree walker used for traversing the parse tree in DFS . For instrumenting, we must implement the methods of listener interface related to conditional rules. The implementation of the listener interface in Python is shown in the following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;InstrumentationListener&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CPP14Listener&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;tokenized_source_code&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;CommonTokenStream&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;branch_number&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;tokenized_source_code&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
      &lt;span class="c1"&gt;# Move all the tokens in the source code in a buffer, token_stream_rewriter. &lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_stream_rewriter&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;TokenStreamRewriter&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;TokenStreamRewriter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tokenized_source_code&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;raise&lt;/span&gt; &lt;span class="ne"&gt;Exception&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;‘&lt;/span&gt;&lt;span class="n"&gt;common_token_stream&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;&lt;span class="err"&gt;’&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="c1"&gt;# Creating and open a text file for logging the instrumentation result at beging of the program&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;enterTranslationunit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;CPP14Parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;TranslationunitContext&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;new_code&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s1"&gt; #include &amp;lt;fstream&amp;gt; &lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s1"&gt; std::ofstream logFile(&amp;quot;log_file.txt&amp;quot;); &lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_stream_rewriter&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;insertAfter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;tokenIndex&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;new_code&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;


    &lt;span class="c1"&gt;# DFS traversal of a statement subtree, rooted at ctx and if the statement is a branching condition &lt;/span&gt;
    &lt;span class="c1"&gt;# insert a prob.&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;enterStatement&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;CPP14Parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;StatementContext&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nb"&gt;isinstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parentCtx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CPP14Parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SelectionstatementContext&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                      &lt;span class="n"&gt;CPP14Parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;IterationstatementContext&lt;/span&gt;&lt;span class="p"&gt;)):&lt;/span&gt;
            &lt;span class="c1"&gt;# if there is a compound statement after the branchning condition:&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nb"&gt;isinstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;children&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;CPP14Parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CompoundstatementContext&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
                &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;branch_number&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
                &lt;span class="n"&gt;new_code&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s1"&gt; logFile &amp;lt;&amp;lt; &amp;quot;p&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;branch_number&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;quot; &amp;lt;&amp;lt; endl; &lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;
                &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_stream_rewriter&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;insertAfter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;tokenIndex&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;new_code&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="c1"&gt;# if there is only one statement after the branchning condition then create a block.&lt;/span&gt;
            &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="nb"&gt;isinstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;children&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
                                &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CPP14Parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SelectionstatementContext&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;CPP14Parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;IterationstatementContext&lt;/span&gt;&lt;span class="p"&gt;)):&lt;/span&gt;
                &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;branch_number&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
                &lt;span class="n"&gt;new_code&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;{&amp;#39;&lt;/span&gt;
                &lt;span class="n"&gt;new_code&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s1"&gt; logFile &amp;lt;&amp;lt; &amp;quot;p&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;branch_number&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;quot; &amp;lt;&amp;lt; endl; &lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;
                &lt;span class="n"&gt;new_code&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getText&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
                &lt;span class="n"&gt;new_code&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s1"&gt;}&amp;#39;&lt;/span&gt;
                &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_stream_rewriter&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;replaceRange&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;tokenIndex&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stop&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;tokenIndex&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;new_code&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;enterFunctionbody&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;CPP14Parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;FunctionbodyContext&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;branch_number&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
        &lt;span class="n"&gt;new_code&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s1"&gt; logFile &amp;lt;&amp;lt; &amp;quot;p&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;branch_number&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;quot; &amp;lt;&amp;lt; endl;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_stream_rewriter&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;insertAfter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;tokenIndex&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;new_code&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;Figure 3. ANTLR listener for instrumenting.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;In the above code, class &lt;code&gt;InstrumentationListener&lt;/code&gt; implements the interface &lt;code&gt;CPP14Listener&lt;/code&gt;, which is the base listener for C++ grammar and generated by ANTLR. Note that the grammar of C++ 14 is available at ANTLR official website. Two methods &lt;code&gt;enterStatement()&lt;/code&gt; and &lt;code&gt;enterFunctionbody()&lt;/code&gt; are implemented to add a print statement in proper places of program code, respectively, at the beginning of each conditional statement and each function. These two methods are invoked by ANTLR parser tree walker if we pass an instance of &lt;code&gt;InstrumnentationListerer&lt;/code&gt; to it.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;InstrumentationListener&lt;/code&gt; class also has two attributes: &lt;code&gt;branch_number&lt;/code&gt; and &lt;code&gt;token_stream_rewriter&lt;/code&gt;. branch_umber used to track the number of instrumented blocks during the instrumentation. Each time we add a print statement, we increment the value of &lt;code&gt;branch_number&lt;/code&gt; by one unit. &lt;/p&gt;
&lt;p&gt;Line 3 defines &lt;code&gt;branch_number&lt;/code&gt; and initialize it with zero. &lt;code&gt;token_stream_rewiter&lt;/code&gt; object is an instance of &lt;code&gt;TokenStreamRewiter&lt;/code&gt; class, which is provided by ANTLR and contain the stream of source code tokens. &lt;code&gt;TokenStreamRewriter&lt;/code&gt; initializes with common_token_stream, which already has been built by ANTLR from the lexer class and then provides methods for adding and manipulating code snips within a given stream.  Line 5 creates an instance of &lt;code&gt;TokenStreamRewriter&lt;/code&gt; class to access its required methods. If &lt;code&gt;common_token_stream&lt;/code&gt; is none, then an exception raises (Line 7).&lt;/p&gt;
&lt;p&gt;Let explain the logic of &lt;code&gt;enterFunctionbody()&lt;/code&gt; as it seems to be simpler than &lt;code&gt;enterStatement()&lt;/code&gt;. Each time a function definition occurred in the source code, this method is invoked. First, the branch_number will be increased by 1 (Line 25). At line 26, the print statement, including the branch_number is prepared, and then at Line 27, we tell &lt;code&gt;token_stream_rewiter&lt;/code&gt;  to insert this new code after the current beginning function token, &lt;em&gt;i.e.&lt;/em&gt;, &lt;code&gt;{&lt;/code&gt; in C++. &lt;/p&gt;
&lt;p&gt;For adding print after conditional and loop statements, more effort is required. &lt;code&gt;enterStatement()&lt;/code&gt; is invoked each time that a statement node is visited. Line 10 checks to see if the statement is an instance of &lt;code&gt;SelectionsteatemetContext&lt;/code&gt; or &lt;code&gt;IterationstatementContext&lt;/code&gt;, which are relevant rule contexts for conditional and loop statements in C++ grammar. If this condition is not valid, &lt;em&gt;i.e.&lt;/em&gt;, for regular statements, no action will perform. Otherwise, we are faced with two different situations. The first one (Line 11) is that the body of the conditional or loop statement is a compound statement, i.e., it has more than one statement, which encloses between two braces &lt;code&gt;{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In such a case, we just need to add our print statement at the beginning of the compound statement right after token &lt;code&gt;{&lt;/code&gt;. The code of this condition is exactly the same code used in &lt;code&gt;enterFunctionbody()&lt;/code&gt;. The second situation occurs when the conditional or loop statement has only one statement inside its basic block. In this state, only the first statement is considered within the condition or loop by the compiler. If one adds a print statement without any enclosing brace, the execution path will not be captured correctly. Hence, in Line 15, after detecting that the statement is neither a compound statement nor branch, the proper code will be provided. The required code for instrumenting includes a left brace, a print statement, a current statement or context, and at the end, a right brace. &lt;/p&gt;
&lt;p&gt;Line 22 adds &lt;code&gt;new_code&lt;/code&gt; to the current source code.
Now the implementation of our &lt;code&gt;InstrumentationListener&lt;/code&gt; has been finished. The next step is to write the main driver for the instrumentation tool and connect this listener to the parse tree walker. &lt;/p&gt;
&lt;p&gt;Figure 4 shows the body of the main python script required to create and run our efficient yet straightforward instrumenting tool. A comment line has explained each line of code, and therefore we omit extra descriptions. The only important note is that the instrumented code, &lt;em&gt;i.e.&lt;/em&gt;, the modified source code, is accessible by &lt;code&gt;token_stream_rewirter&lt;/code&gt; object. The &lt;code&gt;getDefualtText()&lt;/code&gt; of &lt;code&gt;token_stream_rewirter&lt;/code&gt; object is called to retrieve the new source code in Line 18.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;antlr4&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;

&lt;span class="c1"&gt;# Step 1: Convert input to a byte stream&lt;/span&gt;
&lt;span class="n"&gt;stream&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;InputStream&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;input_string&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;# Step 2: Create lexer&lt;/span&gt;
&lt;span class="n"&gt;lexer&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;test_v2Lexer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stream&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;# Step 3: Create a list of tokens&lt;/span&gt;
&lt;span class="n"&gt;token_stream&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;CommonTokenStream&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lexer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;# Step 4: Create parser&lt;/span&gt;
&lt;span class="n"&gt;parser&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;test_v2Parser&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;token_stream&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;# Step 5: Create parse tree&lt;/span&gt;
&lt;span class="n"&gt;parse_tree&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="c1"&gt;# Step 6: Adding a listener&lt;/span&gt;
&lt;span class="n"&gt;instrument_listener&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;InstrumentationListener&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;common_token_stream&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;common_token_stream&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;# Step 7: Create parse tree walker&lt;/span&gt;
&lt;span class="n"&gt;walker&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ParseTreeWalker&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="c1"&gt;# Step 8: Walk parse tree, attaching the listener to instrumented_programs the code&lt;/span&gt;
&lt;span class="n"&gt;walker&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;walk&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;listener&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;instrument_listener&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;parse_tree&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;# Step 9: &lt;/span&gt;
&lt;span class="n"&gt;new_source_code&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;instrument_listener&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;token_stream_rewriter&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getDefaultText&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new_source_code&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;Figure 4. The driver code for instrumenting.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;After the instrumenting was completed, the program must be compiled then executed to apply the modification. Figure 5 shows an example of executing with a sample input. As shown in Figure 5, the executed path for inputs 24 and 18 are logged into the console, in addition to the program output, which is 6 in this example. The sequence of the printed path shows the order in which basic blocks were executed. We may change the instrumentation to capture more complicated information about runtime. However, the techniques and principles will be the same used in this simple example. Interested readers may find more exercise about instrumentation at the end of this chapter.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Figure 5" src="../static/img/dynamic_analysis/gcd_execution_output.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Figure 5. An example of executing the GCD program after instrumenting.&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;We show that using the ANTLR listener mechanism; it would be very simple to instrument the real-world CPP programs. A similar technique can be used to instrument the source code written in other programming languages such as Java and C#.
In the &lt;a href="program_instrumentation.md"&gt;next tutorial&lt;/a&gt;, we discuss using ANTLR for static analysis of the source code and computing some source code metrics.&lt;/p&gt;</content><category term="blog"></category><category term="blog"></category><category term="ANTLR"></category><category term="compiler"></category><category term="tutorial"></category></entry><entry><title>Program static analysis with ANTLR</title><link href="https://m-zakeri.github.io/program-static-analysis-with-antlr.html" rel="alternate"></link><published>2021-03-29T23:45:00+04:30</published><updated>2021-03-29T23:45:00+04:30</updated><author><name>Morteza</name></author><id>tag:m-zakeri.github.io,2021-03-29:/program-static-analysis-with-antlr.html</id><summary type="html">&lt;p&gt;Static analysis means extracting specific information from the program artifacts, e.g., source code, without any execution of the program. The ANTLR tool can be used to perform all types of static analysis at the source-code level. In this tutorial, I explain how we can use the ANTLR  tool to perform some basic kinds of static analysis of the C++ programs in the Python programming language. The task I chose to explain is extracting the class diagram and computing the relevant design metrics.&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Introduction&lt;/h1&gt;
&lt;p&gt;Source code and design metrics are extracted from the source code of the software, and their values allow us to reach conclusions about the quality attributes measured by the metrics.&lt;/p&gt;
&lt;p&gt;A practical approach to computing such metrics is static program source code analysis. Again this analysis can be performed by using the compiler front-end to deal with the parse tree and symbol table. The idea is to create a symbol table for the program under analysis and extract desired metrics. In this section, we demonstrate the use of ANLTR to compute two essential design metrics, FANIN, and FANOUT, which affect the testability of a module. &lt;/p&gt;
&lt;p&gt;FANIN and FANOUT can be computed from UML class diagrams. In the case of source code, we require to extract the class diagram from the program source code. We begin with constructing a simple symbol table to hold the necessary entities, e.g., classes and their relationships. Similar to &lt;a href="program_instrumentation.md"&gt;our source code instrumentation tutorial&lt;/a&gt;, the ANTLR listener mechanism is utilized to build the symbol table. The structure of our symbol table is shown in Figure 1.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Figure 1" src="../static/img/static_analysis/symbol_table.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Figure 1: Class diagram of a simple symbol table for C++&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;The class diagram in Figure 1 has been implemented in Python. During syntax tree walking, each entity is recognized and saved in the corresponding instance of symbol table entities. For example, whenever a method is recognized, the instance of the Method class will be created to hold this method. The Model class is needed to keep a list of recognized classes as the top-level entities. The implementation code of the proposed symbol table in Python is straightforward, and we omit the code here.&lt;/p&gt;
&lt;p&gt;The next step is creating a listener and adding codes to fill the symbol table. Listing 1 shows the listener used to recognize and add source code classes to the symbol table.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;DefinitionPassListener&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CPP14Listener&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;    Pass 1: Extracting the classes and structs from a given CPP source code&lt;/span&gt;
&lt;span class="sd"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;model&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Model&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;model&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;model&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Model&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;model&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;model&lt;/span&gt;

        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;class_instance&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;enterClassspecifier&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;CPP14Parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ClassspecifierContext&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;class_instance&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;class_instance&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Class&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;exitClassspecifier&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;CPP14Parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ClassspecifierContext&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;class_instance&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;     
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;model&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;class_list&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;class_instance&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;class_instance&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;enterClassheadname&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;CPP14Parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ClassheadnameContext&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;class_instance&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;class_instance&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getText&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;Listing 1: Recognizing classes in source code  and inserting them into the symbol table&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;When an instance of &lt;code&gt;DefinitionPassListner&lt;/code&gt; in Listing 1 is passed to the &lt;code&gt;ParseTreeWalker&lt;/code&gt; instance, the classes within the source code are identified and inserted into the symbol table. This task has been performed only by implementing the listener methods, which correspond to the class definition rule in C++ grammar. &lt;/p&gt;
&lt;p&gt;To better understand which methods of the base listener (&lt;code&gt;CPP14Listener&lt;/code&gt;), generated by ANTLR, should be implemented to perform this task, we may look at the parse tree of the simple program, including one class with one field, as shown in Listing 2. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;class&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;Listing 2: C++ code snip with one class and one field.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;The parse tree of code snip in Listing is shown in Figure 2.
The parse tree visualization can be performed by the &lt;a href="https://plugins.jetbrains.com/plugin/7358-antlr-v4-grammar-plugin"&gt;ANTLR plugin for IntelliJ IDEA&lt;/a&gt;.
One can see the complexity of the C++ language and its compilation. The pares tree for the program with only four lines of codes has 39 nodes and more than 350 parse decisions (invocation in the recursive descent parsing), which shows that the real programming languages are too complex. Therefore, the only way to analyze and test them is to utilize compiler techniques.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Simple CPP/Java class parse tree" src="../static/img/static_analysis/simple_cpp_class_parse_tree.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Figure 2: The parse tree for the code snippet shown in Listing 2&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;The recognized classes, by applying &lt;code&gt;DefinitionPassListner&lt;/code&gt;, only have a name (set in Line 25). The &lt;code&gt;DefinitionPassListner&lt;/code&gt; listener class does not capture any required relationships for computing FANIN and FANOUT or any other analysis. &lt;/p&gt;
&lt;p&gt;Relationships between classes in each program occurred in different ways, e.g., through the aggregation. In aggregation, one class has a field with the type of the other class. To extract the aggregation relationship, we should extract all fields whose types are user-defined. Therefore, we create another listener with the following codes:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;ResolvePassListener&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;DefinitionPassListener&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;    Pass 2: Extracting the classes&amp;#39; fields&lt;/span&gt;
&lt;span class="sd"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
     &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;model&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Model&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="nb"&gt;super&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;DefinitionPassListener&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;model&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;model&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;enter_member_specification&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;False&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;field&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Field&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;enterMemberspecification&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;CPP14Parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;MemberspecificationContext&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getChildCount&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;enter_member_specification&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;True&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;enterDeclspecifier&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;CPP14Parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DeclspecifierContext&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;enter_member_specification&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;ctx_the_type_name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getText&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;    
            &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;class_instance&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;model&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;class_list&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;ctx_the_type_name&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;class_instance&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                    &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;field&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;class_instance&lt;/span&gt;
                    &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;class_instance&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fields&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;field&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                    &lt;span class="k"&gt;break&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;Listing 3: Adding class fields to the program symbol table&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;The method &lt;code&gt;enterDeclspecifier&lt;/code&gt; is invoked by &lt;code&gt;ParseTreeWalker&lt;/code&gt; each time a field is defined in the program source code. In &lt;code&gt;ResolvePassListener&lt;/code&gt; an extra check is required to ensure that the recognized variable belongs to the class or not. The flag &lt;code&gt;enter_member_specification&lt;/code&gt; is set to true in &lt;code&gt;enterMemeberspecification&lt;/code&gt; method and used to understand the scope of the variable. In &lt;code&gt;enterDeclspecifier&lt;/code&gt; method, the name of the variable is checked to find whether it is the name of another class or not. Indeed, if the field has a user-defined type, then the type of this field is resolved and added to the current class fields. &lt;/p&gt;
&lt;p&gt;There are some practical considerations at this point. Why has a separate class defined for resolving the fields of classes? The &lt;code&gt;ResolvePassListener&lt;/code&gt; has inherited from &lt;code&gt;DefinitionPassListner&lt;/code&gt;, but why? The reason for separating the listener code into two classes is that the symbol table can not be completed by traversing the parse tree only once. If we try to add the field of the class at the same time that we are adding the class itself, we may not be able to find the proper type of the user-defined fields since all types still have not been inserted into the symbol table. The best practice is that two separate analysis passes are applied. One for adding types to the symbol table called definition pass, and another one for resolving the types to check or complete their information called resolved pass. Each pass in the compiling process reads the source code from start to end.&lt;/p&gt;
&lt;p&gt;The resolve pass inherits from the definition pass since the operation in the definition pass is still required. For example, Line 20 in  &lt;code&gt;ResolvePassListener&lt;/code&gt; requires the current class when adding the recognized field to it. &lt;code&gt;DefinitionPassListner&lt;/code&gt;, in Listing 1, is not suitable to use as a parent for ResolvePassListener. It only inserts new classes to the symbol table; however, we need to retrieve them when the ResolvePassListener is being applied. Another problem is that if the current code for &lt;code&gt;DefinitionPassListner&lt;/code&gt; is executed more than once, the same class is inserted to self.model.class_list the object in the symbol table. We should fix the class &lt;code&gt;DefinitionPassListner&lt;/code&gt; to solve these two problems.&lt;/p&gt;
&lt;p&gt;First, before adding a new class (Line 25 in Listing 1), it should be checked that class has not existed in the symbol table. Second, if the class already exists in the code, in &lt;code&gt;enterClassheadname&lt;/code&gt; method, the corresponding class should be retrieved by its name and assigned to &lt;code&gt;self.class_instance&lt;/code&gt; object. These conditions are expected to be met when the &lt;code&gt;ResolvePassListener&lt;/code&gt; is executed as a second pass of our analysis.
Listing 4 shows the modified version of the &lt;code&gt;DefinitionPassListner&lt;/code&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;DefinitionPassListener&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CPP14Listener&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;    Pass 1 (modified): Extracting the classes and structs&lt;/span&gt;
&lt;span class="sd"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;model&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Model&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;model&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;model&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Model&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;model&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;model&lt;/span&gt;

        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;class_instance&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;enterClassspecifier&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;CPP14Parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ClassspecifierContext&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;class_instance&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;class_instance&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Class&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;exitClassspecifier&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;CPP14Parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ClassspecifierContext&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;class_instance&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;model&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;find_calss_by_name&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;class_instance&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="kc"&gt;False&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; 
                &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;model&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;class_list&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;class_instance&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;


            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;class_instance&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;enterClassheadname&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;CPP14Parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ClassheadnameContext&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;class_instance&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;model&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;find_calss_by_name&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getText&lt;/span&gt;&lt;span class="p"&gt;()):&lt;/span&gt;
                &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;class_instance&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;medel&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get_class_by_name&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;class_instance&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;class_instance&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getText&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;Listing 4: The fixed version of the &lt;code&gt;DefinitionPassListener&lt;/code&gt; class.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;In this tutorial, we assumed that the input program is compilable, and hence we did not perform additional compile-time tasks such as type checking. The complete implementation of two listeners, including import statements and some additional codes, will be available on the &lt;a href="https://github.com/m-zakeri/CodA/"&gt;CodA repository&lt;/a&gt;. &lt;/p&gt;
&lt;p&gt;Once our listeners are completed, we can add a driver code to attach these listeners to a &lt;code&gt;ParseTreeWalker&lt;/code&gt; and perform the target task, as discussed in the &lt;a href="antlr_basics.md"&gt;ANTLR basic tutorial&lt;/a&gt;. 
The only difference is that we have two listeners that must be executed in order to get the desired result. Listing 5 shows the driver code for our static analysis task.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;stream&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FileStream&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;input_string&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;lexer&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;test_v2Lexer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stream&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;token_stream&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;CommonTokenStream&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lexer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;parser&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;test_v2Parser&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;token_stream&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;parse_tree&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="n"&gt;pass1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;DefinitionPassListener&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="n"&gt;walker&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ParseTreeWalker&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;walker&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;walk&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;listener&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;pass1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;parse_tree&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;pass2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ResolvePassListener&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;model&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;pass1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;model&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;walker&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;walk&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;walk&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;listener&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;pass2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;parse_tree&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;Listing 5: Driver coed to perform static analysis of the source code.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;The last step in our analysis is to build the class diagram as a directed annotated graph forming the symbol table and compute the &lt;em&gt;FAN-IN&lt;/em&gt; and &lt;em&gt;FAN-OUT&lt;/em&gt; metrics for each class. This step is done by creating a node for each class and adding an edge between two classes, which have an aggregate relationship together. The direction of each edge specifies the direction of aggregation. &lt;/p&gt;
&lt;p&gt;Listing 6 shows the methods that create and visualize the discussed graph. Two methods are defined in the &lt;code&gt;Model&lt;/code&gt; class, which was part of our symbol table in previous steps. The first method, &lt;code&gt;create_graph&lt;/code&gt;, creates a graph for a class diagram. It uses the &lt;em&gt;NetworkX&lt;/em&gt; library to work with graphs. The second method, &lt;code&gt;draw_graph&lt;/code&gt;, makes visualization of the created graph. The &lt;code&gt;Model&lt;/code&gt; class also has two fields &lt;code&gt;class_list&lt;/code&gt; and &lt;code&gt;class_diagram&lt;/code&gt;, which have not been shown in Listing 6. 
The first field holds all class instances of the source code, and the second field holds the class diagram corresponding graph.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;__date__&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;2021-07-19&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;__author__&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;Morteza Zakeri&amp;#39;&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;create_graph&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;class_diagram&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DiGraph&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;class_instance&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;class_list&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;class_diagram&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_node&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;class_instance&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;class_instance&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;class_list&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;class_instance&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;attributes_list&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;class_attribute&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;class_instance&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;attributes_list&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nb"&gt;isinstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;class_attribute&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;variable_type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Class&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; 
                        &lt;span class="nb"&gt;isinstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;class_attribute&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;variable_type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Structure&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
                        &lt;span class="n"&gt;w&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
                        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;class_diagram&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;has_edge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;class_instance&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;class_attribute&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;variable_type&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
                            &lt;span class="n"&gt;w&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;class_diagram&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;class_instance&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;class_attribute&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;variable_type&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;weight&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
                            &lt;span class="n"&gt;w&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
                        &lt;span class="n"&gt;class_diagram&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_edge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;class_instance&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;class_attribute&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;variable_type&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                                               &lt;span class="n"&gt;rel&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Aggregation&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                                               &lt;span class="n"&gt;weight&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;class_diagram&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;class_diagram&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;draw_graph&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;new_names_dict&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;dict&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;node_name&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;class_diagram&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;nodes&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;new_names_dict&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;update&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="n"&gt;node_name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;node_name&lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt;
        &lt;span class="n"&gt;edge_labels&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get_edge_attributes&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;class_diagram&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;rel&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;edge_labels2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get_edge_attributes&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;class_diagram&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;cardinality&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

        &lt;span class="n"&gt;pos&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;kamada_kawai_layout&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;class_diagram&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;nx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;draw_networkx_nodes&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;class_diagram&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                               &lt;span class="n"&gt;nodelist&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;class_diagram&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;nodes&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                               &lt;span class="n"&gt;node_shape&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;s&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                               &lt;span class="n"&gt;node_size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1000&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                               &lt;span class="n"&gt;alpha&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mf"&gt;0.25&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                               &lt;span class="n"&gt;node_color&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;r&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

        &lt;span class="n"&gt;nx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;draw_networkx_edges&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;class_diagram&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                               &lt;span class="n"&gt;edgelist&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;class_diagram&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;edges&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
                               &lt;span class="n"&gt;width&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mf"&gt;2.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                               &lt;span class="n"&gt;alpha&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mf"&gt;0.95&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                               &lt;span class="n"&gt;edge_color&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;nx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;draw_networkx_edge_labels&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;class_diagram&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;labels&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;edge_labels&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;nx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;draw_networkx_edge_labels&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;class_diagram&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;labels&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;edge_labels2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;nx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;draw_networkx_labels&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;class_diagram&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;new_names_dict&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;font_size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;11&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

        &lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;show&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;Listing 6: Methods for creating and visualizing a simple class diagram.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;FAN-IN and FAN-OUT can for each class are defined respectively as in-degree and out-degree of the class diagram corresponding graph. Therefore, having that graph means that we can compute these metrics quickly. To illustrate the discussed static analysis on a real program, consider the C++ program in Listing 7, which has four simple classes: &lt;code&gt;Person&lt;/code&gt;, &lt;code&gt;Student&lt;/code&gt;, &lt;code&gt;Teacher&lt;/code&gt;, and &lt;code&gt;Course&lt;/code&gt;. The implementation of classes has been omitted for simplicity. Both the &lt;code&gt;Student&lt;/code&gt; class and &lt;code&gt;Teacher&lt;/code&gt; class have been inherited from the class &lt;code&gt;Person&lt;/code&gt;. In addition, the &lt;code&gt;Student&lt;/code&gt;  class has aggregated an instance of the &lt;code&gt;Course&lt;/code&gt; class. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="cp"&gt;#&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cp"&gt;include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cp"&gt;include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;using&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;namespace&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;std&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Person&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;protected&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;firstName&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;lastName&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;nationalCode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;Person&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;firstName&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;lastName&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;nationalCode&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;setPersonName&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;firstName&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;lastName&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;virtual&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;doJob&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="n"&gt;Person&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Person&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;firstName&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;lastName&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;nationalCode&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;firstName&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;firstName&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;lastName&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;lastName&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;nationalCode&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;nationalCode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Person&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;setPersonName&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;firstName&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;lastName&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;firstName&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;firstName&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;lastName&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;lastName&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Person&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;doJob&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;firstName&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot; is a person &amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Student&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Person&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;studentNumber&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;Course&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cource&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;Student&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;firstName&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;lastName&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;nationalCode&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;studentNumber&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;doJob&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;override&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="n"&gt;Student&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Student&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;firstName&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;lastName&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;nationalCode&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;studentNumber&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;Person&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;firstName&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;lastName&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;nationalCode&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;studentNumber&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;studentNumber&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;I am a student: &amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;studentNumber&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;cource&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Course&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;cource&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Software Engieering&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Student&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;doJob&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;firstName&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot; is studing &amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Teacher&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Person&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;teacherNumber&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;Teacher&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;firstName&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;lastName&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;nationalCode&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;teacherNumber&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;doJob&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;override&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="n"&gt;Teacher&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Teacher&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;firstName&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;lastName&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;nationalCode&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;teacherNumber&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;Person&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;firstName&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;lastName&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;nationalCode&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;teacherNumber&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;teacherNumber&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;I am a teacher: &amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;teacherNumber&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Teacher&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;doJob&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;firstName&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot; is teaching &amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Course&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;Course&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;course_name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;course_numbber&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="n"&gt;Course&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Course&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;course_name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;course_numbber&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;course_name&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;course_numbber&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="cm"&gt;/* main function */&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;Teacher&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;t1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Saeed&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Parsa&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1234&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1398&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;Student&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;s1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Morteza&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Zakeri&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;5678&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2020&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;t1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;doJob&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;s1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;doJob&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;Listing 7: A C++ application to test the developed static analysis program in this tutorial.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;The corresponding graph for the class diagram of this program, which is the output of executing codes in Listings 5 and 6, has been shown in Figure 3. As one can see, the inheritance relationships also have been shown in the figure. We omitted the code that captures the inheritance relationship in this section. You may ask to implement the extraction of inheritance relationships after reading this tutorial. &lt;/p&gt;
&lt;p&gt;&lt;img alt="The extracted class diagram" src="../static/img/static_analysis/extracted_calss_diagram.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Figure 3: Class diagram for the program shown in Listing 7.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;FAN-IN and FAN-OUT metrics can be computed, as discussed earlier. For this simple example, FAN-IN for class Student is 0, and FAN-OUT is one; however, for complete computation of these metrics, all relationships, including association, dependencies, and parameters passing, should be considered. &lt;/p&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;p&gt;In this tutorial and the &lt;a href="program_instrumentation.md"&gt;previous one&lt;/a&gt;, I discussed the application of compilers in static and dynamic software analysis. I demonstrated these applications through a simple example of source code instrumentation and metrics computation. The former is a transformation task that modifies the source code, and the latter is an analysis task that extracts some information from the source code. Both of them are essential tasks in the future of software engineering. &lt;/p&gt;
&lt;p&gt;Systematic software testing and quality assurance tools can be built on top of compiler tools such as ANTLR, LLVM, JDT, and Roslyn, with techniques presented in this chapter. Compilers build a detailed model of application code as they validate the syntax and semantics of that code. While traditional compilers used such a model to build the executable output from the source code in a block box manner, the new generation of compilers provides APIs to access the internal details of this model, which can be utilized to build more reliable software. Software testing is more realistic with advanced support by compilers.&lt;/p&gt;</content><category term="blog"></category><category term="blog"></category><category term="ANTLR"></category><category term="compiler"></category><category term="tutorial"></category></entry><entry><title>Advanced Software Engineering</title><link href="https://m-zakeri.github.io/advanced-software-engineering.html" rel="alternate"></link><published>2021-03-23T00:23:00+04:30</published><updated>2021-03-23T00:23:00+04:30</updated><author><name>Morteza</name></author><id>tag:m-zakeri.github.io,2021-03-23:/advanced-software-engineering.html</id><summary type="html">&lt;p&gt;Advanced Software Engineering, graduate course.&lt;/p&gt;</summary><content type="html">&lt;h2&gt;Foreword&lt;/h2&gt;
&lt;p&gt;The AUT advanced software engineering (ASE) course aims at teaching the latest and emerging topics and advances in the field of software engineering to the students who are already familiar with basic subjects in the field. Here, I will share relevant materials and resources with you.&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Course Description&lt;/h2&gt;
&lt;p&gt;This course delves into the latest trends, emerging topics, and cutting-edge advances in the field of software engineering. Designed for students with a foundational understanding of software engineering concepts, the course covers innovative methodologies, tools, and frameworks that are shaping the modern software development landscape. Through in-depth case studies, hands-on projects, and discussions on real-world challenges, students will explore how to drive innovation and implement advanced practices in software engineering.&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Course Objectives&lt;/h2&gt;
&lt;p&gt;By the end of this course, students will:
1. Gain familiarity with the latest research and advancements in software engineering.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Learn to adopt and adapt emerging methodologies and frameworks for large-scale software systems.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Understand the impact of intelligent tools and automation in the software development lifecycle (SDLC).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Explore advanced topics like microservices, cloud-native development, and software observability.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Critically assess and integrate evolving practices to solve modern software engineering challenges.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2&gt;Syllabus&lt;/h2&gt;
&lt;h3&gt;Week 1-2: Introduction to Advanced Software Engineering&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Overview of modern challenges in software engineering&lt;/li&gt;
&lt;li&gt;Emerging trends and technologies in the field&lt;/li&gt;
&lt;li&gt;Recap of fundamental principles and frameworks&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Week 3-4: Continuous Integration, Deployment, and Delivery&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;CI/CD pipelines and automation tools&lt;/li&gt;
&lt;li&gt;Best practices for seamless software deployment&lt;/li&gt;
&lt;li&gt;Ensuring quality and reliability in fast-paced development&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Week 5-6: DevOps and Cloud-Native Software Engineering&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Principles of DevOps culture and practices&lt;/li&gt;
&lt;li&gt;Cloud-native development and containerization with Docker and Kubernetes&lt;/li&gt;
&lt;li&gt;Serverless architectures and their applications&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Week 7-8: Software Observability and Resilience&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Monitoring, logging, and tracing software systems&lt;/li&gt;
&lt;li&gt;Building resilient applications with fault tolerance&lt;/li&gt;
&lt;li&gt;Best practices for incident response and root cause analysis&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Week 9-10: Intelligent Tools and Automation in Software Engineering&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Machine learning applications in the SDLC&lt;/li&gt;
&lt;li&gt;Automated code generation, testing, and debugging&lt;/li&gt;
&lt;li&gt;Intelligent software refactoring and evolution&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Week 11-12: Advanced Software Architectures&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Exploring microservices and event-driven architectures&lt;/li&gt;
&lt;li&gt;Designing scalable, maintainable, and secure systems&lt;/li&gt;
&lt;li&gt;Understanding domain-driven design (DDD)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Week 13: Ethical and Societal Aspects of Software Engineering&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Understanding the social and ethical implications of modern software&lt;/li&gt;
&lt;li&gt;Discussing data privacy, security, and sustainability in engineering practices&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Week 14: Capstone Project and Review&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Applying advanced concepts to design and implement a solution to a real-world problem&lt;/li&gt;
&lt;li&gt;Final presentations and peer reviews&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2&gt;Course Assessment&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Assignments (25%)&lt;/strong&gt;: Hands-on tasks focusing on advanced tools and techniques.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Paper-based Exam (40%)&lt;/strong&gt;: Evaluation of theoretical understanding of emerging topics.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Capstone Project (25%)&lt;/strong&gt;: Team-based project addressing real-world challenges in software engineering.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Participation (10%)&lt;/strong&gt;: Contribution to discussions, peer reviews, and active engagement in the course.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2&gt;Resources&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Textbooks&lt;/strong&gt;:&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Continuous Delivery: Reliable Software Releases through Build, Test, and Deployment Automation&lt;/em&gt; by Jez Humble and David Farley&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Building Microservices: Designing Fine-Grained Systems&lt;/em&gt; by Sam Newman&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Online Platforms&lt;/strong&gt;:&lt;/li&gt;
&lt;li&gt;Cloud platforms such as AWS, Azure, or Google Cloud for practical exercises&lt;/li&gt;
&lt;li&gt;Tools like Jenkins, Docker, Kubernetes, and Prometheus&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Research Papers&lt;/strong&gt;:&lt;/li&gt;
&lt;li&gt;Recent publications on software engineering from top conferences like ICSE and ASE&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2&gt;Prerequisites&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;A solid foundation in software engineering principles.&lt;/li&gt;
&lt;li&gt;Familiarity with basic software development methodologies and tools.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2&gt;Contact Information&lt;/h2&gt;
&lt;p&gt;For inquiries, feel free to reach out via my webpage: &lt;a href="http://www.m-zakeri.github.io" target="_blank"&gt;www.m-zakeri.github.io&lt;/a&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;This structure ensures clarity and provides a robust roadmap for your &lt;em&gt;Advanced Software Engineering&lt;/em&gt; course. Let me know if you'd like to refine any part!&lt;/p&gt;
&lt;h2&gt;Course history&lt;/h2&gt;
&lt;h3&gt;Teaching assistant&lt;/h3&gt;
&lt;p&gt;I was teaching assistant of Advanced Software Engineering M.Sc. and Ph.D. course by &lt;a href="http://parsa.iust.ac.ir/" target="_blank"&gt;Dr. Saeed Parsa&lt;/a&gt; for six semesters at Iran University of Science and Technology. 
Our teaching materials during these three years are available to view and download.&lt;/p&gt;
&lt;h3&gt;Useful links&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://parsa.iust.ac.ir/courses/advanced-software-engineering/" target="_blank"&gt;Course official website&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="courses"></category><category term="courses"></category><category term="teaching"></category></entry><entry><title>Compilers</title><link href="https://m-zakeri.github.io/compilers.html" rel="alternate"></link><published>2021-03-23T00:23:00+04:30</published><updated>2021-03-23T00:23:00+04:30</updated><author><name>Morteza</name></author><id>tag:m-zakeri.github.io,2021-03-23:/compilers.html</id><summary type="html">&lt;p&gt;Compiler design and constructions, Undergraduate course (Bachelor). The course is designed to:&lt;/p&gt;</summary><content type="html">&lt;ul&gt;
&lt;li&gt;Provide an in-depth understanding of the principles, techniques, and tools used in the design and implementation of compilers.&lt;/li&gt;
&lt;li&gt;Equip students with the ability to write and optimize programs by understanding how high-level code is translated into machine-level instructions.&lt;/li&gt;
&lt;li&gt;Introduce concepts of language parsing, code generation, and optimization techniques that are critical for the development of efficient and reliable software.&lt;/li&gt;
&lt;li&gt;Foster the ability to analyze and improve existing compiler systems, as well as design new ones from scratch.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Objectives&lt;/h2&gt;
&lt;p&gt;By the end of this course, students will be able to:
1. Understand the fundamental phases of a compiler, including lexical analysis, syntax analysis, semantic analysis, code generation, and optimization.
2. Develop skills to implement key components of a compiler, such as parsers, symbol tables, and intermediate code generators.
3. Recognize and utilize various parsing techniques, including top-down and bottom-up parsing strategies.
4. Apply optimization techniques to improve the performance of compiled code.
5. Gain exposure to modern tools and technologies used in compiler construction, such as Lex and Yacc.&lt;/p&gt;
&lt;h2&gt;Syllabus&lt;/h2&gt;
&lt;h3&gt;1. Introduction to Compiler Design&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Role of a compiler in the software development lifecycle&lt;/li&gt;
&lt;li&gt;Overview of programming languages and their features&lt;/li&gt;
&lt;li&gt;Architecture of a compiler&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2. Lexical Analysis&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Lexical tokens, patterns, and lexemes&lt;/li&gt;
&lt;li&gt;Design of lexical analyzers&lt;/li&gt;
&lt;li&gt;Introduction to Lex and its usage&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;3. Syntax Analysis&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Context-free grammars and parse trees&lt;/li&gt;
&lt;li&gt;Top-down parsing (recursive descent, LL) and bottom-up parsing (LR, LALR)&lt;/li&gt;
&lt;li&gt;Error detection and recovery mechanisms in parsers&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;4. Semantic Analysis&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Role of semantic analysis in a compiler&lt;/li&gt;
&lt;li&gt;Type checking and type inference&lt;/li&gt;
&lt;li&gt;Symbol tables and attribute grammars&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;5. Intermediate Code Generation&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Representations such as three-address code, quadruples, and abstract syntax trees&lt;/li&gt;
&lt;li&gt;Translating high-level constructs into intermediate representations&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;6. Code Optimization&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Local vs global optimization techniques&lt;/li&gt;
&lt;li&gt;Loop optimizations, dead code elimination, and inlining&lt;/li&gt;
&lt;li&gt;Role of data-flow analysis in optimization&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;7. Code Generation&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Instruction selection and register allocation&lt;/li&gt;
&lt;li&gt;Basic blocks and flow graphs&lt;/li&gt;
&lt;li&gt;Generating efficient machine-level code&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;8. Advanced Topics&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Just-In-Time (JIT) Compilation&lt;/li&gt;
&lt;li&gt;Compiler frameworks (LLVM, GCC)&lt;/li&gt;
&lt;li&gt;Introduction to domain-specific languages (DSLs)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;9. Project and Case Studies&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Design and implementation of a small-scale compiler&lt;/li&gt;
&lt;li&gt;Case studies on modern compiler systems and frameworks&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2&gt;Teaching assistant&lt;/h2&gt;
&lt;h3&gt;Foreword&lt;/h3&gt;
&lt;p&gt;I was teaching assistant of Compiler Design and Construction B.Sc. course by &lt;a href="http://parsa.iust.ac.ir/" target="_blank"&gt;Dr. Saeed Parsa&lt;/a&gt; for seven semesters (more than three years) at Iran University of Science and Technology. Our teaching materials during these three years are available to view and download.&lt;/p&gt;
&lt;p&gt;I put all source code that I developed to practically teach compiler  to students on the GitHub page, the &lt;a href="http://parsa.iust.ac.ir/courses/compilers/" target="_blank"&gt;IUST compiler course&lt;/a&gt;. &lt;/p&gt;
&lt;h3&gt;Useful links&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://parsa.iust.ac.ir/courses/compilers/" target="_blank"&gt;ISUT Compiler Course Official page&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://m-zakeri.github.io/IUSTCompiler/" target="_blank"&gt;ISUT Compiler Course GitHub Page (in English)&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://compileriust.github.io/" target="_blank"&gt;ISUT Compiler Course GitHub Page (in Persian)&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Projects&lt;/h3&gt;
&lt;p&gt;I designed and planned some &lt;strong&gt;practical&lt;/strong&gt; projects about the applications of compiler science in &lt;strong&gt;program analysis&lt;/strong&gt;.
The projects shown in Table 1 have been assigned to the students who take the IUST compiler course during different semesters. Click on the link in the "Project" column to see the project proposal. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Table 1:&lt;/strong&gt; Compiler projects.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Project&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;th&gt;Semesters&lt;/th&gt;
&lt;th&gt;Courses&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href="https://m-zakeri.github.io/IUSTCompiler/projects/core_symbol_table_development/" target="_blank"&gt;OpenUnderstand  2&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Low-level source   code metrics calculation&lt;/td&gt;
&lt;td&gt;Spring 2022&lt;/td&gt;
&lt;td&gt;Compiler&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href="https://m-zakeri.github.io/IUSTCompiler/projects/core_symbol_table_development/" target="_blank"&gt;OpenUnderstand&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Symbols table   development&lt;/td&gt;
&lt;td&gt;Fall 2021,   Spring 2022,&lt;/td&gt;
&lt;td&gt;Compiler&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href="https://m-zakeri.github.io/IUSTCompiler/projects/core_software_metrics_development/" target="_blank"&gt;QualityMeter&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;- Source code   quality attribute computation     - Refactoring   opportunity detection&lt;/td&gt;
&lt;td&gt;Fall 2021&lt;/td&gt;
&lt;td&gt;Advanced compiler&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href="https://m-zakeri.github.io/IUSTCompiler/projects/core_code_smell_development/" target="_blank"&gt;CodART 2&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Source code   smell detection&lt;/td&gt;
&lt;td&gt;Spring 2021   (Cancelled)&lt;/td&gt;
&lt;td&gt;Compiler&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href="https://m-zakeri.github.io/IUSTCompiler/projects/core_refactoring_to_design_patterns_development/" target="_blank"&gt;CodART&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Source code   refactoring&lt;/td&gt;
&lt;td&gt;Fall 2020,   Spring 2021,&lt;/td&gt;
&lt;td&gt;Compiler&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href="https://m-zakeri.github.io/IUSTCompiler/projects/core_refactorings_development/" target="_blank"&gt;CodART&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Refactoring   to design pattern at the source code level&lt;/td&gt;
&lt;td&gt;Fall 2020&lt;/td&gt;
&lt;td&gt;Advanced compiler&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href="https://m-zakeri.github.io/Compilers/projects/core_clean_code_development/" target="_blank"&gt;CleanCode&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Source code   smell detection&lt;/td&gt;
&lt;td&gt;Fall 2019,   Spring 2020&lt;/td&gt;
&lt;td&gt;Compiler&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href="https://m-zakeri.github.io/Compilers/projects/core_source_code_instrumentation_development/" target="_blank"&gt;CodA&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Source code instrumentation   and testbed analysis tool&lt;/td&gt;
&lt;td&gt;Fall 2018&lt;/td&gt;
&lt;td&gt;Compiler /     Advanced compiler&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href="https://m-zakeri.github.io/Compilers/projects/mini_java_compiler_development/" target="_blank"&gt;ANTLR MiniJava&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Parse-tree   and intermediate code generation for the MiniJava programming language with   ANTLR&lt;/td&gt;
&lt;td&gt;Fall 2016,   Spring 2017&lt;/td&gt;
&lt;td&gt;Compiler&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;As a student&lt;/h2&gt;
&lt;p&gt;I always enjoy learning about compilers, code transformation, and their application in automated software engineering. I firmly believe that the next generation of software engineers are intelligent white-box compilers! Such compilers are structure-aware, context-aware, and domain-aware, assisting the programmer in writing high-quality and testable programs. 
Compilers helped artificial intelligence (AI) in the past, and now AI boosts compilers!&lt;/p&gt;</content><category term="courses"></category><category term="courses"></category><category term="teaching"></category></entry><entry><title>Patterns and Principle in Software Engineering</title><link href="https://m-zakeri.github.io/patterns-and-principle-in-software-engineering.html" rel="alternate"></link><published>2021-03-23T00:23:00+04:30</published><updated>2021-03-23T00:23:00+04:30</updated><author><name>Morteza</name></author><id>tag:m-zakeri.github.io,2021-03-23:/patterns-and-principle-in-software-engineering.html</id><summary type="html">&lt;p&gt;Patterns and Principles in Software Engineering, graduate course.&lt;/p&gt;</summary><content type="html">&lt;h2&gt;Course Description&lt;/h2&gt;
&lt;p&gt;This course explores the foundational principles and design patterns that underpin modern software engineering. It aims to equip students with a deep understanding of reusable solutions, architectural patterns, and best practices to enhance the quality, maintainability, and scalability of software systems. Through a mix of theoretical concepts and practical applications, students will learn how to apply these principles effectively in real-world scenarios.&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Course Objectives&lt;/h2&gt;
&lt;p&gt;By the end of this course, students will:
1. Understand core software design principles such as SOLID, DRY, and KISS.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Analyze and apply common software design patterns including Creational, Structural, and Behavioral patterns.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Develop skills to architect scalable and maintainable software systems.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Explore principles of software evolution, refactoring, and maintainability.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Gain insights into modern software development practices, including agile development and DevOps principles.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2&gt;Syllabus&lt;/h2&gt;
&lt;h3&gt;Week 1-2: Introduction to Software Engineering Principles&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Overview of Software Engineering&lt;/li&gt;
&lt;li&gt;Key concepts: Scalability, Maintainability, and Modularity&lt;/li&gt;
&lt;li&gt;Introduction to SOLID Principles and Object-Oriented Design&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Week 3-4: Design Patterns - An Overview&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;What are Design Patterns?&lt;/li&gt;
&lt;li&gt;Types of Patterns: Creational, Structural, Behavioral&lt;/li&gt;
&lt;li&gt;Case studies of practical design pattern applications&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Week 5-6: Creational Patterns&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Singleton, Factory, Abstract Factory, Builder, Prototype&lt;/li&gt;
&lt;li&gt;Practical examples and coding exercises&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Week 7-8: Structural Patterns&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Adapter, Bridge, Composite, Decorator, Facade, Flyweight, Proxy&lt;/li&gt;
&lt;li&gt;Designing software with structural patterns&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Week 9-10: Behavioral Patterns&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Chain of Responsibility, Command, Interpreter, Iterator&lt;/li&gt;
&lt;li&gt;Mediator, Memento, Observer, State, Strategy, Template, Visitor&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Week 11: Architectural Patterns&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;MVC (Model-View-Controller), MVP, MVVM&lt;/li&gt;
&lt;li&gt;Microservices, Event-Driven Architecture&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Week 12: Software Evolution and Refactoring&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Principles of software refactoring&lt;/li&gt;
&lt;li&gt;Techniques to improve existing codebases while maintaining functionality&lt;/li&gt;
&lt;li&gt;Tools and practices for code quality improvement&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Week 13: Patterns in Agile Development and DevOps&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Continuous Integration and Continuous Deployment (CI/CD) Practices&lt;/li&gt;
&lt;li&gt;Design patterns supporting agile development&lt;/li&gt;
&lt;li&gt;Design for testability and automation&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Week 14: Capstone Project and Review&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Applying learned patterns and principles to a real-world project&lt;/li&gt;
&lt;li&gt;Final presentations and feedback&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2&gt;Course Assessment&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Assignments (25%)&lt;/strong&gt;: Weekly exercises on applying patterns.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Paper-based Exam (40%)&lt;/strong&gt;: Theoretical and practical understanding of design principles.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Capstone Project (25%)&lt;/strong&gt;: Collaborative project designing a software system.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Participation (10%)&lt;/strong&gt;: Engaging in discussions and code reviews.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2&gt;Resources&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Textbooks&lt;/strong&gt;:&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Design Patterns: Elements of Reusable Object-Oriented Software&lt;/em&gt; by Erich Gamma et al.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Clean Architecture: A Craftsman’s Guide to Software Structure and Design&lt;/em&gt; by Robert C. Martin&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Online Platforms&lt;/strong&gt;:&lt;/li&gt;
&lt;li&gt;GitHub for version control and collaboration&lt;/li&gt;
&lt;li&gt;IDEs like IntelliJ IDEA or Visual Studio Code for coding exercises&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Additional Resources&lt;/strong&gt;:&lt;/li&gt;
&lt;li&gt;Documentation for tools and frameworks used in the course&lt;/li&gt;
&lt;li&gt;Research papers on software architecture and design&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2&gt;Prerequisites&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Basic understanding of programming concepts.&lt;/li&gt;
&lt;li&gt;Familiarity with object-oriented programming (OOP) and data structures.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2&gt;Contact Information&lt;/h2&gt;
&lt;p&gt;For questions, reach out via my webpage: &lt;a href="http://www.m-zakeri.github.io" target="_blank"&gt;www.m-zakeri.github.io&lt;/a&gt;.&lt;/p&gt;</content><category term="courses"></category><category term="courses"></category><category term="teaching"></category></entry><entry><title>An introduction to ANTLR in Python</title><link href="https://m-zakeri.github.io/An-introduction-to-ANTLR-in-Python.html" rel="alternate"></link><published>2021-03-22T23:00:00+04:30</published><updated>2021-03-22T23:00:00+04:30</updated><author><name>Morteza</name></author><id>tag:m-zakeri.github.io,2021-03-22:/An-introduction-to-ANTLR-in-Python.html</id><summary type="html">&lt;p&gt;ANTLR is a parser generator that can generate the parser program from context-free grammar descriptions specified in the ANTLR grammar format. In this tutorial, I explain how we can generate and use the Java parser with ANTLR in the Python programming language.&lt;/p&gt;</summary><content type="html">&lt;h2&gt;Background&lt;/h2&gt;
&lt;p&gt;The ANTLR tool generates a top-down parser from the grammar rules defined with the ANTLR meta-grammar (Parr and Fisher 2011). The initial version of ANTLR generated the target parser source code in Java. In the current version (version 4), the parser source code can be generated in a wide range of programming languages listed on the &lt;a href="https://www.antlr.org" target="_blank"&gt;ANTLR official website&lt;/a&gt; (Parr 2022a). 
For simplicity, we generate the parser in Python 3, which provides us to run the tool on every platform having Python 3 installed on it. 
Another reason to use Python is that we can integrate the developed program easily with other libraries available in Python, such as machine learning and optimization libraries. 
Finally, I found that there is no comprehensive tutorial on using ANTLR with the Python backend. &lt;/p&gt;
&lt;p&gt;To use ANTLR in other programming languages, specifically Java and C#, refer to the ANTLR slides I created before this tutorial. &lt;/p&gt;
&lt;p&gt;The ANTLR tool is a small “.jar” file that must be run from the command line to generate the parser codes. The ANTLR tool jar file can be downloaded from &lt;a href="https://www.antlr.org/download/antlr-4.10.1-complete.jar"&gt;here&lt;/a&gt;. &lt;/p&gt;
&lt;h2&gt;Generating parser&lt;/h2&gt;
&lt;p&gt;As mentioned, to generate a parser for a programming language, the grammar specification described with ANTLR meta-grammar is required. ANTLR grammar files are named with the “.g4” suffix. &lt;/p&gt;
&lt;p&gt;We obtain the grammar of Java 8 to build our parser for the Java programming language. The grammar can be downloaded from ANTLR 4 grammar repository on GitHub: &lt;a href="[https://github.com/antlr/grammars-v4"&gt;https://github.com/antlr/grammars-v4&lt;/a&gt;. 
Once the ANTLR tool and required grammar files are prepared, we can generate the parser for that with the following command:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;gt; java -Xmx500M -cp antlr-4.9.3-complete.jar org.antlr.v4.Tool -Dlanguage=Python3 -o . JavaLexer.g4

&amp;gt; java -Xmx500M -cp antlr-4.9.3-complete.jar org.antlr.v4.Tool -Dlanguage=Python3 -visitor -listener -o . JavaLabeledParser.g4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The first command generates the lexer from the &lt;code&gt;JavaLexer.g4&lt;/code&gt; description file and the second command generates the parser from the &lt;code&gt;JavaLabeledParser.g4&lt;/code&gt; description file. It is worth noting that the lexer and parser can be written in one file. In such a case, a &lt;em&gt;single command&lt;/em&gt; generates all required codes in one step.&lt;/p&gt;
&lt;p&gt;The grammar files used in the above command are also available in &lt;a href="https://m-zakeri.github.io/IUSTCompiler/grammars" target="_blank"&gt;grammars directory&lt;/a&gt; of the CodART repository.
You may see that I have made some modifications to the Parser rules. &lt;/p&gt;
&lt;p&gt;In the above commands, the &lt;code&gt;antlr-4.9.3-complete.jar&lt;/code&gt; is the ANTLR tool that requires Java to be executed. &lt;code&gt;-Dlanguage&lt;/code&gt; denotes the destination language that the ANTLR parser (and lexer) source code is generated in which. In our case, we set it to Python3. &lt;/p&gt;
&lt;p&gt;After executing the ANTLR parser generation commands, eight files, including parser source code and other required information, are generated. Figure 1 shows the generated files. The “.py” contains lexer and parser source code that can parse any Java input file. The &lt;code&gt;-visitor -listener&lt;/code&gt; switches in the second command result in generating two separate source files, &lt;code&gt;JavaLabledParserListener.py&lt;/code&gt; and &lt;code&gt;JavaLabledParserVistor.py&lt;/code&gt;, which provide interfaces to implement the required codes for a specific language application. Our application is source code refactoring which uses the listener mechanism to implement necessary actions transforming the program to the refactored version. 
The parse tree structure in and listener mechanism are discussed in the next sections.&lt;/p&gt;
&lt;p&gt;&lt;img alt="ANTLR generated files " src="../static/img/antlr_basics/antlr-generated-files.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Figure 1. Generated files by ANTLR.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;It should be noted that to use the generated classes in Figure 1, for developing a specific program, we need to install the appropriate ANTLR runtime library. For creating ANTLR-based programs in Python, the command &lt;code&gt;pip install antlr-python3-runtime&lt;/code&gt; can be used. It installed all runtime dependencies required to program using the ANTLR library.&lt;/p&gt;
&lt;h2&gt;ANTLR parse tree&lt;/h2&gt;
&lt;p&gt;The generated parser by ANTLR is responsible for parsing every Java source code file and generating the parse tree or designating the syntax errors in the input file. The parse tree for real-world programs with thousands of lines of code has a non-trivial structure. ANTLR developers have provided some IDE plugins that can visualize the parse tree to better understand the structure of the parse tree generated by ANTLR. We use Pycharm IDE developed by Jetbrains  to work with Python code. &lt;/p&gt;
&lt;p&gt;Figure 2 shows how we can install the ANTLR plugin in PyCharm. The plugin source code is available on the &lt;a href="https://github.com/antlr/intellij-plugin-v4" target="_blank"&gt;GitHub repo&lt;/a&gt;. When the plugin is installed, the ANTLR preview widow is applied at the bottom of the PyCharm IDE. In addition, the IDE can be recognized as “.g4” files and some other options added to the IDE. The main option is the ability to test a grammar rule and visualize the corresponding parse tree to that rule.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Installing ANTLR plugin in PyCharm IDE " src="../static/img/antlr_basics/installing-antlr4-plugin-in-pycharm.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Figure 2. Installing the ANTLR plugin in the PyCharm IDE.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;In order to use the ANTLR preview tab, the ANTLR grammar should be opened in the PyCharm IDE. We then select a rule (typically the start rule) of our grammar, right-click on the rule, and select the “Test Rule &lt;code&gt;rule_name&lt;/code&gt;” option from the opened menu, shown in Figure 3. We now write our sample input program in the left panel of the ANTLR preview, and the parse tree is shown in the right panel. &lt;/p&gt;
&lt;p&gt;&lt;img alt="Test the grammar rule in the ANTLR PyCharm plugin " src="../static/img/antlr_basics/selecting-rule-for-test-in-antlr-preview-window.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Figure 3. Test the grammar rule in the ANTLR PyCharm plugin.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Figure 4 shows a simple Java class and the corresponding parse tree generated by the ANTLR. The leaves of the parse tree are program tokens, while the intermediate nodes are grammar rules that the evaluating program is derived from them. Also, the root of the tree is the grammar rule, which we selected to start parsing. It means that we can select and test every rule independently. However, a complete Java program can only parse from the start rule of the given grammar, i.e., the &lt;code&gt;compilaionUnit&lt;/code&gt; rule.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Test the grammar rule in the ANTLR PyCharm plugin" src="../static/img/antlr_basics/example_of_antlr-parse-tree-in-antlr-preview.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Figure 4. Test the grammar rule in the ANTLR PyCharm plugin.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;It should be mentioned that the ANTLR Preview window is based on a grammar interpreter, not on the actual generated parser described in the previous section. It means that grammar attributes such as actions and predicates will not be evaluated during live preview because the interpreter is language agnostic. For the same reasons, if the generated parser and/or lexer classes extend a custom implementation of the base parser/lexer classes, the custom code will not be run during the live preview. &lt;/p&gt;
&lt;p&gt;In addition to the parse tree visualization, the ANTLR plugin provides facilities such as profiling, code generation, etc., described in &lt;a href="https://github.com/antlr/intellij-plugin-v4" target="_blank"&gt;here&lt;/a&gt; (Parr 2022b). For example, the profile tab shows the execution time of each rule in the parser for a given input string.&lt;/p&gt;
&lt;p&gt;I want to emphasize that visualizing the parse tree with the ANTLR plugin is really helpful when developing code and fixing bugs described in the next section of this tutorial.&lt;/p&gt;
&lt;h2&gt;Traversing the parse tree programmatically&lt;/h2&gt;
&lt;p&gt;ANTLR is not a simple parser generator. It provides a depth-first parse tree visiting and a callback mechanism called listener to implement the required program analysis or transformation passes. The depth-first search is performed by instantiating an object from the ANTLR &lt;code&gt;ParseTreeWalker&lt;/code&gt; class and calling the walk method, which takes an instance of &lt;code&gt;ParseTree&lt;/code&gt; as an input argument and traverses it.&lt;/p&gt;
&lt;p&gt;Obviously, if we visit the parse tree with the depth-first search algorithm, all program tokens are visited in the same order that they appeared in the source code file. However, the depth-first search contains additional information about when a node in the tree is visited and when the visiting all nodes in its subtree is finished. Therefore, we can add the required actions when visiting a node to perform a special task. For example, according to Figure 4, for counting the number of classes in a code snippet, we can define a counter variable, initialize it to zero, and increase it whenever the walker visits the “classDeclartion” node. &lt;/p&gt;
&lt;p&gt;ANTLR provides two callback functions for each node in the parse tree. One is called by the walker when it is entered into a node, i.e., visit the node, but the children are not visited yet. Another is called when all nodes in the subtree of the visited node have been visited, and the walker is exiting the node. These callback functions are available in the listener class generated by the ANTLR for every rule in a given grammar. In our example for counting the number of classes, we implement all required logic in the body of &lt;code&gt;enterClassDeclartion&lt;/code&gt; method of the &lt;code&gt;JavaLabledParserListener&lt;/code&gt; class. We called these logic codes &lt;em&gt;grammar’s actions&lt;/em&gt; since, indeed, they are bunded to a grammar rule. &lt;/p&gt;
&lt;p&gt;It is worth noting that we can add these actions codes in the grammar file (&lt;code&gt;.g4&lt;/code&gt; file) to form an attributed grammar. Embedding actions in grammar increase the efficiency of the analyzing process. However, when we need many complex actions, the listener mechanism provides a better way to implement them. Indeed, ANTLR 4 emphasizes separating the language applications from the language grammar by using the listener mechanism.&lt;/p&gt;
&lt;p&gt;Listing 1 shows the implementation program for counting the number of classes using the ANTLR listener mechanism. The &lt;code&gt;DesignMetrics&lt;/code&gt; class inherits from &lt;code&gt;JavaLabeledParserListener&lt;/code&gt; class which is the default listener class generated by ANTLR. We only implement the &lt;code&gt;enterClassDeclartion&lt;/code&gt; method, which increases the value of the &lt;code&gt;__dsc&lt;/code&gt; counter each time the walker visits a Java class.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# module: JavaLabledParserListener.py&lt;/span&gt;

&lt;span class="n"&gt;__version__&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;0.1.0&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;__author__&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Morteza&amp;quot;&lt;/span&gt;

&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;antlr4&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="vm"&gt;__name__&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;.&amp;quot;&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="vm"&gt;__name__&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;.JavaLabeledParser&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;JavaLabeledParser&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;JavaLabeledParser&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;JavaLabeledParser&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;JavaLabeledParserListener&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ParseTreeListener&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="c1"&gt;# …&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;enterClassDeclaration&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                              &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;JavaLabeledParser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ClassDeclarationContext&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;pass&lt;/span&gt;
    &lt;span class="c1"&gt;# …&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;DesignMetrics&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;JavaLabeledParserListener&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__dsc&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;  &lt;span class="c1"&gt;# Keep design size in classes&lt;/span&gt;

    &lt;span class="nd"&gt;@property&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;get_design_size&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__dsc&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;enterClassDeclaration&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                              &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;JavaLabeledParser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ClassDeclarationContext&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__dsc&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;Listing 1: Programs that count the number of classes in a Java source code.&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;Wiring the modules&lt;/h3&gt;
&lt;p&gt;To complete our simple analysis task, first, the parse tree for a given input should be constructed. Then, the DesignMetrics class should be instantiated and passed to an object of ParseTreeWalker class. We created a driver module in Python beside the generated code by ANTLR to connect different parts of our program and complete our task. Listing 2 shows the implementation of the main driver for a program that counts the number of classes in Java source codes.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# Module: main_driver.py&lt;/span&gt;

&lt;span class="n"&gt;__version__&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;0.1.0&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;__author__&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Morteza&amp;quot;&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;antlr4&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;JavaLabledLexer&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;JavaLabledLexer&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;JavaLeabledParser&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;JavaLabledParser&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;JavaLabledParserListener&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;DesignMetrics&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;

    &lt;span class="c1"&gt;# Step 1: Load input source into the stream object&lt;/span&gt;
    &lt;span class="n"&gt;stream&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FileStream&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;encoding&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;utf8&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="c1"&gt;# Step 2: Create an instance of AssignmentStLexer&lt;/span&gt;
    &lt;span class="n"&gt;lexer&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;JavaLabledLexer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stream&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="c1"&gt;# Step 3: Convert the input source into a list of tokens&lt;/span&gt;
    &lt;span class="n"&gt;token_stream&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;CommonTokenStream&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lexer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="c1"&gt;# Step 4: Create an instance of the AssignmentStParser&lt;/span&gt;
    &lt;span class="n"&gt;parser&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;JavaLabledParser&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;token_stream&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="c1"&gt;# Step 5: Create parse tree&lt;/span&gt;
    &lt;span class="n"&gt;parse_tree&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;compilationUnit&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

    &lt;span class="c1"&gt;# Step 6: Create an instance of DesignMetrics listener class&lt;/span&gt;
    &lt;span class="n"&gt;my_listener&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;DesignMetrics&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

    &lt;span class="c1"&gt;# Step 7: Create a walker to traverse the parse tree and callback our listener&lt;/span&gt;
    &lt;span class="n"&gt;walker&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ParseTreeWalker&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;walker&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;walk&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;parse_tree&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;listener&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;my_listener&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="c1"&gt;# Step 8: Getting the results&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sa"&gt;f&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;DSC=&lt;/span&gt;&lt;span class="si"&gt;{&lt;/span&gt;&lt;span class="n"&gt;my_listener&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get_design_size&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;Listing 2: Main driver module for the program in Listing 1&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;Conclusion and remarks&lt;/h2&gt;
&lt;p&gt;In this tutorial, we described the basic concepts regarding using the ANTLR tool to generate and walk phase three and implement custom program analysis applications with the help of the ANTLR listener mechanism. The most important point is that we used the real-world programming languages grammars to show the parsing and analyzing process. The discussed topics form the underlying concepts of our approach for automated refactoring used in CodART.
Check out the &lt;a href="https://m-zakeri.github.io/CodART/tutorials/antlr_advanced/" target="_blank"&gt;ANTLR advanced tutorial&lt;/a&gt; to find out how we can use ANTLR for reliable and efficient program transformation.&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;References&lt;/h2&gt;
&lt;p&gt;Parr T ANTLR (ANother Tool for Language Recognition). https://www.antlr.org. Accessed 10 Jan 2022a&lt;/p&gt;
&lt;p&gt;Parr T IntelliJ Idea Plugin for ANTLR v4. https://github.com/antlr/intellij-plugin-v4. Accessed 10 Jan 2022b&lt;/p&gt;
&lt;p&gt;Parr T, Fisher K (2011) LL(*): the foundation of the ANTLR parser generator. Proc 32nd ACM SIGPLAN Conf Program Lang Des Implement 425–436. https://doi.org/http://doi.acm.org/10.1145/1993498.1993548&lt;/p&gt;</content><category term="blog"></category><category term="blog"></category><category term="ANTLR"></category><category term="compiler"></category><category term="tutorial"></category></entry><entry><title>Innovations on Automatic Test Data Generation</title><link href="https://m-zakeri.github.io/innovations-on-automatic-test-data-generation.html" rel="alternate"></link><published>2021-03-22T23:00:00+04:30</published><updated>2021-03-22T23:00:00+04:30</updated><author><name>Morteza</name></author><id>tag:m-zakeri.github.io,2021-03-22:/innovations-on-automatic-test-data-generation.html</id><summary type="html">&lt;p&gt;Fuzz testing (Fuzzing) is a dynamic software testing technique. In this technique with repeated generation and injection of malformed test data to the software under test (SUT), we are looking for possible faults and vulnerabilities.&lt;/p&gt;</summary><content type="html">&lt;p&gt;Fuzz testing (Fuzzing) is a dynamic software testing technique. In this technique with repeated generation and injection of malformed test data to the software under test (SUT), we are looking for possible faults and vulnerabilities. To this goal, fuzz testing requires varieties of test data. The most critical challenge is to handle the complexity of the file structures as program input. Surveys have revealed that many of the generated test data in these cases follow restricted numbers and superficial paths, because of being rejected by the parser of SUT in the initial stages of parsing. Using the grammatical structure of input files to generate test data lead to increase code coverage. However, often, the grammar extraction is performed manually, which is a time consuming, costly and error-prone task.&lt;/p&gt;
&lt;p&gt;Recently, we proposed an automated method for hybrid test data generation. We applied neural language models (NLMs) that are constructed by recurrent neural networks (RNNs). The proposed models by using deep learning techniques can learn the statistical structure of complex files and then generate new textual test data, based on the grammar, and binary data, based on mutations. Fuzzing the generated data is done by two newly introduced algorithms, called neural fuzz algorithms that use these models. We use our proposed method to generate test data, and then fuzz testing of MuPDF complicated software which takes portable document format (PDF) files as input. To train our generative models, we gathered a large corpus of PDF files. Our experiments demonstrate that the data generated by this method leads to an increase in the code coverage, more than 7.0%, compared to state-of-the-art file format fuzzers such as American fuzzy lop (AFL). Experiments also indicate a better learning accuracy of simpler NLMS in comparison with the more complicated encoder-decoder model and confirm that our proposed models can outperform the encoder-decoder model in code coverage when fuzzing the SUT.&lt;/p&gt;
&lt;p&gt;Out paper presents a solution for complex test data generation with the help of deep neural networks. The word “complex” in this context means that test data consist of various data types gathering together based on a specific format or grammar. This is what happens in most of the real-word applications which accept a file as their main input. For example, PDF reader software must handle PDF files as input, and PDF is one of the most complex input formats. A PDF file contains both textual and non-textual or binary data plus many human-defined rules which put such data fields beside each other and generate a file. To handle a complex file, an application processes the file in different stages. These stages usually begin by parsing the input file, then continue with semantic analysis, and finally terminate by executing the file content. Generating test data, here a complex input file, which can access to high code coverage and find more probably existing bugs, require that test data pass all of these stages. To the best of our knowledge, the methods used in fuzzing, one of the most effective software testing technics, show that randomly generating such test data lead to very low coverage of code and hence can not guarantee the absence of bugs or reliability of software. On the other hand, generating test data from grammar requires extracting the grammar or model of the file manually, which is expensive and time-consuming.&lt;/p&gt;
&lt;h2&gt;Challenges and Solutions&lt;/h2&gt;
&lt;p&gt;The problem of generating complex test data that successfully pass different stages in the processing of the file is addressed by using some machine learning techniques to learn the structure of a given input file and then generates some new test data based on the learned model. A file can be seen as a sequence of bytes which generate by a grammar of that file. Hence, we can use a language model to automatically learn this grammar form a corpus containing various samples of the given file. Neural language models are effective models to learn natural language properties and successfully are utilized in the complex natural language processing (NLP) tasks such as machine translation and image captioning. We apply a model based on deep neural language to learn the grammar of the file. The learned model is then sampled to generate new files as test data.&lt;/p&gt;
&lt;p&gt;The first problem we encountered was finding a mechanism to distinguish between data and meta-data. To do so, we applied a reasonable trick: As meta-data repeated in almost every sample of a file format, the learned model predicts the meta-data with higher probability in comparison to data. By putting a threshold at a model output, the data and metadata are distinguishable.&lt;/p&gt;
&lt;p&gt;Aims to seek bugs in software by fuzzing techniques, the second problem was how to determine which byte should be fuzzed to reveal failures in the software under test (SUT). This can be done by targeting different stages of input processing that SUT used them. For example, if we would like to fuzz parser, we should fuzz meta-data because parser usually deals with meta-data to validate the format of the input file and to extract data. On the other hand, if we would like to fuzz the execution stage, it may be better to fuzz data. The ability of the learned model in distinguishing data and meta-data is used to determine the place of fuzz in the file.&lt;/p&gt;
&lt;p&gt;In addition to determining the place of the fuzz, we should inform the value for replacing the third problem we addressed. As we know, the goal of fuzzing is creating the malformed input, and hence the most inappropriate byte is expected to put in the place of fuzz. Again most inappropriate byte can be determined by the learned neural language model. It is enough to select a byte with the lowest likelihood instead of the highest likelihood used in the default manner.&lt;/p&gt;
&lt;p&gt;The fourth problem that raised in this regard was training a neural language model on an ASCII character set rather than training it on all bytes. To deal with non-ASCII bytes that make non-textual parts of the input, we replaced these parts by a specific token, called  Binary Token, and asked the model to learn that token. At the generating time, whenever a model predicted the specific binary token, we replace the binary token with a real binary section previously deleted form file. This is a simple but effective method to reach a hybrid test data generation scheme. Two specific fuzzing algorithms, MetadataNeuralFuzz and DataNeuralFuzz, are proposed based on a learned generative model. The former targets the parsing stage, and the latter focuses on rendering or executions stage in the processing of the input files. We believe that both algorithms are required to reach a complete fuzz testing with high code coverage and probably a high number of discovered bugs. We investigate the effectiveness of various language models with different configurations and several sampling strategies in the context of complex test data generation. Also, we study various parameters required when generating and fuzzing test data with deep learning techniques.
Tools and Publications&lt;/p&gt;
&lt;p&gt;To bring our new theory to a practical tool, we designed and implemented IUST-DeePFUzz as a modular file format fuzzer. The main module of IUST DeepFuzz is a test data generator that implements our neural fuzz algorithms. The fuzzer injects test data to SUT and checks for unexpected results such as crash the memory of the SUT. IUST DeepFuzz uses Microsoft Application Verifier, a free runtime monitoring tool, as a monitoring module to catch any memory corruption. It also uses VSPerfMon, another tool from Microsoft, to measure code coverage. Modules are connected using modest Python and batch scripts. IUST-DeepFuzz can find both the place and the value of the fuzzed symbol automatically while generating the input. Other file formats such as HTML, CSS, XML, JSON, and all types of source codes can be produced in the same manner which is suitable for fuzzing and quick quality assurance of any software systems.&lt;/p&gt;
&lt;h2&gt;Read more&lt;/h2&gt;
&lt;p&gt;For more information about both the theoretical and practical aspect of IUST-DeepFuzz, refer to the &lt;a href="https://m-zakeri.github.io/iust_deep_fuzz"&gt;IUST-DeepFuzz website&lt;/a&gt;.&lt;/p&gt;</content><category term="blog"></category><category term="blog"></category><category term="Testing"></category><category term="Fuzzing"></category></entry><entry><title>Dynamic Complex Network</title><link href="https://m-zakeri.github.io/dynamic-complex-network.html" rel="alternate"></link><published>2020-03-04T21:12:00+03:30</published><updated>2020-03-04T21:12:00+03:30</updated><author><name>Morteza</name></author><id>tag:m-zakeri.github.io,2020-03-04:/dynamic-complex-network.html</id><summary type="html">&lt;p&gt;Dynamic Complex Network, Graduate course.&lt;/p&gt;</summary><content type="html">&lt;h2&gt;Course Description&lt;/h2&gt;
&lt;p&gt;This course provides an in-depth exploration of complex dynamic networks, focusing on their structure, behavior, and applications across various domains. Students will study the mathematical foundations, analysis techniques, and real-world implications of network dynamics. By examining interconnected systems, ranging from social networks to biological and technological networks, students will gain the tools necessary to model, analyze, and optimize network-based systems in the real world.&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Course Objectives&lt;/h2&gt;
&lt;p&gt;By the end of this course, students will:
1. Understand the fundamental concepts and theories of network science.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Analyze and characterize the dynamics of complex networks, including robustness, scalability, and efficiency.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Apply mathematical and computational models to study network behavior and emergent phenomena.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Explore the role of networks in diverse applications, including communication systems, social systems, biology, and finance.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Develop practical skills in modeling and simulating dynamic networks using advanced tools and frameworks.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2&gt;Syllabus&lt;/h2&gt;
&lt;h3&gt;Week 1-2: Fundamentals of Complex Networks&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Introduction to network science&lt;/li&gt;
&lt;li&gt;Graph theory basics: nodes, edges, adjacency matrices&lt;/li&gt;
&lt;li&gt;Types of networks: random, small-world, scale-free, and multiplex&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Week 3-4: Network Structure and Properties&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Key network metrics: degree distribution, centrality, clustering coefficient&lt;/li&gt;
&lt;li&gt;Community detection and modularity&lt;/li&gt;
&lt;li&gt;Real-world network structures and their implications&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Week 5-6: Dynamic Processes on Networks&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Diffusion and spreading processes (e.g., information, diseases)&lt;/li&gt;
&lt;li&gt;Synchronization and collective behavior&lt;/li&gt;
&lt;li&gt;Contagion models in social and biological networks&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Week 7-8: Robustness and Resilience of Networks&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Vulnerability analysis and fault tolerance&lt;/li&gt;
&lt;li&gt;Cascading failures in critical infrastructure networks&lt;/li&gt;
&lt;li&gt;Designing robust and resilient networked systems&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Week 9-10: Network Optimization and Control&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Controllability of complex networks&lt;/li&gt;
&lt;li&gt;Optimizing network flows and resource allocation&lt;/li&gt;
&lt;li&gt;Applications in transportation and communication systems&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Week 11-12: Advanced Topics in Network Science&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Temporal networks and evolving structures&lt;/li&gt;
&lt;li&gt;Multilayer and interconnected networks&lt;/li&gt;
&lt;li&gt;Data-driven approaches to network analysis&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Week 13: Applications of Complex Dynamic Networks&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Social networks and influence propagation&lt;/li&gt;
&lt;li&gt;Biological and ecological networks&lt;/li&gt;
&lt;li&gt;Applications in finance, power grids, and smart cities&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Week 14: Capstone Project and Review&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Designing, simulating, and analyzing a complex network for a chosen domain&lt;/li&gt;
&lt;li&gt;Final presentations and peer reviews&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2&gt;Course Assessment&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Assignments (25%)&lt;/strong&gt;: Analytical exercises and computational tasks.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Papsr-based Exam (40%)&lt;/strong&gt;: Theoretical understanding of network concepts.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Capstone Project (25%)&lt;/strong&gt;: Team-based project involving real-world network analysis.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Participation (10%)&lt;/strong&gt;: Active engagement in discussions, workshops, and reviews.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2&gt;Resources&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Textbooks&lt;/strong&gt;:&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Networks: An Introduction&lt;/em&gt; by Mark Newman&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Dynamical Processes on Complex Networks&lt;/em&gt; by Alain Barrat et al.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Online Platforms&lt;/strong&gt;:&lt;/li&gt;
&lt;li&gt;Software tools such as Gephi, NetworkX (Python), and Cytoscape for network modeling and analysis&lt;/li&gt;
&lt;li&gt;Online datasets for real-world network examples&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Research Papers&lt;/strong&gt;:&lt;/li&gt;
&lt;li&gt;Recent publications on network science and dynamic systems from top journals&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2&gt;Prerequisites&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;A basic understanding of graph theory and linear algebra.&lt;/li&gt;
&lt;li&gt;Familiarity with programming and data analysis tools.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2&gt;Contact Information&lt;/h2&gt;
&lt;p&gt;For inquiries, feel free to reach out via my webpage: &lt;a href="http://www.m-zakeri.github.io"&gt;www.m-zakeri.github.io&lt;/a&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Course history&lt;/h2&gt;
&lt;h2&gt;Teaching assistant&lt;/h2&gt;
&lt;p&gt;I was teaching assistant of Dynamic Complex Network M.Sc. and Ph.D. course by &lt;a href="http://webpages.iust.ac.ir/h_rahmani" target="_blank"&gt;Dr. Hossein Rahmani&lt;/a&gt; for one semester (Winter and spring 2020) at Iran University of Science and Technology. 
Our teaching materials during these two years are available to view and download.&lt;/p&gt;
&lt;h3&gt;Useful links&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://m-zakeri.github.io/iust_complex_network" target="_blank"&gt;Course code samples and homework solutions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://m-zakeri.github.io/CodART/" target="_blank"&gt;Software clustering&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="courses"></category><category term="courses"></category><category term="teaching"></category></entry><entry><title>Game Theory</title><link href="https://m-zakeri.github.io/game-theory.html" rel="alternate"></link><published>2020-03-04T21:12:00+03:30</published><updated>2020-03-04T21:12:00+03:30</updated><author><name>Morteza</name></author><id>tag:m-zakeri.github.io,2020-03-04:/game-theory.html</id><summary type="html">&lt;p&gt;Game Theory, Graduate course.&lt;/p&gt;</summary><content type="html">&lt;p&gt;The course discusses the fundamentals of game theory. Game theory is the study of mathematical models of strategic interactions among rational agents. It has applications in all fields of social science and logic, economics, systems science, and computer science. Initially, it addresses two-person zero-sum games, in which each participant's gains or losses are exactly balanced by those of other participants. Game theory has recently found many applications in formulating network resource allocation problems and coordinating network entities' behavior to achieve a stable operating point with global consensus property.&lt;/p&gt;
&lt;h2&gt;Teaching assistant&lt;/h2&gt;
&lt;h2&gt;Foreword&lt;/h2&gt;
&lt;p&gt;I was teaching assistant of Game Theory M.Sc. and Ph.D. course by &lt;a href="http://webpages.iust.ac.ir/vhakami" target="_blank"&gt;Dr. Vesal Hakami&lt;/a&gt; for one semester (Winter and spring 2020) at Iran University of Science and Technology. Here, our teaching materials during these two years are available to view and download&lt;/p&gt;
&lt;h3&gt;Useful links&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.dropbox.com/s/tup6h56v6hvfxe5/hw01.pdf?dl=0" target="_blank"&gt;Homework #1 (PDF)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.dropbox.com/s/1holxfir0f5qfmn/hw02.pdf?dl=0" target="_blank"&gt;Homework #2 (PDF)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.dropbox.com/s/p36nebp41n0j98o/hw03.pdf?dl=0" target="_blank"&gt;Homework #3 (PDF)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.dropbox.com/s/zdxudn8hyj4empo/GT982_online_midterm_instructions.pdf?dl=0" target="_blank"&gt;Midterm instructions&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="courses"></category><category term="courses"></category><category term="teaching"></category></entry><entry><title>WordPress for beginning</title><link href="https://m-zakeri.github.io/wordpress-for-beginning.html" rel="alternate"></link><published>2019-04-02T02:00:00+04:30</published><updated>2019-04-02T02:00:00+04:30</updated><author><name>Morteza</name></author><id>tag:m-zakeri.github.io,2019-04-02:/wordpress-for-beginning.html</id><summary type="html">&lt;p&gt;WordPress essential training for beginners&lt;/p&gt;</summary><content type="html">&lt;p&gt;Welcome to our WordPress essential training for beginners: &lt;strong&gt;WordPress for Beginning&lt;/strong&gt;.
WordPress is a free and open-source content management system (CMS) based on PHP programming language and MySQL database. Features include a plugin architecture and a template system. It is most associated with blogging but supports other types of web content including more traditional mailing lists and forums, media galleries, and online stores. Used by more than 60 million websites, including 30.6% of the top 10 million websites, make it a popular CMS and web framework. The following video tutorials help you start building your own website by WordPress. Tutorials are available in Persian language.&lt;/p&gt;
&lt;h2&gt;Video tutorials&lt;/h2&gt;
&lt;h3&gt;Part 0: Introduction and syllabus&lt;/h3&gt;
&lt;div id="15541545029611626"&gt;&lt;script type="text/JavaScript" src="https://www.aparat.com/embed/KPqS7?data[rnddiv]=15541545029611626&amp;data[responsive]=yes"&gt;&lt;/script&gt;&lt;/div&gt;

&lt;h3&gt;Part 1: Internet and world wide web (www)&lt;/h3&gt;
&lt;div id="15541545263083211"&gt;&lt;script type="text/JavaScript" src="https://www.aparat.com/embed/xM7sP?data[rnddiv]=15541545263083211&amp;data[responsive]=yes"&gt;&lt;/script&gt;&lt;/div&gt;

&lt;h3&gt;Part 2: Content management systems (CMSs)&lt;/h3&gt;
&lt;div id="15541545411872107"&gt;&lt;script type="text/JavaScript" src="https://www.aparat.com/embed/HPfO4?data[rnddiv]=15541545411872107&amp;data[responsive]=yes"&gt;&lt;/script&gt;&lt;/div&gt;

&lt;h3&gt;Part 3: Installing and configuring WordPress on cPanel&lt;/h3&gt;
&lt;p&gt;Coming soon&lt;/p&gt;
&lt;h3&gt;Part 4: Working with WordPress admin panel (dashboard)&lt;/h3&gt;
&lt;p&gt;Coming soon&lt;/p&gt;
&lt;h3&gt;Part 5: Plugin management&lt;/h3&gt;
&lt;p&gt;Coming soon&lt;/p&gt;
&lt;h3&gt;Part 6: Media management&lt;/h3&gt;
&lt;p&gt;Coming soon&lt;/p&gt;
&lt;h3&gt;Part 7: User management&lt;/h3&gt;</content><category term="blog"></category><category term="blog"></category><category term="WordPress"></category></entry><entry><title>Children and programming</title><link href="https://m-zakeri.github.io/children-and-programming.html" rel="alternate"></link><published>2019-03-10T21:13:00+03:30</published><updated>2019-03-10T21:13:00+03:30</updated><author><name>Morteza</name></author><id>tag:m-zakeri.github.io,2019-03-10:/children-and-programming.html</id><summary type="html">&lt;p&gt;Getting started: Teach computer programming to your children, today!&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="Children and Programming " src="../static/img/children-and-programming.jpg"&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;"Children are a free resource of positive energy." &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I love teaching computer programming to children. For many obvious reasons, I strongly believe that the 21st century is the century of &lt;strong&gt;CODE&lt;/strong&gt;. 
But where should we start from? 
What can we do for our 21st century kids?&lt;/p&gt;
&lt;p&gt;There are many ways to teach programming to a kid. I have begun with &lt;a href="https://scratch.mit.edu" target="_blank"&gt;Scratch&lt;/a&gt; programming tool to teach some children
the basic of computer programming. 
Typically, children love computer games and enjoy playing them. However, I found that they enjoy more to learn how computer games could be made.&lt;/p&gt;
&lt;p&gt;Scratch is a block-based visual programming language targeted primarily at children. Scratch is used as the introductory language because creation of interesting programs is relatively easy, and skills learned can be applied to other programming languages such as Python and Java. Although Scratch’s main user age group is 8–18 years of age, Scratch has been created for educators and parents. &lt;/p&gt;
&lt;p&gt;You can see the result teaching programming to my niece, Yasin, in &lt;a href="https://www.limoonad.com/course/193887/%D8%A2%D9%85%D9%88%D8%B2%D8%B4-%D8%A8%D8%B1%D9%86%D8%A7%D9%85%D9%87-%D9%86%D9%88%DB%8C%D8%B3%DB%8C-%D8%A8%D9%87-%DA%A9%D9%88%D8%AF%DA%A9%D8%A7%D9%86-%D8%AF%D8%A7%D9%86%D8%B4-%D8%A2%D9%85%D9%88%D8%B2%D8%A7%D9%86-%D8%A7%D8%B3%DA%A9%D8%B1%DA%86-scratch"&gt;these videos tutorials&lt;/a&gt;, prepared by him.&lt;/p&gt;</content><category term="blog"></category><category term="blog"></category></entry><entry><title>A survey of sequence-to-sequence learning with neural networks</title><link href="https://m-zakeri.github.io/a-survey-of-sequence-to-sequence-learning-with-neural-networks.html" rel="alternate"></link><published>2019-02-22T12:30:00+03:30</published><updated>2019-02-22T12:30:00+03:30</updated><author><name>Morteza</name></author><id>tag:m-zakeri.github.io,2019-02-22:/a-survey-of-sequence-to-sequence-learning-with-neural-networks.html</id><summary type="html">&lt;p&gt;A survey of sequence-to-sequence learning with deep neural networks.&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://boute.s3.amazonaws.com/290-IUST_logo_color.png"&gt;&lt;b&gt;دانشـکده مهندسی کامپیوتر&lt;/b&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;h1 align = "center"&gt;یـادگیری توالی‌به‌توالی با شبکه‌های عصبی&lt;/h1&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h4 align="center"&gt;
&lt;b&gt; مرتــضی ذاکـری (M - Z A K E R I [ A T ] L I V E [ D O T ] C O M)
&lt;/b&gt;
&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.dropbox.com/s/gii9b6ncz28xfbn/nmt_lstm_sequence2sequence.zip?dl=0"&gt;پیاده‌سازی + مجموعه داده - فایل ZIP (حجم 18.50MB)&lt;/a&gt; &lt;em&gt;بهمن 1396&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.dropbox.com/s/3gris6459iw5tfp/Zakeri_NLP961_project_p3_final.pdf?dl=0"&gt;فاز سوم (نهایی) - نسخه PDF (حجم 1.80MB)&lt;/a&gt; &lt;em&gt;بهمن 1396&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;ارایـه (&lt;a href="https://www.dropbox.com/s/x8i9nwo8n1l3tlk/Zakeri_NLP961_project_p3_presentation.pdf?dl=0"&gt;اسلاید (حجم 1.92MB)&lt;/a&gt;  |  &lt;a href="https://www.dropbox.com/s/43xs7e0kmnil5ku/Zakeri_NLP961_project_p3_talk.mp4?dl=0"&gt;ویدئـو (حجم 53.50MB)&lt;/a&gt;) &lt;em&gt;دی‌ 1396&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.dropbox.com/s/mtngihanlci090r/Zakeri_NLP961_project_p2_rc02.pdf?dl=0"&gt;فاز دوم - نسخه PDF (حجم 1.75MB)&lt;/a&gt; &lt;em&gt;آذر 1396&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.dropbox.com/s/b3n2nfc1hgmvkhh/Zakeri_NLP961_project_p1_rc01.pdf?dl=0"&gt;فاز اول - نسخه PDF (حجم 1.23MB)&lt;/a&gt; &lt;em&gt;آبان‌ 1396&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.dropbox.com/s/xd5y5zxrvm9f67d/Zakeri_NLP961_project_figs.zip?dl=0"&gt; تصاویر - فایل ZIP (حجم 2.22MB)&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.dropbox.com/s/ikyd12fytka91f3/2014_sequence-to-sequence-learning-with-neural-networks.pdf?dl=0"&gt;مرجع اصلی (حجم 165KB)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;تاریخ آخرین بروزرسانی: 19 - 11 -  1396&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;&lt;h2&gt;چکیده&lt;/h2&gt;&lt;/strong&gt;یادگیری ژرف شاخه‌ای نسبتا جدید از یادگیری ماشین است که در آن توابع محاسباتی به‌شکل گراف‌های چند سطحی یا ژرف برای شناسایی و تخمین قانون حاکم بر حل یک مسئله پیچیده به‌کار بسته می‌شوند. شبکه‌های عصبی ژرف ابزاری برای طراحی و پیاده‌سازی این مدل یادگیری هستند. این شبکه‌ها در بسیاری از وظایف یادگیری ماشینی سخت، موفق ظاهر شده‌اند. به‌منظور استفاده از شبکه‌های ژرف در وظایفی که ترتیب ورودی داده‌ در انجام آن مؤثر است مانند اکثر وظایف حوزه پردازش زبان طبیعی، شبکه‌های عصبی مکرر ابداع گشتند که بازنمایی مناسبی از مدل‌های زبانی ارایه می‌دهند. این مدل‌ها در حالت ساده برای همه وظیفه‌های یک مدل زبانی مناسب نیستند. در این گزارش مدل خاصی از شبکه‌های مکرر تحت عنوان مدل توالی‌به‌توالی یا کدگذار-گدگشا بررسی می‌شود که برای وظایفی که شامل توالی‌های ورودی و خروجی با طول متفاوت هستند؛ نظیر ترجمه ماشینی، توسعه داده شده و توانسته است نتایج قابل قبولی را در این زمینه تولید کند.
&lt;strong&gt;کلیدواژه‌ها:&lt;/strong&gt; مدل توالی‌به‌توالی، شبکه عصبی مکرر، یادگیری ژرف، ترجمه ماشینی.&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h1&gt;&lt;strong&gt;مقدمه&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;مدل‌ها و روش‌های یادگیری به‌کمک شبکه‌های عصبی ژرف (DNNs)&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1"&gt;1&lt;/a&gt;&lt;/sup&gt; اخیرا، با افزایش قدرت محاسباتی سخت‌افزارها و نیز حل برخی از چالش‌های اساسی موجود بر سر راه آموزش و یادگیری این شبکه‌ها، بسیار مورد توجه واقع شده‌اند. DNNها در انجام وظایف سخت یادگیری ماشین مانند تشخیص گفتار، تشخیص اشیاء و غیره، فوق‌العاده قدرت‌مند ظاهر شده‌اند و در مواردی روش‌های سنتی را کاملاً کنار زده‌اند. قدرت بازنمایی زیاد DNNها به این دلیل است که قادر هستند محاسبات زیادی را به صورت موازی در چندین لایه انجام داده، با تعداد زیادی پارامتر پاسخ مسئله داده شده را تخمین زده و مدل مناسبی از آن ارایه دهند. درحال حاضر DNNهای بزرگ می‌توانند با استفاده از الگوریتم پس‌انتشار&lt;sup id="fnref:2"&gt;&lt;a class="footnote-ref" href="#fn:2"&gt;2&lt;/a&gt;&lt;/sup&gt; به‌صورت بانظارت&lt;sup id="fnref:3"&gt;&lt;a class="footnote-ref" href="#fn:3"&gt;3&lt;/a&gt;&lt;/sup&gt; روی یک مجموعه آموزش برچسب‌زده و به‌قدر کافی بزرگ آموزش ببینند. بنابراین در مواردی که ضابطه حاکم بر یک مسئله دارای پارامترهای بسیار زیادی است و یک مقدار بهینه از این پارامترها وجود دارد (صرفا با استناد به این که مغز انسان همین مسئله را خیلی سریع حل می‌کند)، روش یادگیری پس‌انتشار این تنظیم از پارامترها (مقدارهای بهینه) را یافته و مسئله را حل می‌کند [1].
 بسیاری از وظایف یادگیری ماشین به حوزه پردازش زبان طبیعی (NLP)&lt;sup id="fnref:4"&gt;&lt;a class="footnote-ref" href="#fn:4"&gt;4&lt;/a&gt;&lt;/sup&gt; مربوط می‌شوند؛ جایی که در آن معمولا ترتیب ورودی‌ها و خروجی‌های یک مسئله مهم است. برای مثال در ترجمه ماشینی دو جمله با واژه‌های یکسان ولی ترتیب متفاوت، معانی (خروجی‌های) مختلفی دارند. این وظایف اصطلاحا مبتنی بر توالی&lt;sup id="fnref:5"&gt;&lt;a class="footnote-ref" href="#fn:5"&gt;5&lt;/a&gt;&lt;/sup&gt; هستند. در واقع ورودی آنها به صورت یک توالی است. شبکه‌های عصبی رو به جلو ژرف&lt;sup id="fnref:6"&gt;&lt;a class="footnote-ref" href="#fn:6"&gt;6&lt;/a&gt;&lt;/sup&gt;  برای این دسته از وظایف خوب عمل نمی‌کنند؛ چرا که قابلیتی برای به‌خاطر سپاری و مدل‌سازی ترتیب در آنها تعبیه نشده است.شبکه‌های عصبی مکرر (RNNs)&lt;sup id="fnref:7"&gt;&lt;a class="footnote-ref" href="#fn:7"&gt;7&lt;/a&gt;&lt;/sup&gt; خانواده‌ای از شبکه‌های عصبی برای پردازش وظایف مبتنی بر توالی هستند. همانطور که شبکه‌های عصبی پیچشی (CNNs)&lt;sup id="fnref:8"&gt;&lt;a class="footnote-ref" href="#fn:8"&gt;8&lt;/a&gt;&lt;/sup&gt;، ویژه پردازش یک تور&lt;sup id="fnref:9"&gt;&lt;a class="footnote-ref" href="#fn:9"&gt;9&lt;/a&gt;&lt;/sup&gt; از مقادیر، برای مثال یک تصویر، طراحی شده‌اند؛ یک RNN نیز همسو با پردازش یک توالی از مقادیر ورودی $$  x\quad =\quad &amp;lt;{ x }^{ (1) },\quad { x }^{ (2) },\quad ...,\quad { x }^{ (n) }&amp;gt; $$ساخته شده است [2]. خروجی RNNها نیز مانند ورودی آنها در اغلب وظایف یک توالی است. این قابلیت پردازش توالی توسط شبکه‌های عصبی، آنها را برای استفاده در وظایف NLP، بسیار درخور ساخته است.&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;شرح مسئله و اهمیت موضوع&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;برخلاف انعطاف پذیری و قدرت بالای RNNها، در حالت ساده این شبکه‌ها یک توالی ورودی با طول ثابت را به یک توالی خروجی با همان طول نگاشت می‌کنند. این موضوع اما یک محدودیت جدی است؛ زیرا، بسیاری از مسائل مهم، در قالب توالی‌هایی که طولشان از قبل مشخص نیست، به‌ بهترین شکل قابل بیان هستند و در نظر گرفتن یک طول ثابت از پیش تعیین شده برای ورودی و خروجی به خوبی مسئله را مدل نمی‌کند. برای مثال ترجمه ماشینی (MT)&lt;sup id="fnref:10"&gt;&lt;a class="footnote-ref" href="#fn:10"&gt;10&lt;/a&gt;&lt;/sup&gt; و تشخیص گفتار&lt;sup id="fnref:11"&gt;&lt;a class="footnote-ref" href="#fn:11"&gt;11&lt;/a&gt;&lt;/sup&gt; مسائلی از این دست هستند. همچنین سیستم پرسش و پاسخ را نیز می‌توان به صورت نگاشت یک توالی از واژه‌ها به‌عنوان پرسش، به یک توالی دیگر از واژه‌ها به عنوان پاسخ، در نظر گرفت. بنابراین پُر واضح است که ایجاد یک روش مستقل از دامنه برای یادگـیری نگاشت توالی‌به‌تولی مفید و قابل توجیه خواهد بود [1].&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;اهداف و راهکارها&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;همانطور که دیدیم طیف وسیعی از وظایف NLP مبتنی بر نگاشت توالی‌های با طول نامشخص و متغیر به یکدیگر است. همچنین روش‌های سنتی مثل n-garm دارای محدودیت‌های خاص خود در حل این دسته مسائل هستند و استفاده از روش‌های یادگیری ژرف به وضوح امید بخش بوده است. بنابراین هدف ارایه یک مدل مبتنی بر RNNها جهت نگاشت توالی‌به‌توالی است. در این گـزارش راهکار مطرح شده در [1] و نتایج آن به‌تفصیل شرح داده می‌شود.
     Stuskever و همکاران [1] نشان دادند که چگونه یک کاربرد ساده از شبکه با معماری حافظه کوتاه‌مدت بلند (LSTM)&lt;sup id="fnref:12"&gt;&lt;a class="footnote-ref" href="#fn:12"&gt;12&lt;/a&gt;&lt;/sup&gt; می‌تواند مسائل نگاشت توالی‌به‌توالی را حل کند. ایده اصلی استفاده از یک LSTM برای خواندن توالی ورودی، به‌صورت یک نمونه در هر مرحله زمانی، جهت اقتباس برداری بزرگ با بعد ثابت و سپس استفاده از یک LSTM دیگر برای استخراج توالی خروجی از آن بردار است. LSTM دوم دقیقا یک مدل زبانی مبتنی بر RNN است با این تفاوت که حاوی احتمال شرطی نسبت به توالی ورودی نیز هست. قابلیت LSTM در یادگیری موفق وابستگی‌های مکانی طولانی مدت نهفته درون توالی‌ها، آن را برای استفاده در مدل پیشنهادی مناسب ساخته است. ‏شکل (1) یک طرح‌واره از این مدل را به صورت عام نشان می‌دهد.
&lt;img alt="شکل (1) یک طرح‌واره از مدل توالی‌به‌توالی متشکل از دو RNN. این مدل توالی ABC را به‌عنوان ورودی خوانده و توالی WXYZ را به‌عنوان خروجی تولید می‌کند. مدل پس از تولید نشانه EOS روند پیش‌بینی خود را متوقف می‌کند [1]. " src="https://boute.s3.amazonaws.com/290-fig1.PNG"&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;داده‌ها و نتایج&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;مدل پیشنهادی در بخش قبل، برروی وظیفه ترجمه ماشینی عصبی (NMT)&lt;sup id="fnref:13"&gt;&lt;a class="footnote-ref" href="#fn:13"&gt;13&lt;/a&gt;&lt;/sup&gt; مورد آزمایش قرار گرفته است. برای انجام آزمایش‌ها از مجموعه داده ترجمه انگلیسی به فرانسوی WMT’14 استفاده شده است [3]. همچنین مجموعه داده کوچکتری در [4] وجود دارد که برای آموزش مدل‌های آزمایشی و غیر واقعی مناسب است. این مجموعه شامل ترجمه‌های انگلیسی به فارسی نیز هست.
 نتایج حاصل شده از این کار بدین قرار است. بر روی مجموعه داده WMT’14 با استخراج مستقیم ترجمه از پنج LSTM ژرف با 380 میلیون پارامتر، در نهایت امتیاز BLEU معادل 34.81 کسب گردیده است. این امتیاز بالاترین امتیازی است که تا زمان ارایه این مقاله از طریق NMT حاصل شده است. به‌عنوان مقایسه امتیاز BLEU برای ترجمه ماشینی آماری (SMT)&lt;sup id="fnref:14"&gt;&lt;a class="footnote-ref" href="#fn:14"&gt;14&lt;/a&gt;&lt;/sup&gt; برروی همین مجموعه داده برابر 33.30 است. این درحالی است که امتیاز 34.81 با احتساب اندازه واژه‌نامه 80هزار کلمه به‌دست آمده و هرجا که کلمه ظاهر شده در ترجمه مرجع در واژه‌نامه نبوده این امتیاز جریمه شده است. بنابراین نتایج نشان می‌دهد که یک معماری مبتنی بر شبکه عصبی تقریبا غیر بهینه، که نقاط زیادی برای بهبود دارد، قادر است تا روش‌های سنتی مبتنی بر عبارتِ سیستم SMT را شکست دهد [1].&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h1&gt;&lt;strong&gt;مفاهیم اولیه&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;در این قسمت پیرامون سه مفهوم اصلی گزارش پیشرو، یعنی مدل زبانی (LM)&lt;sup id="fnref:15"&gt;&lt;a class="footnote-ref" href="#fn:15"&gt;15&lt;/a&gt;&lt;/sup&gt;، شبکه‌های عصبی مکرر و ترجمه ماشینی عصبی، به‌صورت مختصر توضیحاتی ارایه می‌گردد. &lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;مدل زبانی&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;مدل زبانی یک مفهوم پایه در NLP است که امکان پیش‌بینی نشانه بعدی در یک توالی را فراهم می‌کند. به‌بیان دقیق‌تر LM عبارت است از یک توزیع احتمالی روی یک توالی از نشانه‌ها (اغلب واژه‌ها) که احتمال وقوع یک توالی داده شده را مشخص می‌کند. در نتیجه می‌توان بین چندین توالی داده شده برای مثال چند جمله، آن را که محتمل‌تر است، انتخاب کرد [5]. LM برای توالی
$$  x\quad =\quad &amp;lt;{ x }^{ (1) },\quad { x }^{ (2) },\quad ...,\quad { x }^{ (n) }&amp;gt; $$
عبارت است از:
&lt;img alt="Equation 1" src="https://boute.s3.amazonaws.com/290-rel1.PNG"&gt;
مدل‌های سنتی n-gram برای غلبه بر چالش‌های محاسباتی، با استفاده از فرض مارکوف رابطه ‏(1) را به درنظر گرفتن تنها n-1 نشانه قبلی محدود می‌کنند. به‌همین دلیل برای توالی‌های طولانی (بیشتر از 4 یا 5 نشانه) و دیده نشده مناسب نیستند. مدل‌های زبانی عصبی (NLMs)&lt;sup id="fnref:16"&gt;&lt;a class="footnote-ref" href="#fn:16"&gt;16&lt;/a&gt;&lt;/sup&gt; که بر مبنای شبکه‌های عصبی عمل پیش‌بینی واژه بعدی را انجام می‌دهند، در ابتدا برای کمک به n-gramها با آنها ترکیب شدند که منجر به ایجاد پیچیدگی‌های زیادی شد؛ در حالی که مشکل توالی‌های طولانی همچنان وجود داشت [5]. اخیرا اما، معماری‌های جدیدی برای LM که کاملا بر اساس DNNها است، ایجاد شده‌اند. سنگ‌بنای این مجموعه معماری‌ها RNNها بوده که در بخش بعدی معرفی می‌شوند.&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;شبکه‌های عصبی مکرر&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;شبکه‌های عصبی مکرر کلاسی از شبکه‌‌های عصبی هستند که به‌صورت یک &lt;strong&gt;&lt;em&gt;گراف جهت‌دار دوری&lt;/em&gt;&lt;/strong&gt; بیان می‌شوند. به‌عبارت دیگر ورودی هریک از لایه(های) پنهان یا خروجی علاوه بر خروجی لایه قبل، شامل ورودی از مرحله قبل به‌صورت بازخورد نیز می‌شود. شکل (2) یک RNN را نشان می‌دهد. همانطور که پیداست، لایه پنهان از مراحل قبلی هم بازخورد می‌گیرد. در هر مرحله‌زمانی t از (t=1  تا t=n) یک بردار x&lt;sup&gt;(t)&lt;/sup&gt; از توالی ورودی 
$$  x\quad =\quad &amp;lt;{ x }^{ (1) },\quad { x }^{ (2) },\quad ...,\quad { x }^{ (n) }&amp;gt; $$
 پردازش می‌شود. در حالت کلی معادله‌های بروزرسانی (گذرجلو&lt;sup id="fnref:17"&gt;&lt;a class="footnote-ref" href="#fn:17"&gt;17&lt;/a&gt;&lt;/sup&gt;) یک RNN در t عبارتند از [2]:
 &lt;img alt="Equation 2" src="https://boute.s3.amazonaws.com/290-rel2_5.PNG"&gt;
 که در آن بردارهای b و c بایاس و ماتریس‌‌های &lt;em&gt;U&lt;/em&gt;، &lt;em&gt;V&lt;/em&gt; و &lt;em&gt;W&lt;/em&gt; به‌ترتیب وزن یال‌‌های لایه ورودی به پنهان، پنهان به خروجی و پنهان به پنهان، تشکیل‌دهنده مجموعه پارامترهای شبکه هستند. &amp;Phi; تابع انگیزش است که معمولا یکی از توابع ReLU&lt;sup id="fnref:18"&gt;&lt;a class="footnote-ref" href="#fn:18"&gt;18&lt;/a&gt;&lt;/sup&gt; یا سیگموید&lt;sup id="fnref:19"&gt;&lt;a class="footnote-ref" href="#fn:19"&gt;19&lt;/a&gt;&lt;/sup&gt; انتخاب می‌شود. لایه آخر را نیز تابع بیشینه هموار&lt;sup id="fnref:20"&gt;&lt;a class="footnote-ref" href="#fn:20"&gt;20&lt;/a&gt;&lt;/sup&gt; تشکیل می‌دهد که احتمال وقوع هر نشانه خروجی را مشخص می‌کند.
&lt;img alt="شکل (2) گراف محاسباتی مربوط به یک نوع RNN که یک توالی ورودی از مقادیر x را به یک توالی خروجی از مقادیر o نگاشت می‌کند. فرض شده است که خروجی o احتمالات نرمال نشده است، بنابراین خروجی واقعی شبکه یعنی &amp;ycirc; از اعمال تابع بیشینه هموار روی o حاصل می‌شود. چپ: RNN به‌صورت یال بازگشتی. راست: همان شبکه به‌صورت باز شده در زمان، به‌نحوی که هر گره با یک برچسب زمانی مشخص شده است [2]." src="https://boute.s3.amazonaws.com/290-fig2.PNG"&gt;
در ‏شکل (2)، RNN با یک لایه پنهان نشان داده شده است. اما می‌توان RNNژرف با چندین لایه پنهان نیز داشت. همچنین طول توالی‌‌های ورودی و خروجی می‌تواند بسته به مسئله مورد نظر متفاوت باشد. karpathy  در [6]  RNNها را از منظر طول توالی ورودی و طول توالی خروجی به چند دسته تقسیم‌بندی کرده است. شکل (3) این دسته‌بندی را نشان می‌دهد.
&lt;img alt="شکل (3) طرح واره‌ای از حالت‌‌های مختلف RNN. (الف):شبکه عصبی استاندارد، (ب):شبکه یک به چند، (پ): شبکه چند به یک، (ت)و (ث): شبکه‌های چند به چند [6]." src="https://boute.s3.amazonaws.com/290-fig3.PNG"&gt;
تصویر karpathy از حالت‌های مختلف RNN بعد از انتشار مقاله منتخب در این گزارش  می‌باشد؛ با این حال در بخش 4 خواهیم دید که چگونه می‌توان از ترکیب این طرح‌ها نیز برای ایده معماری توالی‌به‌تولی الهام گرفت.&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;ترجمه ماشینی عصبی&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;به‌طور کلی MT را می توان با یک LM که به جمله زبان مبدأ مشروط شده است، مدل‌سازی کرد. بر همین اساس NMT را می‌توان یک مدل زبانی مکرر در نظر گرفت که مستقیما احتمال شرطی p(y|x) را در ترجمه جمله زبان مبدأ
$$  x\quad =\quad &amp;lt;{ x }^{ (1) },\quad { x }^{ (2) },\quad ...,\quad { x }^{ (n) }&amp;gt; $$به جمله زبان مقصد 
$$  y\quad =\quad &amp;lt;{y }^{ (1) },\quad { y }^{ (2) },\quad ...,\quad { y }^{ (m) }&amp;gt; $$مدل می‌کند. دقت شود که طول جمله مبدأ یعنی n و جمله مقصد یعنی m الزاما برابر نیست. بنابراین در NMT هدف محاسبه این احتمال و سپس استفاده از آن در تولید جمله به زبان مقصد، هر دو به کمک DNNها است [5].&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h1&gt;&lt;strong&gt;کارهای مرتبط&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;کارهای زیادی در زمینه NLMs انجام شده است. در بیشتر این کارها از شبکه‌های عصبی روبه‌جلو یا مکرر استفاده شده و کاربرد آن معمولا در یک وظیفه MT با امتیازدهی مجدد n فهرست بهتر&lt;sup id="fnref:21"&gt;&lt;a class="footnote-ref" href="#fn:21"&gt;21&lt;/a&gt;&lt;/sup&gt;، اعمال شده و نتایج آن معمولا نشان از بهبود امتیازهای قبلی داشته است [1]. 
اخیرا کارهایی در زمینه فشردن اطلاعات زبان مبدأ در NLM انجام شده است. برای نمونه Auli و همکاران [7] NLM را با مدل عنوان&lt;sup id="fnref:22"&gt;&lt;a class="footnote-ref" href="#fn:22"&gt;22&lt;/a&gt;&lt;/sup&gt; جمله ورودی ترکیب کرده‌اند که نتایج بهبود بخشی داشته است. کار انجام شده در مقاله [1] به کار [8] بسیار نزدیک است. در مقاله [8] نویسندگان برای اولین بار توالی ورودی را در یک بردار فشرده کرده و سپس آن را به توالی خروجی تبدیل کردند. البته در این کار، برای تبدیل توالی به بردار، از CNNs استفاده شده که ترتیب واژه‌ها را حفظ نمی‌کند. چُـــو و همکاران [9] یک معماری شبهِ LSTM را برای نگاشت توالی ورودی به بردار و سپس استخراج توالی خروجی و نهایتا ترکیب آن با SMT استفاده کرده‌اند. معماری آنها از دو RNN با عنوان‌های کدگذار و کدگشا تشکیل شده که RNN اول وظیفه تبدیل یک توالی با طول متغیر به یک بردار با طول ثابت را قابل یک سلول زمینه c دارد و RNN دوم وظیفه تولید توالی خروجی را با لحاظ کردن c و نماد شروع جمله مقصد بر عهده دارد. معماری پیشنهادی آنها تحت عنوان کلی  RNNکدگذار-کدگشا در ‏شکل (4) نشان داده شده است. چون آنها از LSTM استفاده نکرده و بیشتر تلاش خود را معطوف به ترکیب این روش با مدل‌های قبلی SMT کرده‌اند، برای توالی‌های ورودی و خروجی طولانی همچنان مشکل عدم حفظ حافظه وجود دارد.
Bahdanau و همکاران [10] یک روش ترجمه مستقیم با استفاده از شبکه عصبی پیشنهاد داده‌اند که از سازوکار &lt;em&gt;attention&lt;/em&gt; برای غلبه بر کارآمدی ضعیف روش [9] روی جملات طولانی استفاده می‌کند و به نتایج مطلوبی دست یافتند. &lt;/p&gt;
&lt;p&gt;&lt;img alt="شکل (4) مدل RNN کدگذار-کدگشا، که برای یادگـیری تولید توالی خروجی  y  از روی توالی ورودی x  با استخراج سلول حافظه c از توالی ورودی، به‌کار می‌رود [2]." src="https://boute.s3.amazonaws.com/290-fig4.PNG"&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h1&gt;&lt;strong&gt;مدل توالی‌به‌توالی&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;در مدل توالی‌به‌توالی از دو RNN با واحدهای LSTM استفاده شده است. هدف LSTM در اینجا تخمین احتمال شرطی
$$ p(&amp;lt;{ y }^{ (1) },\quad ...,\quad { y }^{ (m) }&amp;gt;\quad |\quad &amp;lt;{ x }^{ (1) },\quad ...,\quad { x }^{ (n) }&amp;gt;) $$ 
است که قبلا هم دیده بودیم (بخش 2-3). LSTM این احتمال شرطی را ابتدا با اقتباس بازنمایی بعد ثابت v برای توالی ورودی
$$ &amp;lt;{ x }^{ (1) },\quad ...,\quad { x }^{ (n) }&amp;gt; $$
از آخرین مقدار حالت پنهان و در ادامه با محاسبه احتمال 
$$&amp;lt;{ y }^{ (1) },\quad ...,\quad { y }^{ (m) }&amp;gt; $$ 
از رابطه استاندارد مطرح در LM (رابطه (1)) و درنظر گرفتن  برای حالت پنهان آغازین به‌صورت داده شده در رابطه زیر، حساب می‌کند:
&lt;img alt="Equation 6" src="https://boute.s3.amazonaws.com/290-rel6.PNG"&gt;
در رابطه ‏(6) هر توزیع احتمالی 
$$ p({ y }^{ (t) }\quad |\quad v,\quad y^{ (1) },\quad ...,\quad y^{ (t-1) }) $$
به‌وسیله یک تابع بیشینه هموار روی همه واژه‌های داخل واژه‌نامه بازنمایی می‌شود. برای LSTM از روابط [11] استفاده شده است. هر جمله در این مدل نیاز است تا با یک علامت خاص مثل EOS خاتمه یابد. این امر مدل را قادر می‌سازد تا بتواند توزیع احتمالی را روی توالی با هر طول دلخواهی تعریف کند. شمای کلی مدل در شکل (1) نشان داده شده است. در این شکل LSTM بازنمایی توالی ورودی 
$$ &amp;lt;'A','B','C',EOS&amp;gt; $$را حساب و سپس از این بازنمایی برای محاسبه احتمال توالی خروجی&lt;br&gt;
$$ &amp;lt;'W','X','Y','Z',EOS&amp;gt;  $$
استفاده می‌کند. در عین حال این مدل را می‌توان ترکیبی از قسمت‌های پ و ت شکل (3) دانست.
مدل پیاده‌سازی شده در عمل از سه جنبه با مدل معرفی شده در بالا تفاوت دارد. اول، از دو LSTM جداگانه استفاده شده است: یکی برای توالی ورودی و دیگری برای توالی خروجی؛ زیرا، انجام این کار پارامترهای مدل را با هزینه محاسباتی اندکی، به تعداد بسیار زیادی افزایش می‌دهد. دوم اینکه LSTMهای ژرف به‌شکل قابل توجهی LSTMهای سطحی را شکست می‌دهند، به همین دلیل LSTM با ژرفای چهار لایه به‌کار گرفته شده است. سوم اینکه نویسندگان در این مقاله یافته‌اند که وارون کردن توالی ورودی در سرعتِ همگرایی آموزش شبکه و نیز دقت پیش‌بینی آن تأثیر شگرفی ایفا می‌کند. بنابراین به‌جای نگاشت مستقیم توالی  a,b,c  به توالی &amp;alpha;, &amp;beta;, &amp;gamma;  شبکه LSTM برای نگاشت c,b,a به &amp;alpha;, &amp;beta;, &amp;gamma; آموزش داده می‌شود که در آن &amp;alpha;, &amp;beta;, &amp;gamma;  ترجمه یا خروجی متناظر با همان a,b,c است. توجیه علت این پدیده آن است که در نگاشت به شیوه وارون ابتدای عبارت‌ها که متناظر با یکدیگر هستند به‌هم نزدیک شده و این امر سبب زودتر همگرا شدن الگوریتم  کاهش گرادیان تصادفی (SGD) و نزدیک شدن به مقادیر بهینه می‌شود [1].&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;آموزش شبکه&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;مدل توالی‌‌به‌توالی پس از معرفی توسط Sutskever و همکاران [1]، بارها و بارها تا به امروز مورد ارجاع دیگران قرار گرفته و تبدیل به یک مدل مرجع در NMT شده است. این مدل در رساله دکتری آقای لانگ [5] به‌تفصیل و همراه با برخی اصلاحات توضیح داده شده است. در این بخش به برخی جزئیات آموزش شبکه مدل توالی‌به‌توالی می‌پردازیم.
شکل (5) یک نمایش دقیق‌تر از مدل ذکر شده در شکل (1) را نشان می‌دهد. آموزش شبکه بدین نحو است: ابتدا جمله زبان مقصد، سمت راست جمله متناظر خود در زبان مبدأ قرار داده می‌شود. نشان ‘-‘ در اینجا نقش EOS را دارد که البته می‌تواند پایان جمله مبدأ یا آغاز جمله مقصد را مشخص کند. بنابراین به هر کدام از دو گروه قابل تعلق است. LSTM سمت چپ یا همان شبکه کدگذار، در هر مرحله‌زمانی یک واژه از جمله زبان مبدأ را خوانده پس از تبدیل به نمایش مناسب حالت داخلی لایه پنهان را بروزرسانی می‌کند. در مرحله پردازش آخرین واژه مقادیر لایه‌های پنهان بردار ثابت که اکنون نماینده کل جمله ورودی زبان مبدأ است را تشکیل می‌دهد. سپس LSTM دوم یا شبکه کدگشا اولین واژه زبان مقصد را به همراه بردار v، به‌عنوان ورودی دریافت می‌کند و پیشبینی خود را انجام می‌دهد. برچسب واقعی این داده در واقع واژه بعدی در جمله زبان مقصد است. پس از مقایسه و محاسبه خطا، الگوریتم پس‌انتشار روی هر دو شبکه با شروع از شبکه کدگشا اجرا می‌شود و پارامترها را در خلاف جهت گرادیان تنظیم می‌کند. این روند تا پایان یافتن جمله زبان مقصد ادامه پیدا می‌کند. البته در عمل ممکن است ورودی به صورت یک دسته&lt;sup id="fnref:23"&gt;&lt;a class="footnote-ref" href="#fn:23"&gt;23&lt;/a&gt;&lt;/sup&gt; به شبکه داده شده و گرادیان روی کل آن دسته حساب شود. به بیان دیگر در مجموع، شبکه کدگشا آموزش داده می‌شود تا جمله زبان مقصد را به همان جمله زبان مقصدی تبدیل کند که فقط واژه‌های آن یک واحد نسبت به جمله ورودی به سمت جلو جابه‌جا شده‌اند. این روش اصطلاحا teacher forcing نامیده می‌شود [2] و زمانی مناسب است که جمله زبان مقصد (توالی خروجی) کاملا مشخص باشد. در واقع واژه بعدی به عنوان برچسب در فرایند آموزش بانظارت مورد استفاده قرار می‌گیرد و وزن‌ها بر اساس آن تنظیم می‌گردند.
&lt;img alt="شکل (5) نمایش نحوه عملکرد و آموزش مدل‌ توالی‌‌به‌توالی روی وظیفه ترجمه ماشینی عصبی  [5]." src="https://boute.s3.amazonaws.com/290-fig5wc.PNG"&gt;&lt;/p&gt;
&lt;p&gt;در مرحله استنتاج&lt;sup id="fnref:27"&gt;&lt;a class="footnote-ref" href="#fn:27"&gt;27&lt;/a&gt;&lt;/sup&gt; یعنی هنگامی که می‌خواهیم جمله ناشناخته زبان مقصد (توالی خروجی) را کدگشایی نماییم، فرایند شرح داده شده در بالا، با اندکی تفاوت و در قالب گام‌های زیر انجام می‌پذیرد:
1. توالی ورودی با استفاده از شبکه کدگذار به بردار محتوا بدل می‌گردد. در صورتی که از سلول LSTM استفاده شود بردار محتوا برای هر لایه از شبکه حاوی دو متغیر حالت خواهد بود و در صورت استفاده از سلول GRU بردار محتوا برای هر لایه از شبکه دارای یک متغیر است.
2.  یک توالی با اندازه ورودی 1 که ابتدا حاوی نشانه شروع جمله زبان مقصد است در ورودی شبکه کدگشا قرار داده می‌شود.
3.  بردار محتوای حاصل شده از مرحله 1 به همراه توالی مرحله 2 به شبکه کدگشا داده می‌شوند تا نشانه (در اینجا واژه) بعدی جمله زبان مقصد پیش‌بینی شود.
4. از پیش‌بینی مرحله 4 نمونه برداری شده (به یکی از روش‌های حریصانه یا جست‌وجوی پرتوی محلی که در ادامه توضیح داده خواهد شد) و واژه بعدی انتخاب می‌شود.
5. واژه انتخاب شده در مرحله 4 به جمله زبان مقصد (توالی خروجی) الحاق می‌شود.
6. واژه انتخاب شده در مرحله 4 به جای نشانه شروع جمله به شبکه کدگشا داده می‌شود و مراحل 3 و 4 و 6 تکرار می‌شوند تا زمانی که نشانه پایان جمله تولید شود یا اینکه طول جمله تولید شده از یک حد از پیش تعیین شده بیشتر شود.
نکته لازم به ذکر دیگر آن است که توالی ورودی انتخاب شده در این مرحله از مجوعه آزمون انتخاب می‌شود. در واقع مرحله استنتاج روی داده‌های آزمون و برای ارزیابی مدل انجام می‌پذیرد.&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;جزئیات آموزش شبکه&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;در مقاله [1] از LSTMژرف با چهار لایه و 1000 سلول حافظه در هر لایه استفاده شده است. همچنین اندازه واژگان ورودی 160هزار و اندازه واژگان خروجی 80هزار کلمه است. حاصل کار یک شبکه LSTM با مجموع 380میلیون پارامتر بوده که 64میلیون آن اتصالات برگشتی هستند. دیگر جزئیات پارامترها و آموزش شبکه عبارتند از:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;پارامترها با مقادیر تصادفی از توزیع یکنواخت در بازه [0.08+ و 0.08-] مقداردهی اولیه شده‌اند.&lt;/li&gt;
&lt;li&gt;برای آموزش از SGD استاندارد با نرخ یادگیری 0.7 استفاده شده است. بعد از گذشت پنج دوره&lt;sup id="fnref:24"&gt;&lt;a class="footnote-ref" href="#fn:24"&gt;24&lt;/a&gt;&lt;/sup&gt;، نرخ یادگیری در هر نیم‌دور، نصف می‌شود. در ضمن تعداد کل دوره‌های آموزش برابر 7.5 بوده است.&lt;/li&gt;
&lt;li&gt;گرادیان بر روی دسته‌های 128تایی از توالی‌ها محاسبه شده و به اندازه دسته، یعنی 128، تقسیم می‌شود.&lt;/li&gt;
&lt;li&gt;هرچند LSTMها از معضل میرایی گرادیان&lt;sup id="fnref:25"&gt;&lt;a class="footnote-ref" href="#fn:25"&gt;25&lt;/a&gt;&lt;/sup&gt; رنج نمی‌برند، اما ممکن است مشکل انفجار گرادیان&lt;sup id="fnref:26"&gt;&lt;a class="footnote-ref" href="#fn:26"&gt;26&lt;/a&gt;&lt;/sup&gt; را داشته باشند. بنابراین محدودیت سختی بر مقدار نورم گرادیان اعمال می‌شود به‌این نحو که هنگامی که نورم از مقدار آستانه‌ای بیشتر شد، مجددا تنظیم شود. برای هر دسته در مجموعه آموزش مقدار 
$$ s={ ||g|| }_{ 2 }$$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;محاسبه می‌شود که در آن g مقدار گرادیان پس از تقسیم بر 128 است. اگر  s&amp;gt;5 شد آنگاه قرار داده می‌شود:
$$ g=\frac { 5g }{ s }. $$ 
+ جملات مختلف طول‌های مختلفی دارند. بیشتر آنها کوتاه هستند (طولی بین 20 تا 30 دارند) اما برخی از آنها طولانی هستند (طولی بیشتر از 100 دارند)؛ بنابراین دسته‌های 128تایی از جملات که تصادفی انتخاب می‌شوند تعداد کمی جمله طولانی داشته و تعداد زیادی جمله کوتاه و در نتیجه سبب می‌شود تا بیشتر محاسبات داخل هر دسته هدر روند. برای غلبه بر این موضوع سعی شده است همه جملات داخل یک دسته طول تقریبا مساوی داشته باشند. این امر انجام محاسبات را تا 2 برابر تسریع کرده ‌است.&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h1&gt;&lt;strong&gt;آزمایش‌ها&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;روش یادگیری توالی‌به‌توالی معرفی شده روی وظیفه ترجمه ماشینی انگلیسی به فرانسوی در دو حالت مختلف آزمایش گردیده است. در حالت اول مدل، برای ترجمه مستقیم جملات انگلیسی به فرانسوی به‌کار گرفته شده و در حالت دوم برای امتیاز دهی مجدد n فهرست بهتر از جملات در وظیفه SMT استفاده شده است. در این قسمت نتایج آزمایش‌های انجام گرفته در قالب امتیازهای ترجمه کسب شده، نمونه جملات ترجمه شده و بلاخره مصورسازی بازنمایی جملات ورودی، بیان شده است.&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;پیاده‌سازی&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;پیاده‌سازی مدل اولیه با زبان ++C انجام شده است. این پیاده‌سازی از LSTM ژرف با پیکربندی شرح داده شده در بخش 4-1-2 روی یک GPU، تقریبا 1700 واژه بر ثانیه را پردازش می‌کند. این سرعت برای پردازش حجم داده  زیادی مثل مجموعه WMT بسیار پایین است. برای این منظور مدل به صورت موازی شده روی 8 عدد GPU اجرا می‌گردد. هر لایه از LSTM روی یک GPU اجرا شده و فعالیت‌های خود را به محض محاسبه به GPU یا لایه بعدی می‌دهد. چون مدل چهار لایه دارد، چهار GPU دیگر برای موازی‌سازی بیشینه هموار استفاده شده‌اند بنابراین هر GPU مسئول محاسبه یک ضرب ماتریسی (ماتریس با اندازه 2000 × 1000) است. نتیجه حاصل از این موازی‌سازی در سطح GPU، رسیدن به سرعت پردازش 6300 واژه بر ثانیه است. فرایند آموزش در این شیوه پیاده‌سازی، 10 روز به طول انجامید [1].
علاوه بر پیاده‌سازی اولیه، پیاده‌سازی‌های دیگری نیز از این مدل در زبان‌ها و چهارچوب‌های مختلف ارایه شده است؛ از جمله دو پیاده‌سازی خوب با زبان پایتون و روی چهارچوب‌های کاری Tensorflow و Keras. پیاده‌سازی Tensorflow سازوکارهای جدیدتر مثل سازوکار &lt;em&gt;attention&lt;/em&gt; را نیز اضافه کرده است [12]. پیاده‌سازی Keras هم به جای واژه، در &lt;strong&gt;سطح کاراکتر&lt;/strong&gt; انجام شده است [13]. اگرچه در همه پیاده‌سازی‌ها  ترجمه ماشینی، به‌عنوان وظیفه انتخاب شده است. اما این مدل عام بود و برای هر وظیفه‌ای که شامل نگاشت یک توالی ورودی به یک توالی خروجی با طول‌های متفاوت است، قابل اعمال خواهد بود.&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;جزئیات مجموعه داده&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;همانطور که قبلا گفته شد (بخش ‏3-1) از مجموعه داده ترجمه انگلیسی به فرانسوی WMT’14 در آزمایش‌ها استفاده شده است [3]. مدل توصیف شده روی یک زیرمجموعه 12میلیون جمله‌ای، شامل 348میلیون واژه فرانسوی و 340میلیون واژه انگلیسی، آموزش داده شده است. وظیفه ترجمه ماشینی و همچنین این مجموعه داده خاص، به خاطر دردسترس بودن عمومی یک مجموعه آموزش و یک مجموعه آزمون نشانه‌گذاری شده&lt;sup id="fnref:29"&gt;&lt;a class="footnote-ref" href="#fn:29"&gt;28&lt;/a&gt;&lt;/sup&gt; جهت اهداف آموزش و ارزیابی مدل انتخاب شده است و مدل توالی‌به‌تولی مستقل از یک وظیفه خاص است.
همچنان‌که مدل‌های زبانی عصبی معمولی روی یک بازنمایی برداری در نمایش هر کلمه تکیه می‌کنند، در اینجا نیز یک واژه‌نامه با اندازه ثابت، برای هر دو زبان به‌کار گرفته شده است. برای این منظور، 160هزار واژه از پر استفاده‌ترین واژه‌های زبان مبدأ (انگلیسی) و نیز 80هزار واژه از پر استفاده‌ترین واژه‌های زبان مقصد (فرانسوی) برگزیده شده‌اند. هر واژه خارج از این واژه‌نامه‌ها که در جمله‌ها ظاهر شده باشد، با نشانه خاص “UNK” جایگزین شده است.
برای پیاده‌سازی [12] از مجموعه داده ترجمه آلمانی-انگلیسی WMT’16 [14] استفاده شده است و همچنین مدل نمونه پیاده‌سازی شده در [13] از مجموعه داده کوچکتر موجود در [4] استفاده کرده است که قابل جایگزین کردن با مجموعه‌های ذکر شده در بالا نیز هست. ایراد اساسی پیاده‌سازی در سطح کاراکتر [13] این است که معمولا در ترجمه ماشینی واژه‌ها به یکدیگر متناظر می‌شوند نه کاراکترها لذا این مدل از دقت مدل‌های در سطح واژه برخوردار نیست اما ایده خوبی در مورد استفاده در سایر وظایف مبتنی بر نگاشت توالی‌به‌توالی نظیر تولید متن به دست می‌دهد.&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;کدگشایی و امتیازدهی مجدد&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;هسته اصلی آزمایش‌های انجام شده در [1]، آموزش یک LSTM ژرف بزرگ روی تعداد زیادی جفت از جمله‌های زبان مبدأ و زبان مقصد است. آموزش با بیشینه کردن احتمال لگاریتمی یک ترجمه صحیح T برای جمله مبدأ داده شده S انجام می‌شود. بنابراین هدف آموزش عبارت است از:
&lt;img alt="Equation 7" src="https://boute.s3.amazonaws.com/290-rel7.PNG"&gt;
که در آن &lt;strong&gt;S&lt;/strong&gt; مجموعه آموزش است. وقتی آموزش کامل شد، ترجمه‌ها با یافتن درست‌ترین ترجمه از روی LSTM تولید می‌شوند:
&lt;img alt="Equation 8" src="https://boute.s3.amazonaws.com/290-rel8.PNG"&gt;
برای یافتن درست‌ترین ترجمه از یک کدگشای ساده با جست‌وجوی پرتوی محلی&lt;sup id="fnref:30"&gt;&lt;a class="footnote-ref" href="#fn:30"&gt;29&lt;/a&gt;&lt;/sup&gt; چپ به راست استفاده شده است که تعداد B فرضیه جزئی&lt;sup id="fnref:31"&gt;&lt;a class="footnote-ref" href="#fn:31"&gt;30&lt;/a&gt;&lt;/sup&gt; را نگه‌داری می‌کند. هر فرضیه جزئی پیشوندی از تعدادی ترجمه است. در هر مرحله زمانی، هر فرضیه جزئی با واژه‌های محتمل از داخل واژه‌نامه گسترش داده می‌شود. این روند تعداد فرایض جزئی را به‌سرعت افزایش می‌دهد. با توجه به مدل احتمال لگاریتمی، تمام این فرضیه‌ها به غیر از B فرضیه محتمل اول کنار گذاشته می‌شوند. به‌مجرد اینکه نشانه “EOS” به یک فرضیه الصاق شد، از جست‌وجوی پرتوی محلی حذف و به مجموعه فرایض کامل افزوده می‌گردد. هرچند این روش کدگشایی تقریبی است؛ اما، برای پیاده‌سازی راحت خواهد بود. سیستم پیشنهادی حتی با اندازه پرتوی 1 و نیز اندازه پرتوی 2 بیشترین مزایای این روش جست‌وجو را فراهم می‌آورد. امتیازهای BLEU حاصله از آزمایش‌های انجام شده روی مدل، در جدول (1) ذکر شده‌ است.&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;وارون‌سازی جملات مبدأ&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;درحالی‌که LSTM قابلیت حل مسائل با وابستگی‌های طولانی مدت را دارد، در طول آزمایش‌های انجام شده در [1] پژوهشگران یافته‌اند که وقتی جمله‌های مبدأ وارون شده و به‌عنوان ورودی به  شبکه کدگذار داده می‌شوند، LSTM بهتر آموزش می‌بیند. توجه شود که جملات مقصد وارون نمی‌شوند. با انجام این عمل ساده، مقدار سرگشتگی&lt;sup id="fnref:32"&gt;&lt;a class="footnote-ref" href="#fn:32"&gt;31&lt;/a&gt;&lt;/sup&gt; مدل از 5.8 به 4.7 کاهش یافته‌است و مقدار امتیاز BLEU کسب شده از ترجمه‌های کدگشایی شده مدل نیز از 25.9 به 30.6 افزایش داشته است.
نویسندگان [1] توضیح کاملی برای توجیه اثر این پدیده نداشته‌اند. توجیه اولیه آنها بدین ترتیب است که عمل وارون‌سازی جملات زبان مبدأ باعث معرفی بسیاری از وابستگی‌های کوتاه مدت به مجموعه داده می‌شود. وقتی جمله‌های زبان مبدأ را با جمله‌های زبان مقصد الحاق می‌کنیم، هر واژه در جمله مبدأ از واژه نظیرش در جمله مقصد دور می‌افتد. در نتیجه، مسئله یک دارای یک &lt;em&gt;تأخیر زمانی کمینه&lt;/em&gt;&lt;sup id="fnref:33"&gt;&lt;a class="footnote-ref" href="#fn:33"&gt;32&lt;/a&gt;&lt;/sup&gt; خیلی بزرگ می‌شود [1]. با وارون‌سازی واژه‌ها در جمله مبدأ فاصله میانگین بین واژه‌های نظیر به نظیر در جمله‌ مبدأ با جمله مقصد تغییر نمی‌کند. هرچند تعداد کمی از واژه‌های آغازین جمله مبدأ در این حالت به واژه‌های آغازین جمله مقصد بسیار نزدیک می‌شوند؛ بنابراین تأخیر زمانی کمینه مسئله تا حد زیادی کاهش می‌یابد و الگوریتم پس‌انتشار زمان کمتری را برای استقرار ارتباط میان واژه‌های جمله‌های مبدأ و جمله‌های مقصد سپری خواهد نمود. این امر درنهایت منجربه بهبود قابل توجه کارآمدی کلی مدل می‌گردد.
ایده وارون‌سازی جمله‌های ورودی از این مهم نشئت گرفته است که در ابتدا تصور شده وارون‌سازی فقط به پیش‌بینی با اطمینان‌تر واژه‌های آغازین در زبان مقصد کمک می‌کند و منجربه پیش‌بینی کم اطمینان‌تر واژه‌های پایانی می‌شود. هرچند LSTMای که روی جملات مبدأ وارون شده آموزش دیده، در مقایسه با LSTM معمولی، روی جمله‌های طولانی عملکرد بهتری از خود نشان داده است (رجوع شود به بخش ‏1-6). &lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;ارزیابی نـتایج&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;به‌منظور ارزیابی کیفیت ترجمه‌های صورت گرفته توسط مدل از روش امتیازدهی خودکار BLEU [16] استفاده شده است. برای محاسبه امتیاز BLEU، اسکریپت آماده multi-bleu.pl&lt;sup id="fnref:34"&gt;&lt;a class="footnote-ref" href="#fn:34"&gt;33&lt;/a&gt;&lt;/sup&gt; به‌کار رفته است. این نوع امتیاز دهی در کارهای قبلی مشابه نیز استفاده شده است [9] و [10]، بنابراین قابل اطمینان خواهد بود و مقایسه مدل‌ها را امکان‌پذیر می‌سازد. به‌عنوان نمونه، این اسکریپت برای [10] امتیاز 28.45 را تولید کرده است. نتایج در جدول‌های (1) و (2) ارایه شده‌اند. بهترین نتیجه از مجموعه LSTMهایی که در مقداردهی اولیه تصادفی و ترتیب تصادفی ریزدسته‌ها تفاوت داشته‌اند، حاصل شده است. هرچند سازوکار کدگشایی ترجمه به‌کار برده شده در اینجا (جست‌وجوی پرتوی محلی)، سازوکار ساده و ضعیفی است؛ با این حال نخستین بار است که یک سیستم ترجمه ماشینی عصبی خالص، سیستم ترجمه ماشینی مبتنی بر عبارات را با اختلاف قابل توجهی شکست می‌دهد. این سیستم همچنین فاقد قابلیت کنترل واژه‌های خارج از واژه‌نامه است و همان‌طور که قبلا هم بیان شد کلیه واژه‌های بیرون از واژه‌نامه با واژه “UNK” جایگزین شده‌اند. بنابراین در صورتی که سازوکاری برای کنترل این واژه‌ها نیز به مدل اضافه شود یا اندازه واژه‌نامه افزایش یابد، عملکرد این سیستم باز هم جای بهبود خواهد داشت.&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p align="center"&gt;
جدول (1) کارآمدی LSTM روی مجموعه آزمون ترجمه انگلیسی به فرانسوی WMT’14 (ntst14). توجه شود که یک مجموعه متشکل از پنج LSTM با اندازه پرتوی 2، ارزان‌تر (سبک‌تر) از یک LSTM تنها با اندازه پرتوی 12 است [1].
&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style="text-align: center;"&gt;&lt;strong&gt;روش&lt;/strong&gt;&lt;/th&gt;
&lt;th style="text-align: center;"&gt;&lt;strong&gt;امتیاز BLEU (ntst14)&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;Bahdanau و همکاران [10]&lt;/td&gt;
&lt;td style="text-align: center;"&gt;28.45&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;یک LSTM روبه‌جلو، اندازه پرتوی 12&lt;/td&gt;
&lt;td style="text-align: center;"&gt;26.17&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;یک LSTM با ورودی وارون، اندازه پرتوی 12&lt;/td&gt;
&lt;td style="text-align: center;"&gt;30.59&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;پنج LSTM با ورودی وارون، اندازه پرتوی 1&lt;/td&gt;
&lt;td style="text-align: center;"&gt;33.00&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;دو LSTM با ورودی وارون، اندازه پرتوی 12&lt;/td&gt;
&lt;td style="text-align: center;"&gt;33.27&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;پنج LSTM با ورودی وارون، اندازه پرتوی 21&lt;/td&gt;
&lt;td style="text-align: center;"&gt;34.50&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;پنج LSTM با ورودی وارون، اندازه پرتوی 12&lt;/td&gt;
&lt;td style="text-align: center;"&gt;&lt;strong&gt;34.81&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p align="center"&gt;
جدول (2) روش‌های مشابه که شبکه‌های عصبی را در کنار ترجمه ماشینی سنتی روی مجموعه داده WMT’14 در ترجمه انگلیسی به فرانسوی استفاده کرده‌اند [1].
&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style="text-align: center;"&gt;&lt;strong&gt;روش&lt;/strong&gt;&lt;/th&gt;
&lt;th style="text-align: center;"&gt;&lt;strong&gt;امتیاز BLEU (ntst14)&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;لـبه پژوهش [15]&lt;/td&gt;
&lt;td style="text-align: center;"&gt;&lt;strong&gt;37.00&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;چــو و همکاران [9]&lt;/td&gt;
&lt;td style="text-align: center;"&gt;34.54&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;امتیازدهی مجدد 1000فهرست بهتر با یک LSTM روبه‌جلو&lt;/td&gt;
&lt;td style="text-align: center;"&gt;35.61&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;امتیازدهی مجدد1000فهرست بهتر با یک LSTM وارون&lt;/td&gt;
&lt;td style="text-align: center;"&gt;35.85&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;امتیازدهی مجدد1000فهرست بهتر با پنج LSTM وارون&lt;/td&gt;
&lt;td style="text-align: center;"&gt;&lt;strong&gt;36.50&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;پیش‌گویی امتیازدهی مجدد 1000فهرست بهتر&lt;/td&gt;
&lt;td style="text-align: center;"&gt;45~&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;&lt;strong&gt;تحلیل مدل&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;یکی از ویژگی‌های جذاب مدل توالی‌به‌توالی ارایه شده در [1]، توانایی تبدیل یک توالی از واژه‌ها به یک بردار با ابعاد ثابت است. شکل (6) تعدادی از بازنمایی‌های یادگرفته شده در روند آموزش را مصورسازی کرده است. این تصویر به وضوح نشان می‌دهد که بازنمایی‌های ایجاد شده به ترتیب واژه‌ها حساس هستند؛ زیرا از جمله‌هایی با واژه‌های یکسان و ترتیب متفاوت در تصویر استفاده شده است. بازنمایی واقعی مدل در ابعاد بالاتری بود و برای نگاشت روی دو بعد روش PCA به‌کار برده شده است.&lt;/p&gt;
&lt;p&gt;&lt;img alt="شکل (6) این شکل یک تصویر PCA دوبعدی از حالت‌های پنهان LSTM را نشان می‌دهد که پس از پردازش جمله‌های نشان داده شده در شکل، گرفته شده است. عبارات با توجه به معنایشان خوشه‌بندی شده‌اند که معنا در این مثال به طور عمده تابعی از ترتیب ظاهر شدن واژه‌ها در عبارت است. رسیدن به چنین خوشه‌بندی با روش‌های سنتی موجود، سخت است. توجه شود که در همه جمله‌ها واژه‌های یکسانی استفاده شده و تنها ترتیب ظاهر شدن آنها،  تفاوت ایجاد کرده است [1]. دایره‌های کوچک در شکل اعداد دو بعد تصویر شده جمله را نشان می‌دهند." src="https://boute.s3.amazonaws.com/290-fig6.PNG"&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;کارآمدی روی جملات طولانی&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;خروجی مدل روی جمله‌های طولانی (از منظر تعداد واژه) کارآمدی بسیار خوب LSTM را در این زمینه تأیید می‌کند. یک مقایسه کمی از نتایج حاصل شده در شکل (7) نشان داده شده است. همچنین جدول (3) چندین جمله طولانی و ترجمه‌های تولید شده توسط مدل برای آنها را ارایه می‌کند. 
&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="شکل (7) نمودار سمت چپ کارآمدی سیستم را به‌عنوان تابعی از طول جمله‌ها نشان می‌دهد که محور افقی در آن طول واقعی جمله‌ها بر حسب تعداد واژه‌های آنها است. کاهش امتیازی در جملاتی با طول کمتر از 35 واژه وجود ندارد. تنها یک کاهش جزئی در جمله‌های خیلی طولانی مشاهده می‌شود. نمودار سمت راست کارآمدی LSTM را روی جمله‌هایی با واژه‌های کمتر به‌کار رفته نشان می‌دهد که محور افقی در آن جمله‌های آزمایش شده برحسب میانگین تکرار واژه‌هایشان است [1]." src="https://boute.s3.amazonaws.com/290-fig7.PNG"&gt;&lt;/p&gt;
&lt;p align="center"&gt;جدول (3) سه مثال از ترجمه‌های طولانی تولید شده توسط مدل توالی‌به‌توالی در مقایسه با ترجمه صحیح. خواننده می‌تواند صحت نتایج را با استفاده از مترجم گوگل تا حد خوبی درک کند [1].&lt;/p&gt;

&lt;p&gt;&lt;img alt="Table 3" src="https://boute.s3.amazonaws.com/290-table3.PNG"&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h1&gt;&lt;strong&gt;نتیجه‌گیری و کارهای آتی&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;در این گزارش یک مدل یادگیری ژرف جدید برای یادگیری و نگاشت توالی از ورودی‌ها به توالی از خروجی‌ها مطرح و بحث گردید. نشان داده شد که یک شبکه LSTM ژرف با واژگان محدود روی وظیفه ترجمه ماشینی، قادر به شکست سیستم‌های ترجمه ماشینی استاندارد مبتنی بر عبارات با واژگان نامحدود است. موفقیت این رویکرد نسبتا ساده روی وظیفه ترجمه ماشینی نشان دهنده این است که این مدل باید روی دیگر وظیفه‌های مبتنی بر توالی نیز در صورت فراهم بودن مجموعه داده‌های آموزش کافی، بسیار خوب عمل کند.
در طی فرایند آموزش این اصل نیز کشف شده که وارون سازی توالی مبدأ سبب افزایش دقت و بهبود کارآمدی مدل می‌شود. می‌توان نتیجه گرفت پیدا کردن روشی که وابستگی‌های کوتاه مدت را زودتر معرفی کند در هر صورت آموزش مدل را خیلی ساده‌تر می‌کند. لذا به نظر می‌رسد که حتی آموزش یک RNN استاندارد (مدل غیر توالی‌به‌توالی) نیز با این روش بهتر باشد. البته این مورد در عمل مورد آزمایش قرار نگرفته است و بنابراین به صورت یک فرضیه باقی است.
نتیجه قابل ذکر دیگر، قابلیت LSTM در یادگیری صحیح ترجمه توالی‌های طولانی است. در ابتدا تصور می‌شد که LSTM به دلیل حافظه محدود خود در یادگیری جمله‌های طولانی شکست بخورد؛ همچنان‌که پژوهشگران دیگر در کارهای مشابه عملکرد ضعیفی را برای LSTM گزارش کرده بودند. با این حال اما روی جمله‌های خیلی طولانی در حالت وارون همچنان مشکل تضعیف حافظه پابرجاست و احتمالا قابلیت بهبود داشته باشد.   در نهایت نتایج رضایت بخش این مدل یادگیری نشان دهنده این است که یک مدل ساده از شبکه‌های عصبی ژرف، که هنوز جای بهبود و بهینه‌سازی‌های زیادی در خود دارد، قادر به شکست بالغ‌ترین سیستم‌های ترجمه ماشینی سنتی است. کارهای آتی می‌تواند بر روی افزایش دقت مدل توالی‌به‌توالی و پیچیده‌تر کردن آن در راستای یادگیری بهتر توالی‌های طولانی باشد. در آینده نزدیک این مدل‌ها روش‌های سنتی را کاملا منسوخ می‌کنند. نتایج همچنین نشان می‌دهد این رویکرد روی دیگر وظیفه‌های مبتنی بر نگاشت توالی‌به‌توالی می‌تواند موفقیت آمیز ظاهر شود. این مهم، زمینه را برای حل مسائل مختلفی در دیگر حوزه‌های علوم آماده می‌سازد.
می‌توان از این مدل برای ترجمه ماشینی متون طولانی انگلیسی به فارسی و بالعکس استفاده کرد در این وظیفه اثر وارون‌سازی جمله زبان مبدأ باید بررسی شود؛ زیرا، به نظر می‌رسد در زبان‌های از راست به چپ با این کار تأخیر زمانی کمینه افزایش پیدا ‌کند و نتیجه بدتری حاصل شود.
در وظایف دیگر مثل سیستم پرسش و پاسخ نیز می‌توان از این مدل استفاده کرد. در تولید محتوا و برای کامل کردن متون تاریخی و اشعاری که بخش‌هایی از آنها وجود ندارد یا از بین رفته است استفاده از این مدل جالب و ارزشمند به نظر می‌رسد.
علاوه بر استفاده در وظایف جدید، تغییر معماری خود مدل نیز، جهت افزایش دقت وظایف نام برده پیشنهاد می‌شود. برای مثال استفاده از RNN دوسویه، ترکیبی
و نیز دارای حالت در شبکه کدگذار و کدگشا، استفاده از ژرفای بیشتر لایه‌ها، تغییر دیگر ابرپارامترهای شبکه نظیر نرخ آموزش و افزودن سازوکار توجه می‌تواند از جمله پیشنهادهایی باشد که در ساختن مدل‌های با دقت بیشتر قابل استفاده هستند. همچنین برای مواردی که داده‌های برچسب‌دار به اندازه کافی موجود نیستند یا تمامی توالی خروجی یکجا دردسترس نیست (مثل یادگیری برخط یا یادگیری تقویتی)، استفاده از روش بیان شده در مرحله استنتاج به هنگام آموزش، به جای teacher forcing راهکار مناسبی به نظر می‌رسد. &lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;h2&gt;مراجع&lt;/h2&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;[1]      Q.V. Le Ilya Sutskever, Oriol Vinyals, I. Sutskever, O. Vinyals, and Q. V. Le, “Sequence to sequence learning with neural networks,” &lt;em&gt;Nips&lt;/em&gt;, pp. 1–9, 2014.
[2]      I. Goodfellow, Y. Bengio, and A. Courville, &lt;em&gt;Deep learning&lt;/em&gt;. MIT Press, 2016.
[3]      “ACL 2014 ninth workshop on statistical machine translation.” [Online]. Available: http://www.statmt.org/wmt14/medical-task/index.html. [Accessed: 13-Nov-2017].
[4]      “Tab-delimited bilingual bentence pairsfrom the tatoeba project (good for anki and similar flashcard applications).”[Online]. Available: http://www.manythings.org/anki/. [Accessed: 13-Nov-2017].
[5]      M. T. Luong, “Neural machine translation,” Stanford university, 2016.
[6]      A. Karpathy, “Connecting images and natural language,” Stanford University, 2016.
[7]      M. Auli, M. Galley, C. Quirk, and G. Zweig, “Joint language and translation modeling with recurrent neural networks.,” &lt;em&gt;Emnlp&lt;/em&gt;, no. October, pp. 1044–1054, 2013.
[8]      N. Kalchbrenner and P. Blunsom, “Recurrent continuous translation models,” &lt;em&gt;Emnlp&lt;/em&gt;, no. October, pp. 1700–1709, 2013.
[9]      K. Cho &lt;em&gt;et al.&lt;/em&gt;, “Learning phrase representations using RNN encoder-decoder for statistical machine translation,” 2014.
[10]    D. Bahdanau, K. Cho, and Y. Bengio, “Neural machine translation by jointly learning to align and translate,” pp. 1–15, 2014.
[11]    A. Graves, “Generating sequences with recurrent neural networks,” pp. 1–43, 2013.
[12]    M.-T. Luong, E. Brevdo, and R. Zhao, “Neural machine translation (seq2seq) tutorial,” &lt;em&gt;https://github.com/tensorflow/nmt&lt;/em&gt;, 2017.
[13]    “Sequence to sequence example in Keras (character-level),” 2017. [Online]. Available: https://github.com/fcholle/keras/blob/master/examples/lstm_seq2seq.py. [Accessed: 13-Nov-2017].
[14]    “Index of /wmt16/translation-task.” [Online]. Available: http://data.statmt.org/wmt16/translation-task/.[Accessed: 04-Dec-2017].
[15]    N. Durrani, B. Haddow, P. Koehn, and K. Heafield, “Edinburgh’s phrase-based machine translation systems for WMT-14,” &lt;em&gt;Proc. Ninth Work. Stat. Mach. Transl.&lt;/em&gt;, pp. 97–104, 2014.
[16]    K. Papineni, S. Roukos, T. Ward, and W. Zhu, “BLEU: A method for automatic evaluation of machine translation,” &lt;em&gt;… 40Th Annu. Meet. …&lt;/em&gt;, no. July, pp. 311-318,2002.&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;h2&gt;پیوست الف: پیاده‌سازی مدل توالی‌به‌توالی در keras&lt;/h2&gt;&lt;/strong&gt;
در این قسمت جزئیات کد مدل توالی‌به‌توالی پیاده‌سازی شده در keras و تغییرات آن را شرح می‌دهیم. این کد به همراه مجموعه داده از پیوندهای ابتدای گزارش قابل دریافت است. پیاده‌سازی مدل توالی‌به‌توالی در  اینجا در سطح کاراکتر است یعنی وظیفه ترجمه ماشینی را کاراکتر به کاراکتر انجام می‌دهد. البته برای وظیفه ترجمه ماشینی مدل در سطح واژه مرسوم است. شروع از سطح کاراتر ساده تر بوده و بعدا با اضافه کردن یک لایه embedding می‌توان مدل را به آسانی در سطح واژه آموزش داد.
مجموعه آموزش شامل یک فایل متنی است که در هر سطر آن یک عبارت انگلیسی و سپس ترجمه معادل آن آمده است. دو عبارت در یک سطر با کاراکتر t\ از هم جدا شده‌اند. بنابراین جمله زبان مقصد با کاراکتر t\ شروع و با کاراکتر n\ خاتمه می‌یابد. برای تغییر حالت از کدگذار به کدگشا از نشانه  t\  و برای مشخص کردن پایان جمله زبان مقصد از نشانه n\ استفاده خواهد شد. ابتدا فایل ورودی را سطر به سطر خوانده و  دو  بخش متن ورودی و متن هدف را  را از روی آن می‌سازیم. سپس با روش one-hot  متن ورودی و متن هدف را به بردار عددی معادل تبدیل می‌کنیم. تکه کد زیر اینکار را انجام می‌دهد:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="n"&gt;input_token_index&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;dict&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;(char, i) for i, char in enumerate(input_characters)&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;target_token_index&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;dict&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;(char, i) for i, char in enumerate(target_characters)&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;encoder_input_data&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;zeros&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;input_texts&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;max_encoder_seq_length&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num_encoder_tokens&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;dtype&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;float32&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;decoder_input_data&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;zeros&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;input_texts&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;max_decoder_seq_length&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num_decoder_tokens&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;dtype&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;float32&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;decoder_target_data&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;zeros&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;input_texts&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;max_decoder_seq_length&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num_decoder_tokens&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;dtype&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;float32&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bulid&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;one&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;hot&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;input_text&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;target_text&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;enumerate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;zip&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;input_texts&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;target_texts&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;enumerate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;input_text&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;encoder_input_data&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i, t, input_token_index[char&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="err"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;1.&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;enumerate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;target_text&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;decoder_target_data&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;is&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ahead&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;of&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;decoder_input_data&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;by&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;one&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;timestep&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;decoder_input_data&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i, t, target_token_index[char&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="err"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;1.&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;decoder_target_data&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;will&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;be&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ahead&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;by&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;one&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;timestep&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;and&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;will&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;not&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;the&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;start&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;character&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;decoder_target_data&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i, t - 1, target_token_index[char&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="err"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;1.&lt;/span&gt;
&lt;span class="p"&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;دقت شود که ورودی کدگشا در مرحله آموزش، عبارت زبان مقصد (متن هدف) و خروجی آن نیز همان عبارت زبان مقصد است که یک واحد به جلو شیفت داده شده است (روش موسوم به teacher forcing). کد بالا این کار را نیز انجام می‌دهد یعنی خروجی کدگشا را به همین روش اضافه می‌کند.
حال نوبت به تعریف LSTM کدگذار و LSTM کدگشا می‌رسد. در keras کلاس LSTM کلیه وظایف مربوط به این نوع شبکه را پیاده‌سازی کرده است. کافی است یک نمونه (شیء) از این کلاس ایجاد کنیم. این کلاس همچنین متد &lt;strong&gt;&lt;em&gt;call&lt;/em&gt;&lt;/strong&gt; را داراست که لایه ورودی را به عنوان آرگومان دریافت و به شیء ساخته شده از کلاس متصل می‌کند. LSTM کدگذار بنابراین به‌صورت زیر تعریف می‌شود:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="o"&gt;...&lt;/span&gt;
&lt;span class="nx"&gt;encoder_inputs&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;Input&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;shape&lt;/span&gt;&lt;span class="p"&gt;=(&lt;/span&gt;&lt;span class="nx"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;num_encoder_tokens&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="nx"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;type&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;encoder_inputs&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="nx"&gt;encoder&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;LSTM&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;latent_dim&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;return_state&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="nx"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="nx"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;type&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;encoder&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="nx"&gt;encoder_outputs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;state_h&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;state_c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;encoder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;encoder_inputs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;وقتی از آرگومان return_state=True در ساخت یک شی از کلاس LSTM استفاده می‌شود دو حالت حافظه موجود در LSTM هم به عنوان خروجی، علاوه بر توالی خروجی اصلی بازگردانیده می‌شوند. در کد بالا این دو حالت state_c و state_h نام دارند. خروجی کدگذار در مدل توالی‌به‌توالی استفاده‌ای ندارد و دور انداخته می‌شود.  در عوض از حالت‌های state_c و state_h به عنوان حالت آغازین LSTM کدگشا به صورت زیر استفاده می‌شود:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="n"&gt;encoder_states&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;[&lt;/span&gt;&lt;span class="n"&gt;state_h&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;state_c&lt;/span&gt;&lt;span class="err"&gt;]&lt;/span&gt;
&lt;span class="c1"&gt;# Set up the decoder, using `encoder_states` as initial state.&lt;/span&gt;
&lt;span class="n"&gt;decoder_inputs&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Input&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;shape&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num_decoder_tokens&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="c1"&gt;# We set up our decoder to return full output sequences,&lt;/span&gt;
&lt;span class="c1"&gt;# and to return internal states as well. We don&amp;#39;t use the&lt;/span&gt;
&lt;span class="c1"&gt;# return states in the training model, but we will use them in inference.&lt;/span&gt;
&lt;span class="n"&gt;decoder_lstm&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;LSTM&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;latent_dim&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;return_sequences&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="no"&gt;True&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;return_state&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="no"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;decoder_outputs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;_&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;_&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;decoder_lstm&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;decoder_inputs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;initial_state&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;encoder_states&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;همچنین  یک لایه softmax برروی خروجی توالی‌ نهایی LSTMکدگشا جهت تبدیل خروجی به احتمالات معتبر به شکل زیر قرار می‌دهیم:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;...
decoder_dense = Dense(num_decoder_tokens, activation = &amp;#39;softmax&amp;#39;)
decoder_outputs = decoder_dense(decoder_outputs)
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;اکنون لایه‌های مدل ساخته شده است. این لایه‌ها بایستی به شکل یک گراف به هم متصل شده و تشکیل یک مدل با ورودی و خروجی معین را بدهند. در keras دو نوع  مدل وجود دارد. نوع اول مدل‌های ترتیبی (sequential) هستند که یک پشته خطی از لایه‌ها را در قالب مدل به هم مرتبط می‌کنند. یعنی گراف نهایی مدل ترتیبی حالتی خطی دارد. مدل ترتیبی برای ایجاد مدل‌های پیچیده‌تر مثل مدل توالی‌به‌توالی مناسب نیست. نوع دوم مدل در keras با استفاده از Keras functional API ساخته می‌شوند. این حالت برای ساختن مدل‌هایی با چند ورودی و چند خروجی که گراف آن‌ها لزوما خطی نیست به کار می‌رود. در اینجا از این روش استفاده شده است.  برای این منظور پس از تعیین تک تک لایه‌‌ها (کد قسمت‌های قبلی)، از کلاس Model استفاده کرده و ورودی و خروجی نهایی مدل را تعیین می‌کنیم:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="c1"&gt;# Define the model that will turn&lt;/span&gt;
&lt;span class="c1"&gt;#encoder_input_data` &amp;amp; `decoder_input_data` into `decoder_target_data`&lt;/span&gt;
&lt;span class="n"&gt;model&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Model&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;[&lt;/span&gt;&lt;span class="n"&gt;encoder_inputs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;decoder_inputs&lt;/span&gt;&lt;span class="err"&gt;]&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;decoder_outputs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;با استفاده از تابع plot_model می‌توان به صورت گرافیکی بهم‌بست مدل ایجاد شده را مشاهده کرد: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;...
plot_model(model, to_file = &amp;#39;./modelpic/seq2seq_model_&amp;#39; + dt + &amp;#39;.png&amp;#39;, show_shapes=True, show_layer_names=True)
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;برای استفاده از این تابع لازم است با دستور from keras.utils import plot_model  بسته حاوی تابع plot_model را در ابتدای کد، به  برنامه اضافه کنیم. نتیجه اجرای این تابع به شکل زیر است:
&lt;img alt="شکل (الف - 1) مدل توالی‌به‌توالی ساخته شده در keras و رسم شده توسط تابع plot_model" src="https://boute.s3.amazonaws.com/290-seq2seq_model_20180206_155430.png"&gt;&lt;/p&gt;
&lt;p&gt;در مرحله بعد تابع خطا و روش یادگیری مدل تعیین می‌شود:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;...
model.compile(optimizer=&amp;#39;rmsprop&amp;#39;, loss=&amp;#39;categorical_crossentropy&amp;#39;)
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;و درنهایت مدل را با داده‌های واقعی آموزش می‌دهیم:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;...
&lt;span class="gh"&gt;#&lt;/span&gt; Run training
model.fit([encoder_input_data, decoder_input_data], decoder_target_data,
      batch_size=batch_size,
      epochs=epochs,
      validation_split=0.2)
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;پس از آموزش مدل نوبت به آزمون مدل می‌رسد. در این مرحله می‌خواهیم با دادن یک جمله  زبان مبدأ به مدل ترجمه معادل آن در زبان مقصد را کدگشایی کنیم. برای این منظور نیاز است تا مدل‌هایی مشابه اما جدا از مدل آموزش تعریف کنیم. ابتدا مدل کدگذار را به نحوی تعریف می کنیم که جمله زبان مبدا را به عنوان ورودی بپذیرد و حالات آغازین مدل کدگشا را به عنوان خروجی تولید کند:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;...
&lt;span class="gu"&gt;##&lt;/span&gt; encoder model
encoder_model = Model(encoder_inputs, encoder_states)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;مدل کدگشا را طوری تعریف می‌کنیم که ورودی آن شامل حالت‌ها و خروجی مرحله قبلی خود باشد. در مرحله اول کدگشایی مقادیر  این ورودی‌ها عبارت‌اند از حالات خروجی مدل کدگذار و نشانه آغاز جمله زبان مقصد یعنی همان t. تکه کد زیر مدل کدگشا را تعریف می‌کند:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="err"&gt;##&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;decoder&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;model&lt;/span&gt;
&lt;span class="n"&gt;decoder_state_input_h&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;Input&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;shape&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;latent_dim&lt;/span&gt;&lt;span class="p"&gt;,))&lt;/span&gt;
&lt;span class="n"&gt;decoder_state_input_c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;Input&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;shape&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;latent_dim&lt;/span&gt;&lt;span class="p"&gt;,))&lt;/span&gt;
&lt;span class="n"&gt;decoder_states_inputs&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;decoder_state_input_h, decoder_state_input_c&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;decoder_outputs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;state_h&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;state_c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;decoder_lstm&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;decoder_inputs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;initial_state&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;decoder_states_inputs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;decoder_states&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;state_h, state_c&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;decoder_outputs&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;decoder_dense&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;decoder_outputs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;decoder_model&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Model&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;decoder_inputs&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;decoder_states_inputs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;decoder_outputs&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;decoder_states&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;دقت شود که برای ساخت مدل از همان لایه‌های (اشیای LSTM کدگذار و کدگشای ) ساخته شده در مرحله آموزش استفاده شده است. در ای حالت وزن لایه‌ها بین دو مدل ب اشتراک گذاشته می‌شود. یعنی وزن لایه‌ها از مرحله آموزش گرفته می‌شود و  از این مدل‌ها فقط برای پیش‌بینی خروجی با داشتن ورودی، استفاده می‌شود. تابع decode_sequence آمده در زیر، به عنوان آرگومان یک توالی ورودی را دریافت و توالی خروجی معادل آن را باز می‌گرداند:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="n"&gt;def&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;decode_sequence&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;input_seq&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;
&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Encode&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;the&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;as&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;state&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;vectors&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="n"&gt;states_value&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;encoder_model&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;predict&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;input_seq&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Generate&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;empty&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;target&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;sequence&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;of&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;1.&lt;/span&gt;
&lt;span class="n"&gt;target_seq&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;zeros&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num_decoder_tokens&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Populate&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;the&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;first&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;character&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;of&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;target&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;sequence&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;with&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;the&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;start&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;character&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="n"&gt;target_seq&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;0, 0, target_token_index[&amp;#39;\t&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="err"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;1.&lt;/span&gt;
&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Sampling&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;loop&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;batch&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;of&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;sequences&lt;/span&gt;
&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;to&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;simplify&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;here&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;we&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;assume&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;batch&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;of&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;size&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;
&lt;span class="n"&gt;stop_condition&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;False&lt;/span&gt;
&lt;span class="n"&gt;decoded_sentence&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;not&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nl"&gt;stop_condition&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;output_tokens&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;decoder_model&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;predict&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;target_seq&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;states_value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Sample&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;token&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;sampled_token_index&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;argmax&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;output_tokens&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;0, -1, :&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;sampled_char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;reverse_target_char_index&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;sampled_token_index&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;decoded_sentence&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;sampled_char&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;Exit&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;condition&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;either&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;hit&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;max&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;or&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;find&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;stop&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;character&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sampled_char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;or&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="nf"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;decoded_sentence&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;max_decoder_seq_length&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;stop_condition&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;True&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;Update&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;the&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;target&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;sequence&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;of&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;target_seq&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;zeros&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num_decoder_tokens&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;target_seq&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;0, 0, sampled_token_index&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;1.&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;Update&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;states&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;states_value&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;h, c&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;decoded_sentence&lt;/span&gt;
&lt;span class="p"&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;مدل‌های کدگذار و کدگشا که تابع فوق از آنها استفاده می‌کند و قبل از این تعریف شدند نیز به‌ ترتیب  به‌صورت گراف‌های زیر هستند:&lt;/p&gt;
&lt;p&gt;&lt;img alt="شکل (الف - 2) مدل کدگذار استفاده شده در مرحله پیش‌بینی (آزمون یا استنتاج)" src="https://boute.s3.amazonaws.com/290-sampling_encoder_model_20180206_155430.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="شکل (الف - 3) مدل کدگشای استفاده شده در مرحله پیش‌بینی (آزمون یا استنتاج)" src="https://boute.s3.amazonaws.com/290-sampling_decoder_model_20180206_155430.png"&gt;
&lt;strong&gt;توجه:&lt;/strong&gt; شماره‌های سمت چپ هر گره در گراف‌‌های این بخش به صورت ترتیبی توسط keras قرار داده می‌شوند و اهمیتی ندارند.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;h3&gt;ژرف‌سازی شبکه&lt;/h3&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;اگرچه مدل توضیح داده‌شده در این قسمت به طور کامل از مفاهیم شبکه‌های عصبی ژرف استفاده می‌کند اما به معنای واقعی کلمه &lt;em&gt;ژرف&lt;/em&gt; نیست. در keras به راحتی می‌توان یک مدل ژرف را با پشته کردن لایه‌ها روی یکدیگر ایجاد کرد. برای مثال چنانچه بخواهیم شبکه کدگذار مدل فوق دارای دو لایه LSTM باشد کافی است اولین لایه شبکه کدگذار (encoder_l1) را به‌گونه‌ای تعریف کنیم که یک توالی را به‌عنوان خروجی بدهد. سپس لایه ورودی را به این لایه متصل می‌کنیم و لایه LSTM موجود در کد قبلی این‌بار لایه جدید را به عنوان ورودی می‌پذیرد:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;...
&lt;span class="gh"&gt;#&lt;/span&gt; Define an input sequence. 
encoder_inputs = Input(shape=(None, num_encoder_tokens))
&lt;span class="gh"&gt;#&lt;/span&gt; Define LSTM layer 1 and pass the above encoder input sequence to it.
&lt;span class="gh"&gt;#&lt;/span&gt; note that return_sequences argument must set to be True in order to connect next to layer.
encoder_l1 = LSTM(latent_dim, return_sequences=True, return_state=True)(encoder_inputs)
&lt;span class="gh"&gt;#&lt;/span&gt; Define LSTM layer 2 (encoder)
encoder = LSTM(latent_dim, return_state=True)
&lt;span class="gh"&gt;#&lt;/span&gt; Pass (connect) encoder_l1 to LSTM layer 2 (encoder)
encoder_outputs, state_h, state_c = encoder(encoder_l1)
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;و به همین ترتیب این اقدام باید برای دیگر لایه‌های شبکه هم انجام شود.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;h3&gt;تبدیل مدل به یک مدل در سطح واژه&lt;/h3&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;مدل فوق در سطح کاراکتر عمل می‌کند. اگر یک توالی از اعداد صحیح داشته باشیم که هر عدد نشان دهنده شاخص واژه‌ای خاص در یک دیکشنری باشد. می‌توان با استفاده از لایه embedding موجود در keras مدل را برای استفاده از این نشانه‌های عددصحیح آماده کرد. تکه کد زیر این امکان را اضافه می‌کند:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="c1"&gt;# Define an input sequence and process it.&lt;/span&gt;
&lt;span class="n"&gt;encoder_inputs&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Input&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;shape&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,))&lt;/span&gt;
&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Embedding&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num_encoder_tokens&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;latent_dim&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;encoder_inputs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;state_h&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;state_c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;LSTM&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;latent_dim&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;return_state&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="no"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;encoder_states&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;[&lt;/span&gt;&lt;span class="n"&gt;state_h&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;state_c&lt;/span&gt;&lt;span class="err"&gt;]&lt;/span&gt;
&lt;span class="c1"&gt;# Set up the decoder, using `encoder_states` as initial state.&lt;/span&gt;
&lt;span class="n"&gt;decoder_inputs&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Input&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;shape&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,))&lt;/span&gt;
&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Embedding&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num_decoder_tokens&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;latent_dim&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;decoder_inputs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;LSTM&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;latent_dim&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;return_sequences&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="no"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;initial_state&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;encoder_states&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;decoder_outputs&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Dense&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num_decoder_tokens&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;activation&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;softmax&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;# Define the model that will turn&lt;/span&gt;
&lt;span class="c1"&gt;#encoder_input_data` &amp;amp; `decoder_input_data` into `decoder_target_data`&lt;/span&gt;
&lt;span class="n"&gt;model&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Model&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;[&lt;/span&gt;&lt;span class="n"&gt;encoder_inputs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;decoder_inputs&lt;/span&gt;&lt;span class="err"&gt;]&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;decoder_outputs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;# Compile &amp;amp; run training&lt;/span&gt;
&lt;span class="n"&gt;model&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;compile&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;optimizer&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;rmsprop&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;loss&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;categorical_crossentropy&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;# Note that `decoder_target_data` needs to be one-hot encoded,&lt;/span&gt;
&lt;span class="c1"&gt;# rather than sequences of integers like `decoder_input_data`!&lt;/span&gt;
&lt;span class="n"&gt;model&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;[&lt;/span&gt;&lt;span class="n"&gt;encoder_input_data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;decoder_input_data&lt;/span&gt;&lt;span class="err"&gt;]&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;decoder_target_data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;batch_size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;batch_size&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;epochs&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;epochs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;validation_split&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mf"&gt;0.2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;&lt;h2&gt;واژه‌نامه&lt;/h2&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;h3 align = "center"&gt;واژه‌نامه فـارســی به انگلـیسی&lt;/h3&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style="text-align: center;"&gt;&lt;strong&gt;واژه‌‌ی فـارسی&lt;/strong&gt;&lt;/th&gt;
&lt;th style="text-align: center;"&gt;&lt;/th&gt;
&lt;th style="text-align: center;"&gt;&lt;strong&gt;معادل انگلیسی&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;انفجار گرادیان&lt;/td&gt;
&lt;td style="text-align: center;"&gt;&lt;/td&gt;
&lt;td style="text-align: center;"&gt;Exploding Gradient&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;بانظارت&lt;/td&gt;
&lt;td style="text-align: center;"&gt;&lt;/td&gt;
&lt;td style="text-align: center;"&gt;Supervised&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;پردازش زبان طبیعی&lt;/td&gt;
&lt;td style="text-align: center;"&gt;&lt;/td&gt;
&lt;td style="text-align: center;"&gt;Natural Language Processing (NLP)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;پس‌انتشار&lt;/td&gt;
&lt;td style="text-align: center;"&gt;&lt;/td&gt;
&lt;td style="text-align: center;"&gt;Backpropagation&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;تابع بیشینه هموار&lt;/td&gt;
&lt;td style="text-align: center;"&gt;&lt;/td&gt;
&lt;td style="text-align: center;"&gt;Softmax Function&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;تأخیر زمانی کمینه&lt;/td&gt;
&lt;td style="text-align: center;"&gt;&lt;/td&gt;
&lt;td style="text-align: center;"&gt;Minimal Time Lag&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;ترجمه ماشینی&lt;/td&gt;
&lt;td style="text-align: center;"&gt;&lt;/td&gt;
&lt;td style="text-align: center;"&gt;Machine Translation (MT)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;ترجمه ماشینی آماری&lt;/td&gt;
&lt;td style="text-align: center;"&gt;&lt;/td&gt;
&lt;td style="text-align: center;"&gt;Statistical Machine Translation (SMT)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;ترجمه ماشینی عصبی&lt;/td&gt;
&lt;td style="text-align: center;"&gt;&lt;/td&gt;
&lt;td style="text-align: center;"&gt;Neural Machine Translation (NMT)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;تشخیص گفتار&lt;/td&gt;
&lt;td style="text-align: center;"&gt;&lt;/td&gt;
&lt;td style="text-align: center;"&gt;Speech Recognition&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;توالی&lt;/td&gt;
&lt;td style="text-align: center;"&gt;&lt;/td&gt;
&lt;td style="text-align: center;"&gt;Sequence&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;جست‌وجوی پرتوی محلی&lt;/td&gt;
&lt;td style="text-align: center;"&gt;&lt;/td&gt;
&lt;td style="text-align: center;"&gt;Beam Search&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;حافظه کوتاه مدت بلند&lt;/td&gt;
&lt;td style="text-align: center;"&gt;&lt;/td&gt;
&lt;td style="text-align: center;"&gt;Long-Short Term Memory (LSTM)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;دسته&lt;/td&gt;
&lt;td style="text-align: center;"&gt;&lt;/td&gt;
&lt;td style="text-align: center;"&gt;Batch&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;دوره&lt;/td&gt;
&lt;td style="text-align: center;"&gt;&lt;/td&gt;
&lt;td style="text-align: center;"&gt;Epoch&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;سرگشتگی&lt;/td&gt;
&lt;td style="text-align: center;"&gt;&lt;/td&gt;
&lt;td style="text-align: center;"&gt;Perplexity&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;شبکه عصبی پیچشی&lt;/td&gt;
&lt;td style="text-align: center;"&gt;&lt;/td&gt;
&lt;td style="text-align: center;"&gt;Convolutional Neural Network (CNN)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;شبکه عصبی رو به جلو ژرف&lt;/td&gt;
&lt;td style="text-align: center;"&gt;&lt;/td&gt;
&lt;td style="text-align: center;"&gt;Deep Feed-forward Neural Network&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;شبکه عصبی ژرف&lt;/td&gt;
&lt;td style="text-align: center;"&gt;&lt;/td&gt;
&lt;td style="text-align: center;"&gt;Deep Neural Network (DNN)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;شبکه عصبی مکرر&lt;/td&gt;
&lt;td style="text-align: center;"&gt;&lt;/td&gt;
&lt;td style="text-align: center;"&gt;(RNN) Recurrent Neural Network&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;فرضیه جزئی&lt;/td&gt;
&lt;td style="text-align: center;"&gt;&lt;/td&gt;
&lt;td style="text-align: center;"&gt;Partial Hypothesis&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;کدگذار&lt;/td&gt;
&lt;td style="text-align: center;"&gt;&lt;/td&gt;
&lt;td style="text-align: center;"&gt;Encoder&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;کدگشا&lt;/td&gt;
&lt;td style="text-align: center;"&gt;&lt;/td&gt;
&lt;td style="text-align: center;"&gt;Decoder&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;گذر جلو&lt;/td&gt;
&lt;td style="text-align: center;"&gt;&lt;/td&gt;
&lt;td style="text-align: center;"&gt;Forward Pass&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;مدل زبانی&lt;/td&gt;
&lt;td style="text-align: center;"&gt;&lt;/td&gt;
&lt;td style="text-align: center;"&gt;Language Model (LM)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;مدل زبانی عصبی&lt;/td&gt;
&lt;td style="text-align: center;"&gt;&lt;/td&gt;
&lt;td style="text-align: center;"&gt;Neural Language Model (NLM)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;میرایی گرادیان&lt;/td&gt;
&lt;td style="text-align: center;"&gt;&lt;/td&gt;
&lt;td style="text-align: center;"&gt;Vanishing Gradient&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;نشانه‌گذاری شده&lt;/td&gt;
&lt;td style="text-align: center;"&gt;&lt;/td&gt;
&lt;td style="text-align: center;"&gt;Tokenized&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;h3&gt;پانوشت‌ها&lt;/h3&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;deep neural networks&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;backpropagation&amp;#160;&lt;a class="footnote-backref" href="#fnref:2" title="Jump back to footnote 2 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:3"&gt;
&lt;p&gt;supervised&amp;#160;&lt;a class="footnote-backref" href="#fnref:3" title="Jump back to footnote 3 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:4"&gt;
&lt;p&gt;natural language processing&amp;#160;&lt;a class="footnote-backref" href="#fnref:4" title="Jump back to footnote 4 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:5"&gt;
&lt;p&gt;sequence&amp;#160;&lt;a class="footnote-backref" href="#fnref:5" title="Jump back to footnote 5 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:6"&gt;
&lt;p&gt;deep feed-forward neural networks&amp;#160;&lt;a class="footnote-backref" href="#fnref:6" title="Jump back to footnote 6 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:7"&gt;
&lt;p&gt;recurrent neural networks&amp;#160;&lt;a class="footnote-backref" href="#fnref:7" title="Jump back to footnote 7 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:8"&gt;
&lt;p&gt;convolutional neural networks&amp;#160;&lt;a class="footnote-backref" href="#fnref:8" title="Jump back to footnote 8 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:9"&gt;
&lt;p&gt;grid&amp;#160;&lt;a class="footnote-backref" href="#fnref:9" title="Jump back to footnote 9 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:10"&gt;
&lt;p&gt;machine translation&amp;#160;&lt;a class="footnote-backref" href="#fnref:10" title="Jump back to footnote 10 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:11"&gt;
&lt;p&gt;speech recognition&amp;#160;&lt;a class="footnote-backref" href="#fnref:11" title="Jump back to footnote 11 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:12"&gt;
&lt;p&gt;long-short term memory&amp;#160;&lt;a class="footnote-backref" href="#fnref:12" title="Jump back to footnote 12 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:13"&gt;
&lt;p&gt;neural machine translation&amp;#160;&lt;a class="footnote-backref" href="#fnref:13" title="Jump back to footnote 13 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:14"&gt;
&lt;p&gt;statistical machine translation&amp;#160;&lt;a class="footnote-backref" href="#fnref:14" title="Jump back to footnote 14 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:15"&gt;
&lt;p&gt;language model&amp;#160;&lt;a class="footnote-backref" href="#fnref:15" title="Jump back to footnote 15 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:16"&gt;
&lt;p&gt;neural language models&amp;#160;&lt;a class="footnote-backref" href="#fnref:16" title="Jump back to footnote 16 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:17"&gt;
&lt;p&gt;forward pass&amp;#160;&lt;a class="footnote-backref" href="#fnref:17" title="Jump back to footnote 17 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:18"&gt;
&lt;p&gt;rectified linear unit&amp;#160;&lt;a class="footnote-backref" href="#fnref:18" title="Jump back to footnote 18 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:19"&gt;
&lt;p&gt;sigmoid&amp;#160;&lt;a class="footnote-backref" href="#fnref:19" title="Jump back to footnote 19 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:20"&gt;
&lt;p&gt;softmax function&amp;#160;&lt;a class="footnote-backref" href="#fnref:20" title="Jump back to footnote 20 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:21"&gt;
&lt;p&gt;n-best list&amp;#160;&lt;a class="footnote-backref" href="#fnref:21" title="Jump back to footnote 21 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:22"&gt;
&lt;p&gt;topic model&amp;#160;&lt;a class="footnote-backref" href="#fnref:22" title="Jump back to footnote 22 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:23"&gt;
&lt;p&gt;batch&amp;#160;&lt;a class="footnote-backref" href="#fnref:23" title="Jump back to footnote 23 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:24"&gt;
&lt;p&gt;epoch&amp;#160;&lt;a class="footnote-backref" href="#fnref:24" title="Jump back to footnote 24 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:25"&gt;
&lt;p&gt;vanishing gradient&amp;#160;&lt;a class="footnote-backref" href="#fnref:25" title="Jump back to footnote 25 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:26"&gt;
&lt;p&gt;exploding gradient&amp;#160;&lt;a class="footnote-backref" href="#fnref:26" title="Jump back to footnote 26 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:27"&gt;
&lt;p&gt;inference&amp;#160;&lt;a class="footnote-backref" href="#fnref:27" title="Jump back to footnote 27 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:29"&gt;
&lt;p&gt;tokenized&amp;#160;&lt;a class="footnote-backref" href="#fnref:29" title="Jump back to footnote 28 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:30"&gt;
&lt;p&gt;beam search&amp;#160;&lt;a class="footnote-backref" href="#fnref:30" title="Jump back to footnote 29 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:31"&gt;
&lt;p&gt;partial hypothesis&amp;#160;&lt;a class="footnote-backref" href="#fnref:31" title="Jump back to footnote 30 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:32"&gt;
&lt;p&gt;perplexity&amp;#160;&lt;a class="footnote-backref" href="#fnref:32" title="Jump back to footnote 31 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:33"&gt;
&lt;p&gt;minimal time lag&amp;#160;&lt;a class="footnote-backref" href="#fnref:33" title="Jump back to footnote 32 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:34"&gt;
&lt;p&gt;چندین نوع محاسبه از امتیاز BLEU وجود دارد کــه هر نوع با یک اسکریپت زبان perl تعریف شده است و در این مقاله از این اسکریپت‌های موجود برای محاسبه امتیاز BLEU استفاده شده است.&amp;#160;&lt;a class="footnote-backref" href="#fnref:34" title="Jump back to footnote 33 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="blog"></category><category term="blog"></category></entry><entry><title>Computer science at the heart of civilization</title><link href="https://m-zakeri.github.io/computer-science-at-the-heart-of-civilization.html" rel="alternate"></link><published>2019-02-22T12:30:00+03:30</published><updated>2019-02-22T12:30:00+03:30</updated><author><name>Morteza</name></author><id>tag:m-zakeri.github.io,2019-02-22:/computer-science-at-the-heart-of-civilization.html</id><summary type="html">&lt;p&gt;Over the past years, I have successfully integrated computer science into a variety of disciplines, including medicine (developing a non-invasive bladder monitoring system and jaundice prediction models), civil engineering (designing bridge management systems, detect attention state of people during exposure to construction noise), materials engineering (applying artificial intelligence to inverse material design), railway engineering (testing an interlocking system), sociology (creating an intelligent mixed research framework), sports (developing a swimming competition management system), and molecular physics (utilizing Raman spectroscopy).&lt;/p&gt;</summary><content type="html">&lt;p&gt;These projects have facilitated a modern approach to interdisciplinary problem-solving known as computational thinking. The most fascinating aspect of this work is how solving a problem in one domain often provides insights to address challenges in entirely different domains. The focus of this effort has been the generalization of solutions to make them applicable to a broad spectrum of problems.&lt;/p&gt;
&lt;h2&gt;Bridging Disciplines Through Computational Thinking&lt;/h2&gt;
&lt;p&gt;Over the past years, I have successfully integrated computer science into a variety of disciplines, showcasing the transformative potential of computational thinking. This interdisciplinary approach has yielded significant contributions in multiple fields: medicine (developing a non-invasive bladder monitoring system and jaundice prediction models), civil engineering (designing bridge management systems), materials engineering (applying artificial intelligence to inverse material design), railway engineering (testing an interlocking system), sociology (creating an intelligent mixed research framework), sports (developing a swimming competition management system), and molecular physics (utilizing Raman spectroscopy).&lt;/p&gt;
&lt;p&gt;Each of these projects exemplifies the power of computational thinking in solving complex, real-world challenges. By abstracting and generalizing solutions, I have not only addressed specific problems within individual domains but also developed methods that can be applied to entirely different fields. This work demonstrates the universality of computational principles and their capacity to drive innovation across disciplines.&lt;/p&gt;
&lt;h3&gt;Expanding the Horizons of Computational Thinking&lt;/h3&gt;
&lt;p&gt;The interdisciplinary nature of computational thinking has opened new avenues for exploration. For instance:
- &lt;strong&gt;Healthcare and AI Integration&lt;/strong&gt;: Leveraging machine learning for early disease detection, personalized treatments, and non-invasive diagnostic tools.
- &lt;strong&gt;Environmental Engineering&lt;/strong&gt;: Employing computational models to analyze climate patterns, optimize renewable energy systems, and develop sustainable urban planning solutions.
- &lt;strong&gt;Education&lt;/strong&gt;: Designing intelligent tutoring systems that adapt to individual student needs and incorporating computational thinking into curricula to foster problem-solving skills across all disciplines.
- &lt;strong&gt;Arts and Humanities&lt;/strong&gt;: Utilizing computational methods to analyze literary texts, reconstruct historical artifacts, and create generative art.
- &lt;strong&gt;Ethics and Policy&lt;/strong&gt;: Developing frameworks to ensure the ethical application of computational technologies and addressing societal implications of automation and AI.&lt;/p&gt;
&lt;h3&gt;Future Works in Interdisciplinary Computational Thinking&lt;/h3&gt;
&lt;p&gt;Moving forward, several promising areas warrant further research and development:
1. &lt;strong&gt;Adaptive Generalization of Solutions&lt;/strong&gt;: Refining computational models to ensure their adaptability to diverse and evolving problems across disciplines.
2. &lt;strong&gt;Cross-Domain Knowledge Transfer&lt;/strong&gt;: Investigating methodologies for systematically transferring insights and solutions between domains to foster more efficient and innovative problem-solving.
3. &lt;strong&gt;Human-Centric Design in Computational Tools&lt;/strong&gt;: Focusing on usability and accessibility to ensure that computational solutions are approachable and effective for experts in non-technical fields.
4. &lt;strong&gt;Collaboration Platforms for Interdisciplinary Research&lt;/strong&gt;: Building digital ecosystems that connect researchers from different fields, facilitating collaboration, knowledge sharing, and integrated solution development.
5. &lt;strong&gt;Addressing Socio-Technical Challenges&lt;/strong&gt;: Exploring computational approaches to complex societal challenges, such as public health crises, environmental sustainability, and social equity.&lt;/p&gt;
&lt;h3&gt;Remark&lt;/h3&gt;
&lt;p&gt;The interdisciplinary application of computational thinking has not only enhanced my ability to solve problems in diverse fields but has also deepened my understanding of the interconnectedness of knowledge. Each endeavor has been an opportunity to transcend traditional boundaries, fostering innovation that benefits both specialized fields and society at large.&lt;/p&gt;
&lt;p&gt;The evolving landscape of computational thinking continues to offer untapped potential for bridging gaps between disciplines. By embracing this modern approach, we can address increasingly complex challenges in a way that leverages the strengths of diverse fields and creates solutions that are both robust and adaptable.&lt;/p&gt;</content><category term="blog"></category><category term="blog"></category></entry><entry><title>Welcome</title><link href="https://m-zakeri.github.io/welcome.html" rel="alternate"></link><published>2019-02-22T12:30:00+03:30</published><updated>2019-02-22T12:30:00+03:30</updated><author><name>Morteza</name></author><id>tag:m-zakeri.github.io,2019-02-22:/welcome.html</id><summary type="html">&lt;p&gt;"&lt;strong&gt;L&lt;/strong&gt;ife &lt;strong&gt;I&lt;/strong&gt;s a &lt;strong&gt;F&lt;/strong&gt;ractal &lt;strong&gt;E&lt;/strong&gt;vent. Create unlimited values in limited time!", Morteza&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="fractal-life" src="../static/img/fractal-life.gif"&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;"&lt;strong&gt;L&lt;/strong&gt;ife &lt;strong&gt;I&lt;/strong&gt;s a &lt;strong&gt;F&lt;/strong&gt;ractal &lt;strong&gt;E&lt;/strong&gt;vent (Exploration). Create unlimited (infinite) values in limited time!"&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Morteza&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Hello and welcome to my new personal web-page and blog on GitHub. The blog is under construction and some pages will add in future. Please refer to &lt;a href="../pages/about.md"&gt;About me&lt;/a&gt; page for more information. &lt;/p&gt;
&lt;h3&gt;A note about the blogging tool&lt;/h3&gt;
&lt;p&gt;I recently read about &lt;a href="http://docs.getpelican.com" target="_blank"&gt;Pelican&lt;/a&gt; and decided to switch my blog from pure unstructured HTML to a structured static website. &lt;a href="http://docs.getpelican.com" target="_blank"&gt;Pelican&lt;/a&gt; is really beautiful blogging and publishing tool. Simply put, Pelican is a neat static site generator (SSG) written in Python. Like all SSGs, it enables super fast website generation. Pelican has no heavy docs, straightforward installation, and powerful features such as plugins and extendability.
I am new to &lt;a href="http://docs.getpelican.com" target="_blank"&gt;Pelican&lt;/a&gt;, but it is simple and easy to use. I strongly recommend you to use Pelican! &lt;/p&gt;</content><category term="blog"></category><category term="blog"></category></entry></feed>