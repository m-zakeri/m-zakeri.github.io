
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="robots" content="index, follow" />

  <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:ital,wght@0,400;0,700;1,400&family=Source+Sans+Pro:ital,wght@0,300;0,400;0,700;1,400&display=swap" rel="stylesheet">

    <link rel="stylesheet" type="text/css" href="./theme/stylesheet/style.min.css">

    <link id="dark-theme-style" rel="stylesheet" type="text/css"
          media="(prefers-color-scheme: dark)"
    href="./theme/stylesheet/dark-theme.min.css">

    <link id="pygments-dark-theme" rel="stylesheet" type="text/css"
              media="(prefers-color-scheme: dark)"
          href="./theme/pygments/monokai.min.css">
    <link id="pygments-light-theme" rel="stylesheet" type="text/css"
              media="(prefers-color-scheme: light), (prefers-color-scheme: no-preference)"
          href="./theme/pygments/emacs.min.css">


  <link rel="stylesheet"
        type="text/css"
        href="./theme/stork/stork.css" />

  <link rel="stylesheet" type="text/css" href="./theme/font-awesome/css/fontawesome.css">
  <link rel="stylesheet" type="text/css" href="./theme/font-awesome/css/brands.css">
  <link rel="stylesheet" type="text/css" href="./theme/font-awesome/css/solid.css">

  <link rel="stylesheet" type="text/css" href=".//static/css/custom.css">

  <link rel="shortcut icon" href="/static/img/favicon.ico" type="image/x-icon">
  <link rel="icon" href="/static/img/favicon.ico" type="image/x-icon">

  <!-- Chrome, Firefox OS and Opera -->
  <meta name="theme-color" content="#333">
  <!-- Windows Phone -->
  <meta name="msapplication-navbutton-color" content="#333">
  <!-- iOS Safari -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <!-- Microsoft EDGE -->
  <meta name="msapplication-TileColor" content="#333">

  <link href="https://m-zakeri.github.io/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Morteza Zakeri Atom">








 

<meta name="author" content="Morteza" />
<meta name="description" content="A survey of sequence-to-sequence learning with deep neural networks." />
<meta name="keywords" content="blog">


  <meta property="og:site_name" content="Morteza Zakeri"/>
  <meta property="og:title" content="A survey of sequence-to-sequence learning with neural networks"/>
  <meta property="og:description" content="A survey of sequence-to-sequence learning with deep neural networks."/>
  <meta property="og:locale" content="en_US"/>
  <meta property="og:url" content="./a-survey-of-sequence-to-sequence-learning-with-neural-networks.html"/>
  <meta property="og:type" content="article"/>
  <meta property="article:published_time" content="2019-02-22 12:30:00+03:30"/>
  <meta property="article:modified_time" content=""/>
  <meta property="article:author" content="./author/morteza.html">
  <meta property="article:section" content="blog"/>
  <meta property="article:tag" content="blog"/>
  <meta property="og:image" content="/static/img/profile.png">

  <title>Morteza Zakeri &ndash; A survey of sequence-to-sequence learning with neural networks</title>


</head>
<body >

<aside>
  <div>
    <a href="./">
      <img src="/static/img/profile.png" alt="Morteza Zakeri" title="Morteza Zakeri">
    </a>

    <h1>
      <a href="./">Morteza Zakeri</a>
    </h1>

    <p>PhD in Computer Science</p>

    <div class="stork">
      <input class="stork-input" type="text" autocomplete="off" name="q" data-stork="sitesearch" placeholder="Search..." onclick="loadStorkIndex()"/>
      <div class="stork-output" data-stork="sitesearch-output"></div>
    </div>

    <nav>
      <ul class="list">


            <li>
              <a target="_self"
                 href="./#about-me">
                About Me
              </a>
            </li>
            <li>
              <a target="_self"
                 href="./pages/contact-me.html#contact-me">
                Contact Me
              </a>
            </li>
            <li>
              <a target="_self"
                 href="./pages/gallery.html#gallery">
                Gallery
              </a>
            </li>
            <li>
              <a target="_self"
                 href="./pages/honors-and-awards.html#honors-and-awards">
                Honors and Awards
              </a>
            </li>
            <li>
              <a target="_self"
                 href="./pages/media.html#media">
                Media
              </a>
            </li>
            <li>
              <a target="_self"
                 href="./pages/news.html#news">
                News
              </a>
            </li>
            <li>
              <a target="_self"
                 href="./pages/presentations.html#presentations">
                Presentations
              </a>
            </li>
            <li>
              <a target="_self"
                 href="./pages/services-and-projects.html#services-and-projects">
                Services and Projects
              </a>
            </li>
            <li>
              <a target="_self"
                 href="./pages/publications.html#publications">
                Publications
              </a>
            </li>
            <li>
              <a target="_self"
                 href="./pages/research.html#research">
                Research
              </a>
            </li>
            <li>
              <a target="_self"
                 href="./pages/resources.html#resources">
                Resources
              </a>
            </li>
            <li>
              <a target="_self"
                 href="./pages/teaching.html#teaching">
                Teaching
              </a>
            </li>

          <li>
            <a target="_self" href="https://m-zakeri.github.io/lab" >Laboratory in AUT</a>
          </li>
          <li>
            <a target="_self" href="http://reverse.iust.ac.ir" >Laboratory in IUST</a>
          </li>
          <li>
            <a target="_self" href="http://webpages.iust.ac.ir/morteza_zakeri/" >My University Page (IUST)</a>
          </li>
      </ul>
    </nav>

    <ul class="social">
      <li>
        <a class="sc-linkedin"
           href="https://www.linkedin.com/in/mortazazakeri"
           target="_blank">
          <i class="fa-brands fa-linkedin"></i>
        </a>
      </li>
      <li>
        <a class="sc-twitter"
           href="https://twitter.com/_zakeri_"
           target="_blank">
          <i class="fa-brands fa-twitter"></i>
        </a>
      </li>
      <li>
        <a class="sc-github"
           href="https://github.com/m-zakeri"
           target="_blank">
          <i class="fa-brands fa-github"></i>
        </a>
      </li>
      <li>
        <a class="sc-telegram"
           href="https://t.me/mztel"
           target="_blank">
          <i class="fa-brands fa-telegram"></i>
        </a>
      </li>
      <li>
        <a class="sc-rss"
           href="/feeds/all.atom.xml"
           target="_blank">
          <i class="fa-solid fa-rss"></i>
        </a>
      </li>
    </ul>
  </div>

</aside>
  <main>

<nav>
  <a href="./">Home</a>

  <a href="/category/blog.html">Blog</a>
  <a href="/category/services.html">Services</a>
  <a href="/category/courses.html">Courses</a>
  <a href="/categories.html">Categories</a>
  <a href="/archives.html">Archives</a>
  <a href="/tags.html">Tags</a>
  <a href="/sitemap.xml">Sitemap</a>

  <a href="https://m-zakeri.github.io/feeds/all.atom.xml">Atom</a>

</nav>

<article class="single">
  <header>
      
    <h1 id="a-survey-of-sequence-to-sequence-learning-with-neural-networks">A survey of sequence-to-sequence learning with neural networks</h1>
    <p>
      Posted on Fri 22 February 2019 in <a href="./category/blog.html">blog</a>

    </p>
  </header>


  <div>
    <p><a href="https://boute.s3.amazonaws.com/290-IUST_logo_color.png"><b>دانشـکده مهندسی کامپیوتر</b></a></p>
<p><strong><h1 align = "center">یـادگیری توالی‌به‌توالی با شبکه‌های عصبی</h1></strong></p>
<h4 align="center">
<b> مرتــضی ذاکـری (M - Z A K E R I [ A T ] L I V E [ D O T ] C O M)
</b>
</h4>

<ul>
<li><a href="https://www.dropbox.com/s/gii9b6ncz28xfbn/nmt_lstm_sequence2sequence.zip?dl=0">پیاده‌سازی + مجموعه داده - فایل ZIP (حجم 18.50MB)</a> <em>بهمن 1396</em></li>
<li><a href="https://www.dropbox.com/s/3gris6459iw5tfp/Zakeri_NLP961_project_p3_final.pdf?dl=0">فاز سوم (نهایی) - نسخه PDF (حجم 1.80MB)</a> <em>بهمن 1396</em></li>
<li>ارایـه (<a href="https://www.dropbox.com/s/x8i9nwo8n1l3tlk/Zakeri_NLP961_project_p3_presentation.pdf?dl=0">اسلاید (حجم 1.92MB)</a>  |  <a href="https://www.dropbox.com/s/43xs7e0kmnil5ku/Zakeri_NLP961_project_p3_talk.mp4?dl=0">ویدئـو (حجم 53.50MB)</a>) <em>دی‌ 1396</em></li>
<li><a href="https://www.dropbox.com/s/mtngihanlci090r/Zakeri_NLP961_project_p2_rc02.pdf?dl=0">فاز دوم - نسخه PDF (حجم 1.75MB)</a> <em>آذر 1396</em></li>
<li><a href="https://www.dropbox.com/s/b3n2nfc1hgmvkhh/Zakeri_NLP961_project_p1_rc01.pdf?dl=0">فاز اول - نسخه PDF (حجم 1.23MB)</a> <em>آبان‌ 1396</em></li>
<li><a href="https://www.dropbox.com/s/xd5y5zxrvm9f67d/Zakeri_NLP961_project_figs.zip?dl=0"> تصاویر - فایل ZIP (حجم 2.22MB)</a> </li>
<li><a href="https://www.dropbox.com/s/ikyd12fytka91f3/2014_sequence-to-sequence-learning-with-neural-networks.pdf?dl=0">مرجع اصلی (حجم 165KB)</a></li>
<li>تاریخ آخرین بروزرسانی: 19 - 11 -  1396</li>
</ul>
<hr>
<p><strong><h2>چکیده</h2></strong>یادگیری ژرف شاخه‌ای نسبتا جدید از یادگیری ماشین است که در آن توابع محاسباتی به‌شکل گراف‌های چند سطحی یا ژرف برای شناسایی و تخمین قانون حاکم بر حل یک مسئله پیچیده به‌کار بسته می‌شوند. شبکه‌های عصبی ژرف ابزاری برای طراحی و پیاده‌سازی این مدل یادگیری هستند. این شبکه‌ها در بسیاری از وظایف یادگیری ماشینی سخت، موفق ظاهر شده‌اند. به‌منظور استفاده از شبکه‌های ژرف در وظایفی که ترتیب ورودی داده‌ در انجام آن مؤثر است مانند اکثر وظایف حوزه پردازش زبان طبیعی، شبکه‌های عصبی مکرر ابداع گشتند که بازنمایی مناسبی از مدل‌های زبانی ارایه می‌دهند. این مدل‌ها در حالت ساده برای همه وظیفه‌های یک مدل زبانی مناسب نیستند. در این گزارش مدل خاصی از شبکه‌های مکرر تحت عنوان مدل توالی‌به‌توالی یا کدگذار-گدگشا بررسی می‌شود که برای وظایفی که شامل توالی‌های ورودی و خروجی با طول متفاوت هستند؛ نظیر ترجمه ماشینی، توسعه داده شده و توانسته است نتایج قابل قبولی را در این زمینه تولید کند.
<strong>کلیدواژه‌ها:</strong> مدل توالی‌به‌توالی، شبکه عصبی مکرر، یادگیری ژرف، ترجمه ماشینی.</p>
<p><br/></p>
<h1><strong>مقدمه</strong></h1>
<p>مدل‌ها و روش‌های یادگیری به‌کمک شبکه‌های عصبی ژرف (DNNs)<sup id="fnref:1"><a class="footnote-ref" href="#fn:1">1</a></sup> اخیرا، با افزایش قدرت محاسباتی سخت‌افزارها و نیز حل برخی از چالش‌های اساسی موجود بر سر راه آموزش و یادگیری این شبکه‌ها، بسیار مورد توجه واقع شده‌اند. DNNها در انجام وظایف سخت یادگیری ماشین مانند تشخیص گفتار، تشخیص اشیاء و غیره، فوق‌العاده قدرت‌مند ظاهر شده‌اند و در مواردی روش‌های سنتی را کاملاً کنار زده‌اند. قدرت بازنمایی زیاد DNNها به این دلیل است که قادر هستند محاسبات زیادی را به صورت موازی در چندین لایه انجام داده، با تعداد زیادی پارامتر پاسخ مسئله داده شده را تخمین زده و مدل مناسبی از آن ارایه دهند. درحال حاضر DNNهای بزرگ می‌توانند با استفاده از الگوریتم پس‌انتشار<sup id="fnref:2"><a class="footnote-ref" href="#fn:2">2</a></sup> به‌صورت بانظارت<sup id="fnref:3"><a class="footnote-ref" href="#fn:3">3</a></sup> روی یک مجموعه آموزش برچسب‌زده و به‌قدر کافی بزرگ آموزش ببینند. بنابراین در مواردی که ضابطه حاکم بر یک مسئله دارای پارامترهای بسیار زیادی است و یک مقدار بهینه از این پارامترها وجود دارد (صرفا با استناد به این که مغز انسان همین مسئله را خیلی سریع حل می‌کند)، روش یادگیری پس‌انتشار این تنظیم از پارامترها (مقدارهای بهینه) را یافته و مسئله را حل می‌کند [1].
 بسیاری از وظایف یادگیری ماشین به حوزه پردازش زبان طبیعی (NLP)<sup id="fnref:4"><a class="footnote-ref" href="#fn:4">4</a></sup> مربوط می‌شوند؛ جایی که در آن معمولا ترتیب ورودی‌ها و خروجی‌های یک مسئله مهم است. برای مثال در ترجمه ماشینی دو جمله با واژه‌های یکسان ولی ترتیب متفاوت، معانی (خروجی‌های) مختلفی دارند. این وظایف اصطلاحا مبتنی بر توالی<sup id="fnref:5"><a class="footnote-ref" href="#fn:5">5</a></sup> هستند. در واقع ورودی آنها به صورت یک توالی است. شبکه‌های عصبی رو به جلو ژرف<sup id="fnref:6"><a class="footnote-ref" href="#fn:6">6</a></sup>  برای این دسته از وظایف خوب عمل نمی‌کنند؛ چرا که قابلیتی برای به‌خاطر سپاری و مدل‌سازی ترتیب در آنها تعبیه نشده است.شبکه‌های عصبی مکرر (RNNs)<sup id="fnref:7"><a class="footnote-ref" href="#fn:7">7</a></sup> خانواده‌ای از شبکه‌های عصبی برای پردازش وظایف مبتنی بر توالی هستند. همانطور که شبکه‌های عصبی پیچشی (CNNs)<sup id="fnref:8"><a class="footnote-ref" href="#fn:8">8</a></sup>، ویژه پردازش یک تور<sup id="fnref:9"><a class="footnote-ref" href="#fn:9">9</a></sup> از مقادیر، برای مثال یک تصویر، طراحی شده‌اند؛ یک RNN نیز همسو با پردازش یک توالی از مقادیر ورودی $$  x\quad =\quad &lt;{ x }^{ (1) },\quad { x }^{ (2) },\quad ...,\quad { x }^{ (n) }&gt; $$ساخته شده است [2]. خروجی RNNها نیز مانند ورودی آنها در اغلب وظایف یک توالی است. این قابلیت پردازش توالی توسط شبکه‌های عصبی، آنها را برای استفاده در وظایف NLP، بسیار درخور ساخته است.</p>
<h2><strong>شرح مسئله و اهمیت موضوع</strong></h2>
<p>برخلاف انعطاف پذیری و قدرت بالای RNNها، در حالت ساده این شبکه‌ها یک توالی ورودی با طول ثابت را به یک توالی خروجی با همان طول نگاشت می‌کنند. این موضوع اما یک محدودیت جدی است؛ زیرا، بسیاری از مسائل مهم، در قالب توالی‌هایی که طولشان از قبل مشخص نیست، به‌ بهترین شکل قابل بیان هستند و در نظر گرفتن یک طول ثابت از پیش تعیین شده برای ورودی و خروجی به خوبی مسئله را مدل نمی‌کند. برای مثال ترجمه ماشینی (MT)<sup id="fnref:10"><a class="footnote-ref" href="#fn:10">10</a></sup> و تشخیص گفتار<sup id="fnref:11"><a class="footnote-ref" href="#fn:11">11</a></sup> مسائلی از این دست هستند. همچنین سیستم پرسش و پاسخ را نیز می‌توان به صورت نگاشت یک توالی از واژه‌ها به‌عنوان پرسش، به یک توالی دیگر از واژه‌ها به عنوان پاسخ، در نظر گرفت. بنابراین پُر واضح است که ایجاد یک روش مستقل از دامنه برای یادگـیری نگاشت توالی‌به‌تولی مفید و قابل توجیه خواهد بود [1].</p>
<h2><strong>اهداف و راهکارها</strong></h2>
<p>همانطور که دیدیم طیف وسیعی از وظایف NLP مبتنی بر نگاشت توالی‌های با طول نامشخص و متغیر به یکدیگر است. همچنین روش‌های سنتی مثل n-garm دارای محدودیت‌های خاص خود در حل این دسته مسائل هستند و استفاده از روش‌های یادگیری ژرف به وضوح امید بخش بوده است. بنابراین هدف ارایه یک مدل مبتنی بر RNNها جهت نگاشت توالی‌به‌توالی است. در این گـزارش راهکار مطرح شده در [1] و نتایج آن به‌تفصیل شرح داده می‌شود.
     Stuskever و همکاران [1] نشان دادند که چگونه یک کاربرد ساده از شبکه با معماری حافظه کوتاه‌مدت بلند (LSTM)<sup id="fnref:12"><a class="footnote-ref" href="#fn:12">12</a></sup> می‌تواند مسائل نگاشت توالی‌به‌توالی را حل کند. ایده اصلی استفاده از یک LSTM برای خواندن توالی ورودی، به‌صورت یک نمونه در هر مرحله زمانی، جهت اقتباس برداری بزرگ با بعد ثابت و سپس استفاده از یک LSTM دیگر برای استخراج توالی خروجی از آن بردار است. LSTM دوم دقیقا یک مدل زبانی مبتنی بر RNN است با این تفاوت که حاوی احتمال شرطی نسبت به توالی ورودی نیز هست. قابلیت LSTM در یادگیری موفق وابستگی‌های مکانی طولانی مدت نهفته درون توالی‌ها، آن را برای استفاده در مدل پیشنهادی مناسب ساخته است. ‏شکل (1) یک طرح‌واره از این مدل را به صورت عام نشان می‌دهد.
<img alt="شکل (1) یک طرح‌واره از مدل توالی‌به‌توالی متشکل از دو RNN. این مدل توالی ABC را به‌عنوان ورودی خوانده و توالی WXYZ را به‌عنوان خروجی تولید می‌کند. مدل پس از تولید نشانه EOS روند پیش‌بینی خود را متوقف می‌کند [1]. " src="https://boute.s3.amazonaws.com/290-fig1.PNG"></p>
<h2><strong>داده‌ها و نتایج</strong></h2>
<p>مدل پیشنهادی در بخش قبل، برروی وظیفه ترجمه ماشینی عصبی (NMT)<sup id="fnref:13"><a class="footnote-ref" href="#fn:13">13</a></sup> مورد آزمایش قرار گرفته است. برای انجام آزمایش‌ها از مجموعه داده ترجمه انگلیسی به فرانسوی WMT’14 استفاده شده است [3]. همچنین مجموعه داده کوچکتری در [4] وجود دارد که برای آموزش مدل‌های آزمایشی و غیر واقعی مناسب است. این مجموعه شامل ترجمه‌های انگلیسی به فارسی نیز هست.
 نتایج حاصل شده از این کار بدین قرار است. بر روی مجموعه داده WMT’14 با استخراج مستقیم ترجمه از پنج LSTM ژرف با 380 میلیون پارامتر، در نهایت امتیاز BLEU معادل 34.81 کسب گردیده است. این امتیاز بالاترین امتیازی است که تا زمان ارایه این مقاله از طریق NMT حاصل شده است. به‌عنوان مقایسه امتیاز BLEU برای ترجمه ماشینی آماری (SMT)<sup id="fnref:14"><a class="footnote-ref" href="#fn:14">14</a></sup> برروی همین مجموعه داده برابر 33.30 است. این درحالی است که امتیاز 34.81 با احتساب اندازه واژه‌نامه 80هزار کلمه به‌دست آمده و هرجا که کلمه ظاهر شده در ترجمه مرجع در واژه‌نامه نبوده این امتیاز جریمه شده است. بنابراین نتایج نشان می‌دهد که یک معماری مبتنی بر شبکه عصبی تقریبا غیر بهینه، که نقاط زیادی برای بهبود دارد، قادر است تا روش‌های سنتی مبتنی بر عبارتِ سیستم SMT را شکست دهد [1].</p>
<p><br/></p>
<h1><strong>مفاهیم اولیه</strong></h1>
<p>در این قسمت پیرامون سه مفهوم اصلی گزارش پیشرو، یعنی مدل زبانی (LM)<sup id="fnref:15"><a class="footnote-ref" href="#fn:15">15</a></sup>، شبکه‌های عصبی مکرر و ترجمه ماشینی عصبی، به‌صورت مختصر توضیحاتی ارایه می‌گردد. </p>
<h2><strong>مدل زبانی</strong></h2>
<p>مدل زبانی یک مفهوم پایه در NLP است که امکان پیش‌بینی نشانه بعدی در یک توالی را فراهم می‌کند. به‌بیان دقیق‌تر LM عبارت است از یک توزیع احتمالی روی یک توالی از نشانه‌ها (اغلب واژه‌ها) که احتمال وقوع یک توالی داده شده را مشخص می‌کند. در نتیجه می‌توان بین چندین توالی داده شده برای مثال چند جمله، آن را که محتمل‌تر است، انتخاب کرد [5]. LM برای توالی
$$  x\quad =\quad &lt;{ x }^{ (1) },\quad { x }^{ (2) },\quad ...,\quad { x }^{ (n) }&gt; $$
عبارت است از:
<img alt="Equation 1" src="https://boute.s3.amazonaws.com/290-rel1.PNG">
مدل‌های سنتی n-gram برای غلبه بر چالش‌های محاسباتی، با استفاده از فرض مارکوف رابطه ‏(1) را به درنظر گرفتن تنها n-1 نشانه قبلی محدود می‌کنند. به‌همین دلیل برای توالی‌های طولانی (بیشتر از 4 یا 5 نشانه) و دیده نشده مناسب نیستند. مدل‌های زبانی عصبی (NLMs)<sup id="fnref:16"><a class="footnote-ref" href="#fn:16">16</a></sup> که بر مبنای شبکه‌های عصبی عمل پیش‌بینی واژه بعدی را انجام می‌دهند، در ابتدا برای کمک به n-gramها با آنها ترکیب شدند که منجر به ایجاد پیچیدگی‌های زیادی شد؛ در حالی که مشکل توالی‌های طولانی همچنان وجود داشت [5]. اخیرا اما، معماری‌های جدیدی برای LM که کاملا بر اساس DNNها است، ایجاد شده‌اند. سنگ‌بنای این مجموعه معماری‌ها RNNها بوده که در بخش بعدی معرفی می‌شوند.</p>
<h2><strong>شبکه‌های عصبی مکرر</strong></h2>
<p>شبکه‌های عصبی مکرر کلاسی از شبکه‌‌های عصبی هستند که به‌صورت یک <strong><em>گراف جهت‌دار دوری</em></strong> بیان می‌شوند. به‌عبارت دیگر ورودی هریک از لایه(های) پنهان یا خروجی علاوه بر خروجی لایه قبل، شامل ورودی از مرحله قبل به‌صورت بازخورد نیز می‌شود. شکل (2) یک RNN را نشان می‌دهد. همانطور که پیداست، لایه پنهان از مراحل قبلی هم بازخورد می‌گیرد. در هر مرحله‌زمانی t از (t=1  تا t=n) یک بردار x<sup>(t)</sup> از توالی ورودی 
$$  x\quad =\quad &lt;{ x }^{ (1) },\quad { x }^{ (2) },\quad ...,\quad { x }^{ (n) }&gt; $$
 پردازش می‌شود. در حالت کلی معادله‌های بروزرسانی (گذرجلو<sup id="fnref:17"><a class="footnote-ref" href="#fn:17">17</a></sup>) یک RNN در t عبارتند از [2]:
 <img alt="Equation 2" src="https://boute.s3.amazonaws.com/290-rel2_5.PNG">
 که در آن بردارهای b و c بایاس و ماتریس‌‌های <em>U</em>، <em>V</em> و <em>W</em> به‌ترتیب وزن یال‌‌های لایه ورودی به پنهان، پنهان به خروجی و پنهان به پنهان، تشکیل‌دهنده مجموعه پارامترهای شبکه هستند. &Phi; تابع انگیزش است که معمولا یکی از توابع ReLU<sup id="fnref:18"><a class="footnote-ref" href="#fn:18">18</a></sup> یا سیگموید<sup id="fnref:19"><a class="footnote-ref" href="#fn:19">19</a></sup> انتخاب می‌شود. لایه آخر را نیز تابع بیشینه هموار<sup id="fnref:20"><a class="footnote-ref" href="#fn:20">20</a></sup> تشکیل می‌دهد که احتمال وقوع هر نشانه خروجی را مشخص می‌کند.
<img alt="شکل (2) گراف محاسباتی مربوط به یک نوع RNN که یک توالی ورودی از مقادیر x را به یک توالی خروجی از مقادیر o نگاشت می‌کند. فرض شده است که خروجی o احتمالات نرمال نشده است، بنابراین خروجی واقعی شبکه یعنی &ycirc; از اعمال تابع بیشینه هموار روی o حاصل می‌شود. چپ: RNN به‌صورت یال بازگشتی. راست: همان شبکه به‌صورت باز شده در زمان، به‌نحوی که هر گره با یک برچسب زمانی مشخص شده است [2]." src="https://boute.s3.amazonaws.com/290-fig2.PNG">
در ‏شکل (2)، RNN با یک لایه پنهان نشان داده شده است. اما می‌توان RNNژرف با چندین لایه پنهان نیز داشت. همچنین طول توالی‌‌های ورودی و خروجی می‌تواند بسته به مسئله مورد نظر متفاوت باشد. karpathy  در [6]  RNNها را از منظر طول توالی ورودی و طول توالی خروجی به چند دسته تقسیم‌بندی کرده است. شکل (3) این دسته‌بندی را نشان می‌دهد.
<img alt="شکل (3) طرح واره‌ای از حالت‌‌های مختلف RNN. (الف):شبکه عصبی استاندارد، (ب):شبکه یک به چند، (پ): شبکه چند به یک، (ت)و (ث): شبکه‌های چند به چند [6]." src="https://boute.s3.amazonaws.com/290-fig3.PNG">
تصویر karpathy از حالت‌های مختلف RNN بعد از انتشار مقاله منتخب در این گزارش  می‌باشد؛ با این حال در بخش 4 خواهیم دید که چگونه می‌توان از ترکیب این طرح‌ها نیز برای ایده معماری توالی‌به‌تولی الهام گرفت.</p>
<h2><strong>ترجمه ماشینی عصبی</strong></h2>
<p>به‌طور کلی MT را می توان با یک LM که به جمله زبان مبدأ مشروط شده است، مدل‌سازی کرد. بر همین اساس NMT را می‌توان یک مدل زبانی مکرر در نظر گرفت که مستقیما احتمال شرطی p(y|x) را در ترجمه جمله زبان مبدأ
$$  x\quad =\quad &lt;{ x }^{ (1) },\quad { x }^{ (2) },\quad ...,\quad { x }^{ (n) }&gt; $$به جمله زبان مقصد 
$$  y\quad =\quad &lt;{y }^{ (1) },\quad { y }^{ (2) },\quad ...,\quad { y }^{ (m) }&gt; $$مدل می‌کند. دقت شود که طول جمله مبدأ یعنی n و جمله مقصد یعنی m الزاما برابر نیست. بنابراین در NMT هدف محاسبه این احتمال و سپس استفاده از آن در تولید جمله به زبان مقصد، هر دو به کمک DNNها است [5].</p>
<p><br/></p>
<h1><strong>کارهای مرتبط</strong></h1>
<p>کارهای زیادی در زمینه NLMs انجام شده است. در بیشتر این کارها از شبکه‌های عصبی روبه‌جلو یا مکرر استفاده شده و کاربرد آن معمولا در یک وظیفه MT با امتیازدهی مجدد n فهرست بهتر<sup id="fnref:21"><a class="footnote-ref" href="#fn:21">21</a></sup>، اعمال شده و نتایج آن معمولا نشان از بهبود امتیازهای قبلی داشته است [1]. 
اخیرا کارهایی در زمینه فشردن اطلاعات زبان مبدأ در NLM انجام شده است. برای نمونه Auli و همکاران [7] NLM را با مدل عنوان<sup id="fnref:22"><a class="footnote-ref" href="#fn:22">22</a></sup> جمله ورودی ترکیب کرده‌اند که نتایج بهبود بخشی داشته است. کار انجام شده در مقاله [1] به کار [8] بسیار نزدیک است. در مقاله [8] نویسندگان برای اولین بار توالی ورودی را در یک بردار فشرده کرده و سپس آن را به توالی خروجی تبدیل کردند. البته در این کار، برای تبدیل توالی به بردار، از CNNs استفاده شده که ترتیب واژه‌ها را حفظ نمی‌کند. چُـــو و همکاران [9] یک معماری شبهِ LSTM را برای نگاشت توالی ورودی به بردار و سپس استخراج توالی خروجی و نهایتا ترکیب آن با SMT استفاده کرده‌اند. معماری آنها از دو RNN با عنوان‌های کدگذار و کدگشا تشکیل شده که RNN اول وظیفه تبدیل یک توالی با طول متغیر به یک بردار با طول ثابت را قابل یک سلول زمینه c دارد و RNN دوم وظیفه تولید توالی خروجی را با لحاظ کردن c و نماد شروع جمله مقصد بر عهده دارد. معماری پیشنهادی آنها تحت عنوان کلی  RNNکدگذار-کدگشا در ‏شکل (4) نشان داده شده است. چون آنها از LSTM استفاده نکرده و بیشتر تلاش خود را معطوف به ترکیب این روش با مدل‌های قبلی SMT کرده‌اند، برای توالی‌های ورودی و خروجی طولانی همچنان مشکل عدم حفظ حافظه وجود دارد.
Bahdanau و همکاران [10] یک روش ترجمه مستقیم با استفاده از شبکه عصبی پیشنهاد داده‌اند که از سازوکار <em>attention</em> برای غلبه بر کارآمدی ضعیف روش [9] روی جملات طولانی استفاده می‌کند و به نتایج مطلوبی دست یافتند. </p>
<p><img alt="شکل (4) مدل RNN کدگذار-کدگشا، که برای یادگـیری تولید توالی خروجی  y  از روی توالی ورودی x  با استخراج سلول حافظه c از توالی ورودی، به‌کار می‌رود [2]." src="https://boute.s3.amazonaws.com/290-fig4.PNG"></p>
<p><br/></p>
<h1><strong>مدل توالی‌به‌توالی</strong></h1>
<p>در مدل توالی‌به‌توالی از دو RNN با واحدهای LSTM استفاده شده است. هدف LSTM در اینجا تخمین احتمال شرطی
$$ p(&lt;{ y }^{ (1) },\quad ...,\quad { y }^{ (m) }&gt;\quad |\quad &lt;{ x }^{ (1) },\quad ...,\quad { x }^{ (n) }&gt;) $$ 
است که قبلا هم دیده بودیم (بخش 2-3). LSTM این احتمال شرطی را ابتدا با اقتباس بازنمایی بعد ثابت v برای توالی ورودی
$$ &lt;{ x }^{ (1) },\quad ...,\quad { x }^{ (n) }&gt; $$
از آخرین مقدار حالت پنهان و در ادامه با محاسبه احتمال 
$$&lt;{ y }^{ (1) },\quad ...,\quad { y }^{ (m) }&gt; $$ 
از رابطه استاندارد مطرح در LM (رابطه (1)) و درنظر گرفتن  برای حالت پنهان آغازین به‌صورت داده شده در رابطه زیر، حساب می‌کند:
<img alt="Equation 6" src="https://boute.s3.amazonaws.com/290-rel6.PNG">
در رابطه ‏(6) هر توزیع احتمالی 
$$ p({ y }^{ (t) }\quad |\quad v,\quad y^{ (1) },\quad ...,\quad y^{ (t-1) }) $$
به‌وسیله یک تابع بیشینه هموار روی همه واژه‌های داخل واژه‌نامه بازنمایی می‌شود. برای LSTM از روابط [11] استفاده شده است. هر جمله در این مدل نیاز است تا با یک علامت خاص مثل EOS خاتمه یابد. این امر مدل را قادر می‌سازد تا بتواند توزیع احتمالی را روی توالی با هر طول دلخواهی تعریف کند. شمای کلی مدل در شکل (1) نشان داده شده است. در این شکل LSTM بازنمایی توالی ورودی 
$$ &lt;'A','B','C',EOS&gt; $$را حساب و سپس از این بازنمایی برای محاسبه احتمال توالی خروجی<br>
$$ &lt;'W','X','Y','Z',EOS&gt;  $$
استفاده می‌کند. در عین حال این مدل را می‌توان ترکیبی از قسمت‌های پ و ت شکل (3) دانست.
مدل پیاده‌سازی شده در عمل از سه جنبه با مدل معرفی شده در بالا تفاوت دارد. اول، از دو LSTM جداگانه استفاده شده است: یکی برای توالی ورودی و دیگری برای توالی خروجی؛ زیرا، انجام این کار پارامترهای مدل را با هزینه محاسباتی اندکی، به تعداد بسیار زیادی افزایش می‌دهد. دوم اینکه LSTMهای ژرف به‌شکل قابل توجهی LSTMهای سطحی را شکست می‌دهند، به همین دلیل LSTM با ژرفای چهار لایه به‌کار گرفته شده است. سوم اینکه نویسندگان در این مقاله یافته‌اند که وارون کردن توالی ورودی در سرعتِ همگرایی آموزش شبکه و نیز دقت پیش‌بینی آن تأثیر شگرفی ایفا می‌کند. بنابراین به‌جای نگاشت مستقیم توالی  a,b,c  به توالی &alpha;, &beta;, &gamma;  شبکه LSTM برای نگاشت c,b,a به &alpha;, &beta;, &gamma; آموزش داده می‌شود که در آن &alpha;, &beta;, &gamma;  ترجمه یا خروجی متناظر با همان a,b,c است. توجیه علت این پدیده آن است که در نگاشت به شیوه وارون ابتدای عبارت‌ها که متناظر با یکدیگر هستند به‌هم نزدیک شده و این امر سبب زودتر همگرا شدن الگوریتم  کاهش گرادیان تصادفی (SGD) و نزدیک شدن به مقادیر بهینه می‌شود [1].</p>
<h2><strong>آموزش شبکه</strong></h2>
<p>مدل توالی‌‌به‌توالی پس از معرفی توسط Sutskever و همکاران [1]، بارها و بارها تا به امروز مورد ارجاع دیگران قرار گرفته و تبدیل به یک مدل مرجع در NMT شده است. این مدل در رساله دکتری آقای لانگ [5] به‌تفصیل و همراه با برخی اصلاحات توضیح داده شده است. در این بخش به برخی جزئیات آموزش شبکه مدل توالی‌به‌توالی می‌پردازیم.
شکل (5) یک نمایش دقیق‌تر از مدل ذکر شده در شکل (1) را نشان می‌دهد. آموزش شبکه بدین نحو است: ابتدا جمله زبان مقصد، سمت راست جمله متناظر خود در زبان مبدأ قرار داده می‌شود. نشان ‘-‘ در اینجا نقش EOS را دارد که البته می‌تواند پایان جمله مبدأ یا آغاز جمله مقصد را مشخص کند. بنابراین به هر کدام از دو گروه قابل تعلق است. LSTM سمت چپ یا همان شبکه کدگذار، در هر مرحله‌زمانی یک واژه از جمله زبان مبدأ را خوانده پس از تبدیل به نمایش مناسب حالت داخلی لایه پنهان را بروزرسانی می‌کند. در مرحله پردازش آخرین واژه مقادیر لایه‌های پنهان بردار ثابت که اکنون نماینده کل جمله ورودی زبان مبدأ است را تشکیل می‌دهد. سپس LSTM دوم یا شبکه کدگشا اولین واژه زبان مقصد را به همراه بردار v، به‌عنوان ورودی دریافت می‌کند و پیشبینی خود را انجام می‌دهد. برچسب واقعی این داده در واقع واژه بعدی در جمله زبان مقصد است. پس از مقایسه و محاسبه خطا، الگوریتم پس‌انتشار روی هر دو شبکه با شروع از شبکه کدگشا اجرا می‌شود و پارامترها را در خلاف جهت گرادیان تنظیم می‌کند. این روند تا پایان یافتن جمله زبان مقصد ادامه پیدا می‌کند. البته در عمل ممکن است ورودی به صورت یک دسته<sup id="fnref:23"><a class="footnote-ref" href="#fn:23">23</a></sup> به شبکه داده شده و گرادیان روی کل آن دسته حساب شود. به بیان دیگر در مجموع، شبکه کدگشا آموزش داده می‌شود تا جمله زبان مقصد را به همان جمله زبان مقصدی تبدیل کند که فقط واژه‌های آن یک واحد نسبت به جمله ورودی به سمت جلو جابه‌جا شده‌اند. این روش اصطلاحا teacher forcing نامیده می‌شود [2] و زمانی مناسب است که جمله زبان مقصد (توالی خروجی) کاملا مشخص باشد. در واقع واژه بعدی به عنوان برچسب در فرایند آموزش بانظارت مورد استفاده قرار می‌گیرد و وزن‌ها بر اساس آن تنظیم می‌گردند.
<img alt="شکل (5) نمایش نحوه عملکرد و آموزش مدل‌ توالی‌‌به‌توالی روی وظیفه ترجمه ماشینی عصبی  [5]." src="https://boute.s3.amazonaws.com/290-fig5wc.PNG"></p>
<p>در مرحله استنتاج<sup id="fnref:27"><a class="footnote-ref" href="#fn:27">27</a></sup> یعنی هنگامی که می‌خواهیم جمله ناشناخته زبان مقصد (توالی خروجی) را کدگشایی نماییم، فرایند شرح داده شده در بالا، با اندکی تفاوت و در قالب گام‌های زیر انجام می‌پذیرد:
1. توالی ورودی با استفاده از شبکه کدگذار به بردار محتوا بدل می‌گردد. در صورتی که از سلول LSTM استفاده شود بردار محتوا برای هر لایه از شبکه حاوی دو متغیر حالت خواهد بود و در صورت استفاده از سلول GRU بردار محتوا برای هر لایه از شبکه دارای یک متغیر است.
2.  یک توالی با اندازه ورودی 1 که ابتدا حاوی نشانه شروع جمله زبان مقصد است در ورودی شبکه کدگشا قرار داده می‌شود.
3.  بردار محتوای حاصل شده از مرحله 1 به همراه توالی مرحله 2 به شبکه کدگشا داده می‌شوند تا نشانه (در اینجا واژه) بعدی جمله زبان مقصد پیش‌بینی شود.
4. از پیش‌بینی مرحله 4 نمونه برداری شده (به یکی از روش‌های حریصانه یا جست‌وجوی پرتوی محلی که در ادامه توضیح داده خواهد شد) و واژه بعدی انتخاب می‌شود.
5. واژه انتخاب شده در مرحله 4 به جمله زبان مقصد (توالی خروجی) الحاق می‌شود.
6. واژه انتخاب شده در مرحله 4 به جای نشانه شروع جمله به شبکه کدگشا داده می‌شود و مراحل 3 و 4 و 6 تکرار می‌شوند تا زمانی که نشانه پایان جمله تولید شود یا اینکه طول جمله تولید شده از یک حد از پیش تعیین شده بیشتر شود.
نکته لازم به ذکر دیگر آن است که توالی ورودی انتخاب شده در این مرحله از مجوعه آزمون انتخاب می‌شود. در واقع مرحله استنتاج روی داده‌های آزمون و برای ارزیابی مدل انجام می‌پذیرد.</p>
<h2><strong>جزئیات آموزش شبکه</strong></h2>
<p>در مقاله [1] از LSTMژرف با چهار لایه و 1000 سلول حافظه در هر لایه استفاده شده است. همچنین اندازه واژگان ورودی 160هزار و اندازه واژگان خروجی 80هزار کلمه است. حاصل کار یک شبکه LSTM با مجموع 380میلیون پارامتر بوده که 64میلیون آن اتصالات برگشتی هستند. دیگر جزئیات پارامترها و آموزش شبکه عبارتند از:</p>
<ul>
<li>پارامترها با مقادیر تصادفی از توزیع یکنواخت در بازه [0.08+ و 0.08-] مقداردهی اولیه شده‌اند.</li>
<li>برای آموزش از SGD استاندارد با نرخ یادگیری 0.7 استفاده شده است. بعد از گذشت پنج دوره<sup id="fnref:24"><a class="footnote-ref" href="#fn:24">24</a></sup>، نرخ یادگیری در هر نیم‌دور، نصف می‌شود. در ضمن تعداد کل دوره‌های آموزش برابر 7.5 بوده است.</li>
<li>گرادیان بر روی دسته‌های 128تایی از توالی‌ها محاسبه شده و به اندازه دسته، یعنی 128، تقسیم می‌شود.</li>
<li>هرچند LSTMها از معضل میرایی گرادیان<sup id="fnref:25"><a class="footnote-ref" href="#fn:25">25</a></sup> رنج نمی‌برند، اما ممکن است مشکل انفجار گرادیان<sup id="fnref:26"><a class="footnote-ref" href="#fn:26">26</a></sup> را داشته باشند. بنابراین محدودیت سختی بر مقدار نورم گرادیان اعمال می‌شود به‌این نحو که هنگامی که نورم از مقدار آستانه‌ای بیشتر شد، مجددا تنظیم شود. برای هر دسته در مجموعه آموزش مقدار 
$$ s={ ||g|| }_{ 2 }$$</li>
</ul>
<p>محاسبه می‌شود که در آن g مقدار گرادیان پس از تقسیم بر 128 است. اگر  s&gt;5 شد آنگاه قرار داده می‌شود:
$$ g=\frac { 5g }{ s }. $$ 
+ جملات مختلف طول‌های مختلفی دارند. بیشتر آنها کوتاه هستند (طولی بین 20 تا 30 دارند) اما برخی از آنها طولانی هستند (طولی بیشتر از 100 دارند)؛ بنابراین دسته‌های 128تایی از جملات که تصادفی انتخاب می‌شوند تعداد کمی جمله طولانی داشته و تعداد زیادی جمله کوتاه و در نتیجه سبب می‌شود تا بیشتر محاسبات داخل هر دسته هدر روند. برای غلبه بر این موضوع سعی شده است همه جملات داخل یک دسته طول تقریبا مساوی داشته باشند. این امر انجام محاسبات را تا 2 برابر تسریع کرده ‌است.</p>
<p><br/></p>
<h1><strong>آزمایش‌ها</strong></h1>
<p>روش یادگیری توالی‌به‌توالی معرفی شده روی وظیفه ترجمه ماشینی انگلیسی به فرانسوی در دو حالت مختلف آزمایش گردیده است. در حالت اول مدل، برای ترجمه مستقیم جملات انگلیسی به فرانسوی به‌کار گرفته شده و در حالت دوم برای امتیاز دهی مجدد n فهرست بهتر از جملات در وظیفه SMT استفاده شده است. در این قسمت نتایج آزمایش‌های انجام گرفته در قالب امتیازهای ترجمه کسب شده، نمونه جملات ترجمه شده و بلاخره مصورسازی بازنمایی جملات ورودی، بیان شده است.</p>
<h2><strong>پیاده‌سازی</strong></h2>
<p>پیاده‌سازی مدل اولیه با زبان ++C انجام شده است. این پیاده‌سازی از LSTM ژرف با پیکربندی شرح داده شده در بخش 4-1-2 روی یک GPU، تقریبا 1700 واژه بر ثانیه را پردازش می‌کند. این سرعت برای پردازش حجم داده  زیادی مثل مجموعه WMT بسیار پایین است. برای این منظور مدل به صورت موازی شده روی 8 عدد GPU اجرا می‌گردد. هر لایه از LSTM روی یک GPU اجرا شده و فعالیت‌های خود را به محض محاسبه به GPU یا لایه بعدی می‌دهد. چون مدل چهار لایه دارد، چهار GPU دیگر برای موازی‌سازی بیشینه هموار استفاده شده‌اند بنابراین هر GPU مسئول محاسبه یک ضرب ماتریسی (ماتریس با اندازه 2000 × 1000) است. نتیجه حاصل از این موازی‌سازی در سطح GPU، رسیدن به سرعت پردازش 6300 واژه بر ثانیه است. فرایند آموزش در این شیوه پیاده‌سازی، 10 روز به طول انجامید [1].
علاوه بر پیاده‌سازی اولیه، پیاده‌سازی‌های دیگری نیز از این مدل در زبان‌ها و چهارچوب‌های مختلف ارایه شده است؛ از جمله دو پیاده‌سازی خوب با زبان پایتون و روی چهارچوب‌های کاری Tensorflow و Keras. پیاده‌سازی Tensorflow سازوکارهای جدیدتر مثل سازوکار <em>attention</em> را نیز اضافه کرده است [12]. پیاده‌سازی Keras هم به جای واژه، در <strong>سطح کاراکتر</strong> انجام شده است [13]. اگرچه در همه پیاده‌سازی‌ها  ترجمه ماشینی، به‌عنوان وظیفه انتخاب شده است. اما این مدل عام بود و برای هر وظیفه‌ای که شامل نگاشت یک توالی ورودی به یک توالی خروجی با طول‌های متفاوت است، قابل اعمال خواهد بود.</p>
<h2><strong>جزئیات مجموعه داده</strong></h2>
<p>همانطور که قبلا گفته شد (بخش ‏3-1) از مجموعه داده ترجمه انگلیسی به فرانسوی WMT’14 در آزمایش‌ها استفاده شده است [3]. مدل توصیف شده روی یک زیرمجموعه 12میلیون جمله‌ای، شامل 348میلیون واژه فرانسوی و 340میلیون واژه انگلیسی، آموزش داده شده است. وظیفه ترجمه ماشینی و همچنین این مجموعه داده خاص، به خاطر دردسترس بودن عمومی یک مجموعه آموزش و یک مجموعه آزمون نشانه‌گذاری شده<sup id="fnref:29"><a class="footnote-ref" href="#fn:29">28</a></sup> جهت اهداف آموزش و ارزیابی مدل انتخاب شده است و مدل توالی‌به‌تولی مستقل از یک وظیفه خاص است.
همچنان‌که مدل‌های زبانی عصبی معمولی روی یک بازنمایی برداری در نمایش هر کلمه تکیه می‌کنند، در اینجا نیز یک واژه‌نامه با اندازه ثابت، برای هر دو زبان به‌کار گرفته شده است. برای این منظور، 160هزار واژه از پر استفاده‌ترین واژه‌های زبان مبدأ (انگلیسی) و نیز 80هزار واژه از پر استفاده‌ترین واژه‌های زبان مقصد (فرانسوی) برگزیده شده‌اند. هر واژه خارج از این واژه‌نامه‌ها که در جمله‌ها ظاهر شده باشد، با نشانه خاص “UNK” جایگزین شده است.
برای پیاده‌سازی [12] از مجموعه داده ترجمه آلمانی-انگلیسی WMT’16 [14] استفاده شده است و همچنین مدل نمونه پیاده‌سازی شده در [13] از مجموعه داده کوچکتر موجود در [4] استفاده کرده است که قابل جایگزین کردن با مجموعه‌های ذکر شده در بالا نیز هست. ایراد اساسی پیاده‌سازی در سطح کاراکتر [13] این است که معمولا در ترجمه ماشینی واژه‌ها به یکدیگر متناظر می‌شوند نه کاراکترها لذا این مدل از دقت مدل‌های در سطح واژه برخوردار نیست اما ایده خوبی در مورد استفاده در سایر وظایف مبتنی بر نگاشت توالی‌به‌توالی نظیر تولید متن به دست می‌دهد.</p>
<h2><strong>کدگشایی و امتیازدهی مجدد</strong></h2>
<p>هسته اصلی آزمایش‌های انجام شده در [1]، آموزش یک LSTM ژرف بزرگ روی تعداد زیادی جفت از جمله‌های زبان مبدأ و زبان مقصد است. آموزش با بیشینه کردن احتمال لگاریتمی یک ترجمه صحیح T برای جمله مبدأ داده شده S انجام می‌شود. بنابراین هدف آموزش عبارت است از:
<img alt="Equation 7" src="https://boute.s3.amazonaws.com/290-rel7.PNG">
که در آن <strong>S</strong> مجموعه آموزش است. وقتی آموزش کامل شد، ترجمه‌ها با یافتن درست‌ترین ترجمه از روی LSTM تولید می‌شوند:
<img alt="Equation 8" src="https://boute.s3.amazonaws.com/290-rel8.PNG">
برای یافتن درست‌ترین ترجمه از یک کدگشای ساده با جست‌وجوی پرتوی محلی<sup id="fnref:30"><a class="footnote-ref" href="#fn:30">29</a></sup> چپ به راست استفاده شده است که تعداد B فرضیه جزئی<sup id="fnref:31"><a class="footnote-ref" href="#fn:31">30</a></sup> را نگه‌داری می‌کند. هر فرضیه جزئی پیشوندی از تعدادی ترجمه است. در هر مرحله زمانی، هر فرضیه جزئی با واژه‌های محتمل از داخل واژه‌نامه گسترش داده می‌شود. این روند تعداد فرایض جزئی را به‌سرعت افزایش می‌دهد. با توجه به مدل احتمال لگاریتمی، تمام این فرضیه‌ها به غیر از B فرضیه محتمل اول کنار گذاشته می‌شوند. به‌مجرد اینکه نشانه “EOS” به یک فرضیه الصاق شد، از جست‌وجوی پرتوی محلی حذف و به مجموعه فرایض کامل افزوده می‌گردد. هرچند این روش کدگشایی تقریبی است؛ اما، برای پیاده‌سازی راحت خواهد بود. سیستم پیشنهادی حتی با اندازه پرتوی 1 و نیز اندازه پرتوی 2 بیشترین مزایای این روش جست‌وجو را فراهم می‌آورد. امتیازهای BLEU حاصله از آزمایش‌های انجام شده روی مدل، در جدول (1) ذکر شده‌ است.</p>
<h2><strong>وارون‌سازی جملات مبدأ</strong></h2>
<p>درحالی‌که LSTM قابلیت حل مسائل با وابستگی‌های طولانی مدت را دارد، در طول آزمایش‌های انجام شده در [1] پژوهشگران یافته‌اند که وقتی جمله‌های مبدأ وارون شده و به‌عنوان ورودی به  شبکه کدگذار داده می‌شوند، LSTM بهتر آموزش می‌بیند. توجه شود که جملات مقصد وارون نمی‌شوند. با انجام این عمل ساده، مقدار سرگشتگی<sup id="fnref:32"><a class="footnote-ref" href="#fn:32">31</a></sup> مدل از 5.8 به 4.7 کاهش یافته‌است و مقدار امتیاز BLEU کسب شده از ترجمه‌های کدگشایی شده مدل نیز از 25.9 به 30.6 افزایش داشته است.
نویسندگان [1] توضیح کاملی برای توجیه اثر این پدیده نداشته‌اند. توجیه اولیه آنها بدین ترتیب است که عمل وارون‌سازی جملات زبان مبدأ باعث معرفی بسیاری از وابستگی‌های کوتاه مدت به مجموعه داده می‌شود. وقتی جمله‌های زبان مبدأ را با جمله‌های زبان مقصد الحاق می‌کنیم، هر واژه در جمله مبدأ از واژه نظیرش در جمله مقصد دور می‌افتد. در نتیجه، مسئله یک دارای یک <em>تأخیر زمانی کمینه</em><sup id="fnref:33"><a class="footnote-ref" href="#fn:33">32</a></sup> خیلی بزرگ می‌شود [1]. با وارون‌سازی واژه‌ها در جمله مبدأ فاصله میانگین بین واژه‌های نظیر به نظیر در جمله‌ مبدأ با جمله مقصد تغییر نمی‌کند. هرچند تعداد کمی از واژه‌های آغازین جمله مبدأ در این حالت به واژه‌های آغازین جمله مقصد بسیار نزدیک می‌شوند؛ بنابراین تأخیر زمانی کمینه مسئله تا حد زیادی کاهش می‌یابد و الگوریتم پس‌انتشار زمان کمتری را برای استقرار ارتباط میان واژه‌های جمله‌های مبدأ و جمله‌های مقصد سپری خواهد نمود. این امر درنهایت منجربه بهبود قابل توجه کارآمدی کلی مدل می‌گردد.
ایده وارون‌سازی جمله‌های ورودی از این مهم نشئت گرفته است که در ابتدا تصور شده وارون‌سازی فقط به پیش‌بینی با اطمینان‌تر واژه‌های آغازین در زبان مقصد کمک می‌کند و منجربه پیش‌بینی کم اطمینان‌تر واژه‌های پایانی می‌شود. هرچند LSTMای که روی جملات مبدأ وارون شده آموزش دیده، در مقایسه با LSTM معمولی، روی جمله‌های طولانی عملکرد بهتری از خود نشان داده است (رجوع شود به بخش ‏1-6). </p>
<h2><strong>ارزیابی نـتایج</strong></h2>
<p>به‌منظور ارزیابی کیفیت ترجمه‌های صورت گرفته توسط مدل از روش امتیازدهی خودکار BLEU [16] استفاده شده است. برای محاسبه امتیاز BLEU، اسکریپت آماده multi-bleu.pl<sup id="fnref:34"><a class="footnote-ref" href="#fn:34">33</a></sup> به‌کار رفته است. این نوع امتیاز دهی در کارهای قبلی مشابه نیز استفاده شده است [9] و [10]، بنابراین قابل اطمینان خواهد بود و مقایسه مدل‌ها را امکان‌پذیر می‌سازد. به‌عنوان نمونه، این اسکریپت برای [10] امتیاز 28.45 را تولید کرده است. نتایج در جدول‌های (1) و (2) ارایه شده‌اند. بهترین نتیجه از مجموعه LSTMهایی که در مقداردهی اولیه تصادفی و ترتیب تصادفی ریزدسته‌ها تفاوت داشته‌اند، حاصل شده است. هرچند سازوکار کدگشایی ترجمه به‌کار برده شده در اینجا (جست‌وجوی پرتوی محلی)، سازوکار ساده و ضعیفی است؛ با این حال نخستین بار است که یک سیستم ترجمه ماشینی عصبی خالص، سیستم ترجمه ماشینی مبتنی بر عبارات را با اختلاف قابل توجهی شکست می‌دهد. این سیستم همچنین فاقد قابلیت کنترل واژه‌های خارج از واژه‌نامه است و همان‌طور که قبلا هم بیان شد کلیه واژه‌های بیرون از واژه‌نامه با واژه “UNK” جایگزین شده‌اند. بنابراین در صورتی که سازوکاری برای کنترل این واژه‌ها نیز به مدل اضافه شود یا اندازه واژه‌نامه افزایش یابد، عملکرد این سیستم باز هم جای بهبود خواهد داشت.</p>
<p><br/></p>
<p align="center">
جدول (1) کارآمدی LSTM روی مجموعه آزمون ترجمه انگلیسی به فرانسوی WMT’14 (ntst14). توجه شود که یک مجموعه متشکل از پنج LSTM با اندازه پرتوی 2، ارزان‌تر (سبک‌تر) از یک LSTM تنها با اندازه پرتوی 12 است [1].
</p>

<table>
<thead>
<tr>
<th style="text-align: center;"><strong>روش</strong></th>
<th style="text-align: center;"><strong>امتیاز BLEU (ntst14)</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">Bahdanau و همکاران [10]</td>
<td style="text-align: center;">28.45</td>
</tr>
<tr>
<td style="text-align: center;">یک LSTM روبه‌جلو، اندازه پرتوی 12</td>
<td style="text-align: center;">26.17</td>
</tr>
<tr>
<td style="text-align: center;">یک LSTM با ورودی وارون، اندازه پرتوی 12</td>
<td style="text-align: center;">30.59</td>
</tr>
<tr>
<td style="text-align: center;">پنج LSTM با ورودی وارون، اندازه پرتوی 1</td>
<td style="text-align: center;">33.00</td>
</tr>
<tr>
<td style="text-align: center;">دو LSTM با ورودی وارون، اندازه پرتوی 12</td>
<td style="text-align: center;">33.27</td>
</tr>
<tr>
<td style="text-align: center;">پنج LSTM با ورودی وارون، اندازه پرتوی 21</td>
<td style="text-align: center;">34.50</td>
</tr>
<tr>
<td style="text-align: center;">پنج LSTM با ورودی وارون، اندازه پرتوی 12</td>
<td style="text-align: center;"><strong>34.81</strong></td>
</tr>
</tbody>
</table>
<p><br/></p>
<p align="center">
جدول (2) روش‌های مشابه که شبکه‌های عصبی را در کنار ترجمه ماشینی سنتی روی مجموعه داده WMT’14 در ترجمه انگلیسی به فرانسوی استفاده کرده‌اند [1].
</p>

<table>
<thead>
<tr>
<th style="text-align: center;"><strong>روش</strong></th>
<th style="text-align: center;"><strong>امتیاز BLEU (ntst14)</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">لـبه پژوهش [15]</td>
<td style="text-align: center;"><strong>37.00</strong></td>
</tr>
<tr>
<td style="text-align: center;">چــو و همکاران [9]</td>
<td style="text-align: center;">34.54</td>
</tr>
<tr>
<td style="text-align: center;">امتیازدهی مجدد 1000فهرست بهتر با یک LSTM روبه‌جلو</td>
<td style="text-align: center;">35.61</td>
</tr>
<tr>
<td style="text-align: center;">امتیازدهی مجدد1000فهرست بهتر با یک LSTM وارون</td>
<td style="text-align: center;">35.85</td>
</tr>
<tr>
<td style="text-align: center;">امتیازدهی مجدد1000فهرست بهتر با پنج LSTM وارون</td>
<td style="text-align: center;"><strong>36.50</strong></td>
</tr>
<tr>
<td style="text-align: center;">پیش‌گویی امتیازدهی مجدد 1000فهرست بهتر</td>
<td style="text-align: center;">45~</td>
</tr>
</tbody>
</table>
<h2><strong>تحلیل مدل</strong></h2>
<p>یکی از ویژگی‌های جذاب مدل توالی‌به‌توالی ارایه شده در [1]، توانایی تبدیل یک توالی از واژه‌ها به یک بردار با ابعاد ثابت است. شکل (6) تعدادی از بازنمایی‌های یادگرفته شده در روند آموزش را مصورسازی کرده است. این تصویر به وضوح نشان می‌دهد که بازنمایی‌های ایجاد شده به ترتیب واژه‌ها حساس هستند؛ زیرا از جمله‌هایی با واژه‌های یکسان و ترتیب متفاوت در تصویر استفاده شده است. بازنمایی واقعی مدل در ابعاد بالاتری بود و برای نگاشت روی دو بعد روش PCA به‌کار برده شده است.</p>
<p><img alt="شکل (6) این شکل یک تصویر PCA دوبعدی از حالت‌های پنهان LSTM را نشان می‌دهد که پس از پردازش جمله‌های نشان داده شده در شکل، گرفته شده است. عبارات با توجه به معنایشان خوشه‌بندی شده‌اند که معنا در این مثال به طور عمده تابعی از ترتیب ظاهر شدن واژه‌ها در عبارت است. رسیدن به چنین خوشه‌بندی با روش‌های سنتی موجود، سخت است. توجه شود که در همه جمله‌ها واژه‌های یکسانی استفاده شده و تنها ترتیب ظاهر شدن آنها،  تفاوت ایجاد کرده است [1]. دایره‌های کوچک در شکل اعداد دو بعد تصویر شده جمله را نشان می‌دهند." src="https://boute.s3.amazonaws.com/290-fig6.PNG"></p>
<h2><strong>کارآمدی روی جملات طولانی</strong></h2>
<p>خروجی مدل روی جمله‌های طولانی (از منظر تعداد واژه) کارآمدی بسیار خوب LSTM را در این زمینه تأیید می‌کند. یک مقایسه کمی از نتایج حاصل شده در شکل (7) نشان داده شده است. همچنین جدول (3) چندین جمله طولانی و ترجمه‌های تولید شده توسط مدل برای آنها را ارایه می‌کند. 
<br/></p>
<p><img alt="شکل (7) نمودار سمت چپ کارآمدی سیستم را به‌عنوان تابعی از طول جمله‌ها نشان می‌دهد که محور افقی در آن طول واقعی جمله‌ها بر حسب تعداد واژه‌های آنها است. کاهش امتیازی در جملاتی با طول کمتر از 35 واژه وجود ندارد. تنها یک کاهش جزئی در جمله‌های خیلی طولانی مشاهده می‌شود. نمودار سمت راست کارآمدی LSTM را روی جمله‌هایی با واژه‌های کمتر به‌کار رفته نشان می‌دهد که محور افقی در آن جمله‌های آزمایش شده برحسب میانگین تکرار واژه‌هایشان است [1]." src="https://boute.s3.amazonaws.com/290-fig7.PNG"></p>
<p align="center">جدول (3) سه مثال از ترجمه‌های طولانی تولید شده توسط مدل توالی‌به‌توالی در مقایسه با ترجمه صحیح. خواننده می‌تواند صحت نتایج را با استفاده از مترجم گوگل تا حد خوبی درک کند [1].</p>

<p><img alt="Table 3" src="https://boute.s3.amazonaws.com/290-table3.PNG"></p>
<p><br/></p>
<h1><strong>نتیجه‌گیری و کارهای آتی</strong></h1>
<p>در این گزارش یک مدل یادگیری ژرف جدید برای یادگیری و نگاشت توالی از ورودی‌ها به توالی از خروجی‌ها مطرح و بحث گردید. نشان داده شد که یک شبکه LSTM ژرف با واژگان محدود روی وظیفه ترجمه ماشینی، قادر به شکست سیستم‌های ترجمه ماشینی استاندارد مبتنی بر عبارات با واژگان نامحدود است. موفقیت این رویکرد نسبتا ساده روی وظیفه ترجمه ماشینی نشان دهنده این است که این مدل باید روی دیگر وظیفه‌های مبتنی بر توالی نیز در صورت فراهم بودن مجموعه داده‌های آموزش کافی، بسیار خوب عمل کند.
در طی فرایند آموزش این اصل نیز کشف شده که وارون سازی توالی مبدأ سبب افزایش دقت و بهبود کارآمدی مدل می‌شود. می‌توان نتیجه گرفت پیدا کردن روشی که وابستگی‌های کوتاه مدت را زودتر معرفی کند در هر صورت آموزش مدل را خیلی ساده‌تر می‌کند. لذا به نظر می‌رسد که حتی آموزش یک RNN استاندارد (مدل غیر توالی‌به‌توالی) نیز با این روش بهتر باشد. البته این مورد در عمل مورد آزمایش قرار نگرفته است و بنابراین به صورت یک فرضیه باقی است.
نتیجه قابل ذکر دیگر، قابلیت LSTM در یادگیری صحیح ترجمه توالی‌های طولانی است. در ابتدا تصور می‌شد که LSTM به دلیل حافظه محدود خود در یادگیری جمله‌های طولانی شکست بخورد؛ همچنان‌که پژوهشگران دیگر در کارهای مشابه عملکرد ضعیفی را برای LSTM گزارش کرده بودند. با این حال اما روی جمله‌های خیلی طولانی در حالت وارون همچنان مشکل تضعیف حافظه پابرجاست و احتمالا قابلیت بهبود داشته باشد.   در نهایت نتایج رضایت بخش این مدل یادگیری نشان دهنده این است که یک مدل ساده از شبکه‌های عصبی ژرف، که هنوز جای بهبود و بهینه‌سازی‌های زیادی در خود دارد، قادر به شکست بالغ‌ترین سیستم‌های ترجمه ماشینی سنتی است. کارهای آتی می‌تواند بر روی افزایش دقت مدل توالی‌به‌توالی و پیچیده‌تر کردن آن در راستای یادگیری بهتر توالی‌های طولانی باشد. در آینده نزدیک این مدل‌ها روش‌های سنتی را کاملا منسوخ می‌کنند. نتایج همچنین نشان می‌دهد این رویکرد روی دیگر وظیفه‌های مبتنی بر نگاشت توالی‌به‌توالی می‌تواند موفقیت آمیز ظاهر شود. این مهم، زمینه را برای حل مسائل مختلفی در دیگر حوزه‌های علوم آماده می‌سازد.
می‌توان از این مدل برای ترجمه ماشینی متون طولانی انگلیسی به فارسی و بالعکس استفاده کرد در این وظیفه اثر وارون‌سازی جمله زبان مبدأ باید بررسی شود؛ زیرا، به نظر می‌رسد در زبان‌های از راست به چپ با این کار تأخیر زمانی کمینه افزایش پیدا ‌کند و نتیجه بدتری حاصل شود.
در وظایف دیگر مثل سیستم پرسش و پاسخ نیز می‌توان از این مدل استفاده کرد. در تولید محتوا و برای کامل کردن متون تاریخی و اشعاری که بخش‌هایی از آنها وجود ندارد یا از بین رفته است استفاده از این مدل جالب و ارزشمند به نظر می‌رسد.
علاوه بر استفاده در وظایف جدید، تغییر معماری خود مدل نیز، جهت افزایش دقت وظایف نام برده پیشنهاد می‌شود. برای مثال استفاده از RNN دوسویه، ترکیبی
و نیز دارای حالت در شبکه کدگذار و کدگشا، استفاده از ژرفای بیشتر لایه‌ها، تغییر دیگر ابرپارامترهای شبکه نظیر نرخ آموزش و افزودن سازوکار توجه می‌تواند از جمله پیشنهادهایی باشد که در ساختن مدل‌های با دقت بیشتر قابل استفاده هستند. همچنین برای مواردی که داده‌های برچسب‌دار به اندازه کافی موجود نیستند یا تمامی توالی خروجی یکجا دردسترس نیست (مثل یادگیری برخط یا یادگیری تقویتی)، استفاده از روش بیان شده در مرحله استنتاج به هنگام آموزش، به جای teacher forcing راهکار مناسبی به نظر می‌رسد. </p>
<p><br/></p>
<p><strong><h2>مراجع</h2></strong></p>
<p>[1]      Q.V. Le Ilya Sutskever, Oriol Vinyals, I. Sutskever, O. Vinyals, and Q. V. Le, “Sequence to sequence learning with neural networks,” <em>Nips</em>, pp. 1–9, 2014.
[2]      I. Goodfellow, Y. Bengio, and A. Courville, <em>Deep learning</em>. MIT Press, 2016.
[3]      “ACL 2014 ninth workshop on statistical machine translation.” [Online]. Available: http://www.statmt.org/wmt14/medical-task/index.html. [Accessed: 13-Nov-2017].
[4]      “Tab-delimited bilingual bentence pairsfrom the tatoeba project (good for anki and similar flashcard applications).”[Online]. Available: http://www.manythings.org/anki/. [Accessed: 13-Nov-2017].
[5]      M. T. Luong, “Neural machine translation,” Stanford university, 2016.
[6]      A. Karpathy, “Connecting images and natural language,” Stanford University, 2016.
[7]      M. Auli, M. Galley, C. Quirk, and G. Zweig, “Joint language and translation modeling with recurrent neural networks.,” <em>Emnlp</em>, no. October, pp. 1044–1054, 2013.
[8]      N. Kalchbrenner and P. Blunsom, “Recurrent continuous translation models,” <em>Emnlp</em>, no. October, pp. 1700–1709, 2013.
[9]      K. Cho <em>et al.</em>, “Learning phrase representations using RNN encoder-decoder for statistical machine translation,” 2014.
[10]    D. Bahdanau, K. Cho, and Y. Bengio, “Neural machine translation by jointly learning to align and translate,” pp. 1–15, 2014.
[11]    A. Graves, “Generating sequences with recurrent neural networks,” pp. 1–43, 2013.
[12]    M.-T. Luong, E. Brevdo, and R. Zhao, “Neural machine translation (seq2seq) tutorial,” <em>https://github.com/tensorflow/nmt</em>, 2017.
[13]    “Sequence to sequence example in Keras (character-level),” 2017. [Online]. Available: https://github.com/fcholle/keras/blob/master/examples/lstm_seq2seq.py. [Accessed: 13-Nov-2017].
[14]    “Index of /wmt16/translation-task.” [Online]. Available: http://data.statmt.org/wmt16/translation-task/.[Accessed: 04-Dec-2017].
[15]    N. Durrani, B. Haddow, P. Koehn, and K. Heafield, “Edinburgh’s phrase-based machine translation systems for WMT-14,” <em>Proc. Ninth Work. Stat. Mach. Transl.</em>, pp. 97–104, 2014.
[16]    K. Papineni, S. Roukos, T. Ward, and W. Zhu, “BLEU: A method for automatic evaluation of machine translation,” <em>… 40Th Annu. Meet. …</em>, no. July, pp. 311-318,2002.</p>
<p><br/></p>
<p><strong><h2>پیوست الف: پیاده‌سازی مدل توالی‌به‌توالی در keras</h2></strong>
در این قسمت جزئیات کد مدل توالی‌به‌توالی پیاده‌سازی شده در keras و تغییرات آن را شرح می‌دهیم. این کد به همراه مجموعه داده از پیوندهای ابتدای گزارش قابل دریافت است. پیاده‌سازی مدل توالی‌به‌توالی در  اینجا در سطح کاراکتر است یعنی وظیفه ترجمه ماشینی را کاراکتر به کاراکتر انجام می‌دهد. البته برای وظیفه ترجمه ماشینی مدل در سطح واژه مرسوم است. شروع از سطح کاراتر ساده تر بوده و بعدا با اضافه کردن یک لایه embedding می‌توان مدل را به آسانی در سطح واژه آموزش داد.
مجموعه آموزش شامل یک فایل متنی است که در هر سطر آن یک عبارت انگلیسی و سپس ترجمه معادل آن آمده است. دو عبارت در یک سطر با کاراکتر t\ از هم جدا شده‌اند. بنابراین جمله زبان مقصد با کاراکتر t\ شروع و با کاراکتر n\ خاتمه می‌یابد. برای تغییر حالت از کدگذار به کدگشا از نشانه  t\  و برای مشخص کردن پایان جمله زبان مقصد از نشانه n\ استفاده خواهد شد. ابتدا فایل ورودی را سطر به سطر خوانده و  دو  بخش متن ورودی و متن هدف را  را از روی آن می‌سازیم. سپس با روش one-hot  متن ورودی و متن هدف را به بردار عددی معادل تبدیل می‌کنیم. تکه کد زیر اینکار را انجام می‌دهد:</p>
<div class="highlight"><pre><span></span><code><span class="p">...</span>
<span class="n">input_token_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dict</span><span class="p">(</span><span class="o">[</span><span class="n">(char, i) for i, char in enumerate(input_characters)</span><span class="o">]</span><span class="p">)</span>
<span class="n">target_token_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dict</span><span class="p">(</span><span class="o">[</span><span class="n">(char, i) for i, char in enumerate(target_characters)</span><span class="o">]</span><span class="p">)</span>
<span class="n">encoder_input_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="nf">len</span><span class="p">(</span><span class="n">input_texts</span><span class="p">),</span><span class="w"> </span><span class="n">max_encoder_seq_length</span><span class="p">,</span><span class="w"> </span><span class="n">num_encoder_tokens</span><span class="p">),</span><span class="w"> </span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float32&#39;</span><span class="p">)</span>
<span class="n">decoder_input_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="nf">len</span><span class="p">(</span><span class="n">input_texts</span><span class="p">),</span><span class="w"> </span><span class="n">max_decoder_seq_length</span><span class="p">,</span><span class="w"> </span><span class="n">num_decoder_tokens</span><span class="p">),</span><span class="w"> </span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float32&#39;</span><span class="p">)</span>
<span class="n">decoder_target_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="nf">len</span><span class="p">(</span><span class="n">input_texts</span><span class="p">),</span><span class="w"> </span><span class="n">max_decoder_seq_length</span><span class="p">,</span><span class="w"> </span><span class="n">num_decoder_tokens</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float32&#39;</span><span class="p">)</span>
<span class="err">#</span><span class="w"> </span><span class="n">bulid</span><span class="w"> </span><span class="n">one</span><span class="o">-</span><span class="n">hot</span><span class="w"> </span><span class="n">vector</span>
<span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">input_text</span><span class="p">,</span><span class="w"> </span><span class="n">target_text</span><span class="p">)</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">enumerate</span><span class="p">(</span><span class="n">zip</span><span class="p">(</span><span class="n">input_texts</span><span class="p">,</span><span class="w"> </span><span class="n">target_texts</span><span class="p">))</span><span class="err">:</span>
<span class="k">for</span><span class="w"> </span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="nc">char</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">enumerate</span><span class="p">(</span><span class="n">input_text</span><span class="p">)</span><span class="err">:</span>
<span class="w">    </span><span class="n">encoder_input_data</span><span class="o">[</span><span class="n">i, t, input_token_index[char</span><span class="o">]</span><span class="err">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.</span>
<span class="k">for</span><span class="w"> </span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="nc">char</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">enumerate</span><span class="p">(</span><span class="n">target_text</span><span class="p">)</span><span class="err">:</span>
<span class="w">    </span><span class="err">#</span><span class="w"> </span><span class="n">decoder_target_data</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">ahead</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">decoder_input_data</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="n">one</span><span class="w"> </span><span class="n">timestep</span>
<span class="w">    </span><span class="n">decoder_input_data</span><span class="o">[</span><span class="n">i, t, target_token_index[char</span><span class="o">]</span><span class="err">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="err">:</span>
<span class="w">        </span><span class="err">#</span><span class="w"> </span><span class="n">decoder_target_data</span><span class="w"> </span><span class="n">will</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">ahead</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="n">one</span><span class="w"> </span><span class="n">timestep</span>
<span class="w">        </span><span class="err">#</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">will</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="k">include</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="k">start</span><span class="w"> </span><span class="k">character</span><span class="p">.</span>
<span class="w">        </span><span class="n">decoder_target_data</span><span class="o">[</span><span class="n">i, t - 1, target_token_index[char</span><span class="o">]</span><span class="err">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.</span>
<span class="p">...</span>
</code></pre></div>

<p>دقت شود که ورودی کدگشا در مرحله آموزش، عبارت زبان مقصد (متن هدف) و خروجی آن نیز همان عبارت زبان مقصد است که یک واحد به جلو شیفت داده شده است (روش موسوم به teacher forcing). کد بالا این کار را نیز انجام می‌دهد یعنی خروجی کدگشا را به همین روش اضافه می‌کند.
حال نوبت به تعریف LSTM کدگذار و LSTM کدگشا می‌رسد. در keras کلاس LSTM کلیه وظایف مربوط به این نوع شبکه را پیاده‌سازی کرده است. کافی است یک نمونه (شیء) از این کلاس ایجاد کنیم. این کلاس همچنین متد <strong><em>call</em></strong> را داراست که لایه ورودی را به عنوان آرگومان دریافت و به شیء ساخته شده از کلاس متصل می‌کند. LSTM کدگذار بنابراین به‌صورت زیر تعریف می‌شود:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="nx">encoder_inputs</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">Input</span><span class="p">(</span><span class="nx">shape</span><span class="p">=(</span><span class="nx">None</span><span class="p">,</span><span class="w"> </span><span class="nx">num_encoder_tokens</span><span class="p">))</span>
<span class="err">#</span><span class="nx">print</span><span class="p">(</span><span class="k">type</span><span class="p">(</span><span class="nx">encoder_inputs</span><span class="p">))</span>
<span class="nx">encoder</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">LSTM</span><span class="p">(</span><span class="nx">latent_dim</span><span class="p">,</span><span class="w"> </span><span class="nx">return_state</span><span class="p">=</span><span class="nx">True</span><span class="p">)</span>
<span class="err">#</span><span class="nx">print</span><span class="p">(</span><span class="k">type</span><span class="p">(</span><span class="nx">encoder</span><span class="p">))</span>
<span class="nx">encoder_outputs</span><span class="p">,</span><span class="w"> </span><span class="nx">state_h</span><span class="p">,</span><span class="w"> </span><span class="nx">state_c</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">encoder</span><span class="p">(</span><span class="nx">encoder_inputs</span><span class="p">)</span>
<span class="o">...</span>
</code></pre></div>

<p>وقتی از آرگومان return_state=True در ساخت یک شی از کلاس LSTM استفاده می‌شود دو حالت حافظه موجود در LSTM هم به عنوان خروجی، علاوه بر توالی خروجی اصلی بازگردانیده می‌شوند. در کد بالا این دو حالت state_c و state_h نام دارند. خروجی کدگذار در مدل توالی‌به‌توالی استفاده‌ای ندارد و دور انداخته می‌شود.  در عوض از حالت‌های state_c و state_h به عنوان حالت آغازین LSTM کدگشا به صورت زیر استفاده می‌شود:</p>
<div class="highlight"><pre><span></span><code><span class="p">...</span>
<span class="n">encoder_states</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">[</span><span class="n">state_h</span><span class="p">,</span><span class="w"> </span><span class="n">state_c</span><span class="err">]</span>
<span class="c1"># Set up the decoder, using `encoder_states` as initial state.</span>
<span class="n">decoder_inputs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="k">None</span><span class="p">,</span><span class="w"> </span><span class="n">num_decoder_tokens</span><span class="p">))</span>
<span class="c1"># We set up our decoder to return full output sequences,</span>
<span class="c1"># and to return internal states as well. We don&#39;t use the</span>
<span class="c1"># return states in the training model, but we will use them in inference.</span>
<span class="n">decoder_lstm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">LSTM</span><span class="p">(</span><span class="n">latent_dim</span><span class="p">,</span><span class="w"> </span><span class="n">return_sequences</span><span class="o">=</span><span class="no">True</span><span class="p">,</span><span class="w"> </span><span class="n">return_state</span><span class="o">=</span><span class="no">True</span><span class="p">)</span>
<span class="n">decoder_outputs</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">decoder_lstm</span><span class="p">(</span><span class="n">decoder_inputs</span><span class="p">,</span><span class="n">initial_state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">encoder_states</span><span class="p">)</span>
<span class="p">...</span>
</code></pre></div>

<p>همچنین  یک لایه softmax برروی خروجی توالی‌ نهایی LSTMکدگشا جهت تبدیل خروجی به احتمالات معتبر به شکل زیر قرار می‌دهیم:</p>
<div class="highlight"><pre><span></span><code>...
decoder_dense = Dense(num_decoder_tokens, activation = &#39;softmax&#39;)
decoder_outputs = decoder_dense(decoder_outputs)
...
</code></pre></div>

<p>اکنون لایه‌های مدل ساخته شده است. این لایه‌ها بایستی به شکل یک گراف به هم متصل شده و تشکیل یک مدل با ورودی و خروجی معین را بدهند. در keras دو نوع  مدل وجود دارد. نوع اول مدل‌های ترتیبی (sequential) هستند که یک پشته خطی از لایه‌ها را در قالب مدل به هم مرتبط می‌کنند. یعنی گراف نهایی مدل ترتیبی حالتی خطی دارد. مدل ترتیبی برای ایجاد مدل‌های پیچیده‌تر مثل مدل توالی‌به‌توالی مناسب نیست. نوع دوم مدل در keras با استفاده از Keras functional API ساخته می‌شوند. این حالت برای ساختن مدل‌هایی با چند ورودی و چند خروجی که گراف آن‌ها لزوما خطی نیست به کار می‌رود. در اینجا از این روش استفاده شده است.  برای این منظور پس از تعیین تک تک لایه‌‌ها (کد قسمت‌های قبلی)، از کلاس Model استفاده کرده و ورودی و خروجی نهایی مدل را تعیین می‌کنیم:</p>
<div class="highlight"><pre><span></span><code><span class="p">...</span>
<span class="c1"># Define the model that will turn</span>
<span class="c1">#encoder_input_data` &amp; `decoder_input_data` into `decoder_target_data`</span>
<span class="n">model</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Model</span><span class="p">(</span><span class="err">[</span><span class="n">encoder_inputs</span><span class="p">,</span><span class="w"> </span><span class="n">decoder_inputs</span><span class="err">]</span><span class="p">,</span><span class="w"> </span><span class="n">decoder_outputs</span><span class="p">)</span>
<span class="p">...</span>
</code></pre></div>

<p>با استفاده از تابع plot_model می‌توان به صورت گرافیکی بهم‌بست مدل ایجاد شده را مشاهده کرد: </p>
<div class="highlight"><pre><span></span><code>...
plot_model(model, to_file = &#39;./modelpic/seq2seq_model_&#39; + dt + &#39;.png&#39;, show_shapes=True, show_layer_names=True)
...
</code></pre></div>

<p>برای استفاده از این تابع لازم است با دستور from keras.utils import plot_model  بسته حاوی تابع plot_model را در ابتدای کد، به  برنامه اضافه کنیم. نتیجه اجرای این تابع به شکل زیر است:
<img alt="شکل (الف - 1) مدل توالی‌به‌توالی ساخته شده در keras و رسم شده توسط تابع plot_model" src="https://boute.s3.amazonaws.com/290-seq2seq_model_20180206_155430.png"></p>
<p>در مرحله بعد تابع خطا و روش یادگیری مدل تعیین می‌شود:</p>
<div class="highlight"><pre><span></span><code>...
model.compile(optimizer=&#39;rmsprop&#39;, loss=&#39;categorical_crossentropy&#39;)
...
</code></pre></div>

<p>و درنهایت مدل را با داده‌های واقعی آموزش می‌دهیم:</p>
<div class="highlight"><pre><span></span><code>...
<span class="gh">#</span> Run training
model.fit([encoder_input_data, decoder_input_data], decoder_target_data,
      batch_size=batch_size,
      epochs=epochs,
      validation_split=0.2)
...
</code></pre></div>

<p>پس از آموزش مدل نوبت به آزمون مدل می‌رسد. در این مرحله می‌خواهیم با دادن یک جمله  زبان مبدأ به مدل ترجمه معادل آن در زبان مقصد را کدگشایی کنیم. برای این منظور نیاز است تا مدل‌هایی مشابه اما جدا از مدل آموزش تعریف کنیم. ابتدا مدل کدگذار را به نحوی تعریف می کنیم که جمله زبان مبدا را به عنوان ورودی بپذیرد و حالات آغازین مدل کدگشا را به عنوان خروجی تولید کند:</p>
<div class="highlight"><pre><span></span><code>...
<span class="gu">##</span> encoder model
encoder_model = Model(encoder_inputs, encoder_states)
</code></pre></div>

<p>مدل کدگشا را طوری تعریف می‌کنیم که ورودی آن شامل حالت‌ها و خروجی مرحله قبلی خود باشد. در مرحله اول کدگشایی مقادیر  این ورودی‌ها عبارت‌اند از حالات خروجی مدل کدگذار و نشانه آغاز جمله زبان مقصد یعنی همان t. تکه کد زیر مدل کدگشا را تعریف می‌کند:</p>
<div class="highlight"><pre><span></span><code><span class="p">...</span>
<span class="err">##</span><span class="w"> </span><span class="n">decoder</span><span class="w"> </span><span class="n">model</span>
<span class="n">decoder_state_input_h</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">latent_dim</span><span class="p">,))</span>
<span class="n">decoder_state_input_c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">latent_dim</span><span class="p">,))</span>
<span class="n">decoder_states_inputs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">[</span><span class="n">decoder_state_input_h, decoder_state_input_c</span><span class="o">]</span>
<span class="n">decoder_outputs</span><span class="p">,</span><span class="w"> </span><span class="n">state_h</span><span class="p">,</span><span class="w"> </span><span class="n">state_c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">decoder_lstm</span><span class="p">(</span><span class="n">decoder_inputs</span><span class="p">,</span><span class="w"> </span><span class="n">initial_state</span><span class="o">=</span><span class="n">decoder_states_inputs</span><span class="p">)</span>
<span class="n">decoder_states</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">[</span><span class="n">state_h, state_c</span><span class="o">]</span>
<span class="n">decoder_outputs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">decoder_dense</span><span class="p">(</span><span class="n">decoder_outputs</span><span class="p">)</span>
<span class="n">decoder_model</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Model</span><span class="p">(</span><span class="o">[</span><span class="n">decoder_inputs</span><span class="o">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">decoder_states_inputs</span><span class="p">,</span><span class="o">[</span><span class="n">decoder_outputs</span><span class="o">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">decoder_states</span><span class="p">)</span>
<span class="p">...</span>
</code></pre></div>

<p>دقت شود که برای ساخت مدل از همان لایه‌های (اشیای LSTM کدگذار و کدگشای ) ساخته شده در مرحله آموزش استفاده شده است. در ای حالت وزن لایه‌ها بین دو مدل ب اشتراک گذاشته می‌شود. یعنی وزن لایه‌ها از مرحله آموزش گرفته می‌شود و  از این مدل‌ها فقط برای پیش‌بینی خروجی با داشتن ورودی، استفاده می‌شود. تابع decode_sequence آمده در زیر، به عنوان آرگومان یک توالی ورودی را دریافت و توالی خروجی معادل آن را باز می‌گرداند:</p>
<div class="highlight"><pre><span></span><code><span class="p">...</span>
<span class="n">def</span><span class="w"> </span><span class="n">decode_sequence</span><span class="p">(</span><span class="n">input_seq</span><span class="p">)</span><span class="err">:</span>
<span class="err">#</span><span class="w"> </span><span class="n">Encode</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="k">input</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="k">state</span><span class="w"> </span><span class="n">vectors</span><span class="p">.</span>
<span class="n">states_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">encoder_model</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">input_seq</span><span class="p">)</span>
<span class="err">#</span><span class="w"> </span><span class="n">Generate</span><span class="w"> </span><span class="n">empty</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="k">sequence</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="mf">1.</span>
<span class="n">target_seq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">num_decoder_tokens</span><span class="p">))</span>
<span class="err">#</span><span class="w"> </span><span class="n">Populate</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="k">first</span><span class="w"> </span><span class="k">character</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="k">sequence</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="k">start</span><span class="w"> </span><span class="k">character</span><span class="p">.</span>
<span class="n">target_seq</span><span class="o">[</span><span class="n">0, 0, target_token_index[&#39;\t&#39;</span><span class="o">]</span><span class="err">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.</span>
<span class="err">#</span><span class="w"> </span><span class="n">Sampling</span><span class="w"> </span><span class="n">loop</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">batch</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">sequences</span>
<span class="err">#</span><span class="w"> </span><span class="p">(</span><span class="k">to</span><span class="w"> </span><span class="n">simplify</span><span class="p">,</span><span class="w"> </span><span class="n">here</span><span class="w"> </span><span class="n">we</span><span class="w"> </span><span class="n">assume</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">batch</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="k">size</span><span class="w"> </span><span class="mi">1</span><span class="p">).</span>
<span class="n">stop_condition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">False</span>
<span class="n">decoded_sentence</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;&#39;</span>
<span class="k">while</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="nl">stop_condition</span><span class="p">:</span>
<span class="w">    </span><span class="n">output_tokens</span><span class="p">,</span><span class="w"> </span><span class="n">h</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">decoder_model</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span>
<span class="w">        </span><span class="o">[</span><span class="n">target_seq</span><span class="o">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">states_value</span><span class="p">)</span>
<span class="w">    </span><span class="err">#</span><span class="w"> </span><span class="n">Sample</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">token</span>
<span class="w">    </span><span class="n">sampled_token_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="p">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">output_tokens</span><span class="o">[</span><span class="n">0, -1, :</span><span class="o">]</span><span class="p">)</span>
<span class="w">    </span><span class="n">sampled_char</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">reverse_target_char_index</span><span class="o">[</span><span class="n">sampled_token_index</span><span class="o">]</span>
<span class="w">    </span><span class="n">decoded_sentence</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">sampled_char</span>
<span class="w">    </span><span class="err">#</span><span class="w"> </span><span class="k">Exit</span><span class="w"> </span><span class="k">condition</span><span class="err">:</span><span class="w"> </span><span class="n">either</span><span class="w"> </span><span class="n">hit</span><span class="w"> </span><span class="nf">max</span><span class="w"> </span><span class="n">length</span>
<span class="w">    </span><span class="err">#</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="n">find</span><span class="w"> </span><span class="n">stop</span><span class="w"> </span><span class="k">character</span><span class="p">.</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sampled_char</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s1">&#39;\n&#39;</span><span class="w"> </span><span class="ow">or</span>
<span class="w">       </span><span class="nf">len</span><span class="p">(</span><span class="n">decoded_sentence</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">max_decoder_seq_length</span><span class="p">)</span><span class="err">:</span>
<span class="w">        </span><span class="n">stop_condition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">True</span>
<span class="w">    </span><span class="err">#</span><span class="w"> </span><span class="k">Update</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="k">sequence</span><span class="w"> </span><span class="p">(</span><span class="k">of</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="mi">1</span><span class="p">).</span>
<span class="w">    </span><span class="n">target_seq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">num_decoder_tokens</span><span class="p">))</span>
<span class="w">    </span><span class="n">target_seq</span><span class="o">[</span><span class="n">0, 0, sampled_token_index</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.</span>
<span class="w">    </span><span class="err">#</span><span class="w"> </span><span class="k">Update</span><span class="w"> </span><span class="n">states</span>
<span class="w">    </span><span class="n">states_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">[</span><span class="n">h, c</span><span class="o">]</span>
<span class="k">return</span><span class="w"> </span><span class="n">decoded_sentence</span>
<span class="p">...</span>
</code></pre></div>

<p>مدل‌های کدگذار و کدگشا که تابع فوق از آنها استفاده می‌کند و قبل از این تعریف شدند نیز به‌ ترتیب  به‌صورت گراف‌های زیر هستند:</p>
<p><img alt="شکل (الف - 2) مدل کدگذار استفاده شده در مرحله پیش‌بینی (آزمون یا استنتاج)" src="https://boute.s3.amazonaws.com/290-sampling_encoder_model_20180206_155430.png"></p>
<p><img alt="شکل (الف - 3) مدل کدگشای استفاده شده در مرحله پیش‌بینی (آزمون یا استنتاج)" src="https://boute.s3.amazonaws.com/290-sampling_decoder_model_20180206_155430.png">
<strong>توجه:</strong> شماره‌های سمت چپ هر گره در گراف‌‌های این بخش به صورت ترتیبی توسط keras قرار داده می‌شوند و اهمیتی ندارند.</p>
<p><strong><h3>ژرف‌سازی شبکه</h3></strong></p>
<p>اگرچه مدل توضیح داده‌شده در این قسمت به طور کامل از مفاهیم شبکه‌های عصبی ژرف استفاده می‌کند اما به معنای واقعی کلمه <em>ژرف</em> نیست. در keras به راحتی می‌توان یک مدل ژرف را با پشته کردن لایه‌ها روی یکدیگر ایجاد کرد. برای مثال چنانچه بخواهیم شبکه کدگذار مدل فوق دارای دو لایه LSTM باشد کافی است اولین لایه شبکه کدگذار (encoder_l1) را به‌گونه‌ای تعریف کنیم که یک توالی را به‌عنوان خروجی بدهد. سپس لایه ورودی را به این لایه متصل می‌کنیم و لایه LSTM موجود در کد قبلی این‌بار لایه جدید را به عنوان ورودی می‌پذیرد:</p>
<div class="highlight"><pre><span></span><code>...
<span class="gh">#</span> Define an input sequence. 
encoder_inputs = Input(shape=(None, num_encoder_tokens))
<span class="gh">#</span> Define LSTM layer 1 and pass the above encoder input sequence to it.
<span class="gh">#</span> note that return_sequences argument must set to be True in order to connect next to layer.
encoder_l1 = LSTM(latent_dim, return_sequences=True, return_state=True)(encoder_inputs)
<span class="gh">#</span> Define LSTM layer 2 (encoder)
encoder = LSTM(latent_dim, return_state=True)
<span class="gh">#</span> Pass (connect) encoder_l1 to LSTM layer 2 (encoder)
encoder_outputs, state_h, state_c = encoder(encoder_l1)
...
</code></pre></div>

<p>و به همین ترتیب این اقدام باید برای دیگر لایه‌های شبکه هم انجام شود.</p>
<p><strong><h3>تبدیل مدل به یک مدل در سطح واژه</h3></strong></p>
<p>مدل فوق در سطح کاراکتر عمل می‌کند. اگر یک توالی از اعداد صحیح داشته باشیم که هر عدد نشان دهنده شاخص واژه‌ای خاص در یک دیکشنری باشد. می‌توان با استفاده از لایه embedding موجود در keras مدل را برای استفاده از این نشانه‌های عددصحیح آماده کرد. تکه کد زیر این امکان را اضافه می‌کند:</p>
<div class="highlight"><pre><span></span><code><span class="p">...</span>
<span class="c1"># Define an input sequence and process it.</span>
<span class="n">encoder_inputs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="k">None</span><span class="p">,))</span>
<span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Embedding</span><span class="p">(</span><span class="n">num_encoder_tokens</span><span class="p">,</span><span class="w"> </span><span class="n">latent_dim</span><span class="p">)(</span><span class="n">encoder_inputs</span><span class="p">)</span>
<span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">state_h</span><span class="p">,</span><span class="w"> </span><span class="n">state_c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">LSTM</span><span class="p">(</span><span class="n">latent_dim</span><span class="p">,</span><span class="n">return_state</span><span class="o">=</span><span class="no">True</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span><span class="n">encoder_states</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">[</span><span class="n">state_h</span><span class="p">,</span><span class="w"> </span><span class="n">state_c</span><span class="err">]</span>
<span class="c1"># Set up the decoder, using `encoder_states` as initial state.</span>
<span class="n">decoder_inputs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="k">None</span><span class="p">,))</span>
<span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Embedding</span><span class="p">(</span><span class="n">num_decoder_tokens</span><span class="p">,</span><span class="w"> </span><span class="n">latent_dim</span><span class="p">)(</span><span class="n">decoder_inputs</span><span class="p">)</span>
<span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">LSTM</span><span class="p">(</span><span class="n">latent_dim</span><span class="p">,</span><span class="w"> </span><span class="n">return_sequences</span><span class="o">=</span><span class="no">True</span><span class="p">)(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">initial_state</span><span class="o">=</span><span class="n">encoder_states</span><span class="p">)</span>
<span class="n">decoder_outputs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Dense</span><span class="p">(</span><span class="n">num_decoder_tokens</span><span class="p">,</span><span class="w"> </span><span class="n">activation</span><span class="o">=</span><span class="s1">&#39;softmax&#39;</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>
<span class="c1"># Define the model that will turn</span>
<span class="c1">#encoder_input_data` &amp; `decoder_input_data` into `decoder_target_data`</span>
<span class="n">model</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Model</span><span class="p">(</span><span class="err">[</span><span class="n">encoder_inputs</span><span class="p">,</span><span class="w"> </span><span class="n">decoder_inputs</span><span class="err">]</span><span class="p">,</span><span class="w"> </span><span class="n">decoder_outputs</span><span class="p">)</span>
<span class="c1"># Compile &amp; run training</span>
<span class="n">model</span><span class="p">.</span><span class="n">compile</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="s1">&#39;rmsprop&#39;</span><span class="p">,</span><span class="w"> </span><span class="n">loss</span><span class="o">=</span><span class="s1">&#39;categorical_crossentropy&#39;</span><span class="p">)</span>
<span class="c1"># Note that `decoder_target_data` needs to be one-hot encoded,</span>
<span class="c1"># rather than sequences of integers like `decoder_input_data`!</span>
<span class="n">model</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="err">[</span><span class="n">encoder_input_data</span><span class="p">,</span><span class="w"> </span><span class="n">decoder_input_data</span><span class="err">]</span><span class="p">,</span><span class="w"> </span><span class="n">decoder_target_data</span><span class="p">,</span><span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span><span class="n">epochs</span><span class="o">=</span><span class="n">epochs</span><span class="p">,</span><span class="w"> </span><span class="n">validation_split</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>
<span class="p">...</span>
</code></pre></div>

<p><br>
<br></p>
<hr>
<p><strong><h2>واژه‌نامه</h2></strong></p>
<p><strong><h3 align = "center">واژه‌نامه فـارســی به انگلـیسی</h3></strong></p>
<table>
<thead>
<tr>
<th style="text-align: center;"><strong>واژه‌‌ی فـارسی</strong></th>
<th style="text-align: center;"></th>
<th style="text-align: center;"><strong>معادل انگلیسی</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">انفجار گرادیان</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">Exploding Gradient</td>
</tr>
<tr>
<td style="text-align: center;">بانظارت</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">Supervised</td>
</tr>
<tr>
<td style="text-align: center;">پردازش زبان طبیعی</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">Natural Language Processing (NLP)</td>
</tr>
<tr>
<td style="text-align: center;">پس‌انتشار</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">Backpropagation</td>
</tr>
<tr>
<td style="text-align: center;">تابع بیشینه هموار</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">Softmax Function</td>
</tr>
<tr>
<td style="text-align: center;">تأخیر زمانی کمینه</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">Minimal Time Lag</td>
</tr>
<tr>
<td style="text-align: center;">ترجمه ماشینی</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">Machine Translation (MT)</td>
</tr>
<tr>
<td style="text-align: center;">ترجمه ماشینی آماری</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">Statistical Machine Translation (SMT)</td>
</tr>
<tr>
<td style="text-align: center;">ترجمه ماشینی عصبی</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">Neural Machine Translation (NMT)</td>
</tr>
<tr>
<td style="text-align: center;">تشخیص گفتار</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">Speech Recognition</td>
</tr>
<tr>
<td style="text-align: center;">توالی</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">Sequence</td>
</tr>
<tr>
<td style="text-align: center;">جست‌وجوی پرتوی محلی</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">Beam Search</td>
</tr>
<tr>
<td style="text-align: center;">حافظه کوتاه مدت بلند</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">Long-Short Term Memory (LSTM)</td>
</tr>
<tr>
<td style="text-align: center;">دسته</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">Batch</td>
</tr>
<tr>
<td style="text-align: center;">دوره</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">Epoch</td>
</tr>
<tr>
<td style="text-align: center;">سرگشتگی</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">Perplexity</td>
</tr>
<tr>
<td style="text-align: center;">شبکه عصبی پیچشی</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">Convolutional Neural Network (CNN)</td>
</tr>
<tr>
<td style="text-align: center;">شبکه عصبی رو به جلو ژرف</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">Deep Feed-forward Neural Network</td>
</tr>
<tr>
<td style="text-align: center;">شبکه عصبی ژرف</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">Deep Neural Network (DNN)</td>
</tr>
<tr>
<td style="text-align: center;">شبکه عصبی مکرر</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">(RNN) Recurrent Neural Network</td>
</tr>
<tr>
<td style="text-align: center;">فرضیه جزئی</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">Partial Hypothesis</td>
</tr>
<tr>
<td style="text-align: center;">کدگذار</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">Encoder</td>
</tr>
<tr>
<td style="text-align: center;">کدگشا</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">Decoder</td>
</tr>
<tr>
<td style="text-align: center;">گذر جلو</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">Forward Pass</td>
</tr>
<tr>
<td style="text-align: center;">مدل زبانی</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">Language Model (LM)</td>
</tr>
<tr>
<td style="text-align: center;">مدل زبانی عصبی</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">Neural Language Model (NLM)</td>
</tr>
<tr>
<td style="text-align: center;">میرایی گرادیان</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">Vanishing Gradient</td>
</tr>
<tr>
<td style="text-align: center;">نشانه‌گذاری شده</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">Tokenized</td>
</tr>
</tbody>
</table>
<p><br/></p>
<p><strong><h3>پانوشت‌ها</h3></strong></p>
<div class="footnote">
<hr>
<ol>
<li id="fn:1">
<p>deep neural networks&#160;<a class="footnote-backref" href="#fnref:1" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:2">
<p>backpropagation&#160;<a class="footnote-backref" href="#fnref:2" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
<li id="fn:3">
<p>supervised&#160;<a class="footnote-backref" href="#fnref:3" title="Jump back to footnote 3 in the text">&#8617;</a></p>
</li>
<li id="fn:4">
<p>natural language processing&#160;<a class="footnote-backref" href="#fnref:4" title="Jump back to footnote 4 in the text">&#8617;</a></p>
</li>
<li id="fn:5">
<p>sequence&#160;<a class="footnote-backref" href="#fnref:5" title="Jump back to footnote 5 in the text">&#8617;</a></p>
</li>
<li id="fn:6">
<p>deep feed-forward neural networks&#160;<a class="footnote-backref" href="#fnref:6" title="Jump back to footnote 6 in the text">&#8617;</a></p>
</li>
<li id="fn:7">
<p>recurrent neural networks&#160;<a class="footnote-backref" href="#fnref:7" title="Jump back to footnote 7 in the text">&#8617;</a></p>
</li>
<li id="fn:8">
<p>convolutional neural networks&#160;<a class="footnote-backref" href="#fnref:8" title="Jump back to footnote 8 in the text">&#8617;</a></p>
</li>
<li id="fn:9">
<p>grid&#160;<a class="footnote-backref" href="#fnref:9" title="Jump back to footnote 9 in the text">&#8617;</a></p>
</li>
<li id="fn:10">
<p>machine translation&#160;<a class="footnote-backref" href="#fnref:10" title="Jump back to footnote 10 in the text">&#8617;</a></p>
</li>
<li id="fn:11">
<p>speech recognition&#160;<a class="footnote-backref" href="#fnref:11" title="Jump back to footnote 11 in the text">&#8617;</a></p>
</li>
<li id="fn:12">
<p>long-short term memory&#160;<a class="footnote-backref" href="#fnref:12" title="Jump back to footnote 12 in the text">&#8617;</a></p>
</li>
<li id="fn:13">
<p>neural machine translation&#160;<a class="footnote-backref" href="#fnref:13" title="Jump back to footnote 13 in the text">&#8617;</a></p>
</li>
<li id="fn:14">
<p>statistical machine translation&#160;<a class="footnote-backref" href="#fnref:14" title="Jump back to footnote 14 in the text">&#8617;</a></p>
</li>
<li id="fn:15">
<p>language model&#160;<a class="footnote-backref" href="#fnref:15" title="Jump back to footnote 15 in the text">&#8617;</a></p>
</li>
<li id="fn:16">
<p>neural language models&#160;<a class="footnote-backref" href="#fnref:16" title="Jump back to footnote 16 in the text">&#8617;</a></p>
</li>
<li id="fn:17">
<p>forward pass&#160;<a class="footnote-backref" href="#fnref:17" title="Jump back to footnote 17 in the text">&#8617;</a></p>
</li>
<li id="fn:18">
<p>rectified linear unit&#160;<a class="footnote-backref" href="#fnref:18" title="Jump back to footnote 18 in the text">&#8617;</a></p>
</li>
<li id="fn:19">
<p>sigmoid&#160;<a class="footnote-backref" href="#fnref:19" title="Jump back to footnote 19 in the text">&#8617;</a></p>
</li>
<li id="fn:20">
<p>softmax function&#160;<a class="footnote-backref" href="#fnref:20" title="Jump back to footnote 20 in the text">&#8617;</a></p>
</li>
<li id="fn:21">
<p>n-best list&#160;<a class="footnote-backref" href="#fnref:21" title="Jump back to footnote 21 in the text">&#8617;</a></p>
</li>
<li id="fn:22">
<p>topic model&#160;<a class="footnote-backref" href="#fnref:22" title="Jump back to footnote 22 in the text">&#8617;</a></p>
</li>
<li id="fn:23">
<p>batch&#160;<a class="footnote-backref" href="#fnref:23" title="Jump back to footnote 23 in the text">&#8617;</a></p>
</li>
<li id="fn:24">
<p>epoch&#160;<a class="footnote-backref" href="#fnref:24" title="Jump back to footnote 24 in the text">&#8617;</a></p>
</li>
<li id="fn:25">
<p>vanishing gradient&#160;<a class="footnote-backref" href="#fnref:25" title="Jump back to footnote 25 in the text">&#8617;</a></p>
</li>
<li id="fn:26">
<p>exploding gradient&#160;<a class="footnote-backref" href="#fnref:26" title="Jump back to footnote 26 in the text">&#8617;</a></p>
</li>
<li id="fn:27">
<p>inference&#160;<a class="footnote-backref" href="#fnref:27" title="Jump back to footnote 27 in the text">&#8617;</a></p>
</li>
<li id="fn:29">
<p>tokenized&#160;<a class="footnote-backref" href="#fnref:29" title="Jump back to footnote 28 in the text">&#8617;</a></p>
</li>
<li id="fn:30">
<p>beam search&#160;<a class="footnote-backref" href="#fnref:30" title="Jump back to footnote 29 in the text">&#8617;</a></p>
</li>
<li id="fn:31">
<p>partial hypothesis&#160;<a class="footnote-backref" href="#fnref:31" title="Jump back to footnote 30 in the text">&#8617;</a></p>
</li>
<li id="fn:32">
<p>perplexity&#160;<a class="footnote-backref" href="#fnref:32" title="Jump back to footnote 31 in the text">&#8617;</a></p>
</li>
<li id="fn:33">
<p>minimal time lag&#160;<a class="footnote-backref" href="#fnref:33" title="Jump back to footnote 32 in the text">&#8617;</a></p>
</li>
<li id="fn:34">
<p>چندین نوع محاسبه از امتیاز BLEU وجود دارد کــه هر نوع با یک اسکریپت زبان perl تعریف شده است و در این مقاله از این اسکریپت‌های موجود برای محاسبه امتیاز BLEU استفاده شده است.&#160;<a class="footnote-backref" href="#fnref:34" title="Jump back to footnote 33 in the text">&#8617;</a></p>
</li>
</ol>
</div>
  </div>
  <div class="tag-cloud">
    <p>
      <a href="./tag/blog.html">blog</a>
    </p>
  </div>


  <div class="neighbors">
    <a class="btn float-left" href="./computer-science-at-the-heart-of-civilization.html" title="Computer science at the heart of civilization">
      <i class="fa fa-angle-left"></i> Previous Post
    </a>
    <a class="btn float-right" href="./children-and-programming.html" title="Children and programming">
      Next Post <i class="fa fa-angle-right"></i>
    </a>
  </div>

  <div class="related-posts">
    <h4>You might enjoy</h4>
    <ul class="related-posts">
      <li><a href="./a-gentle-introduction-to-search-based-software-refactoring.html">A gentle introduction to search-based software refactoring</a></li>
      <li><a href="./codart-automated-source-code-refactoring-toolkit.html">CodART: Automated Source Code Refactoring Toolkit</a></li>
      <li><a href="./automated-refactoring-of-the-java-code-using-antlr-in-python.html">Automated refactoring of the Java code using ANTLR in Python</a></li>
      <li><a href="./do-software-engineers-sacrifice-themselves.html">Do software engineers sacrifice themselves?</a></li>
      <li><a href="./program-dynamic-analysis-with-antlr.html">Program dynamic analysis with ANTLR</a></li>
    </ul>
  </div>



<!-- Disqus -->
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'zakeri';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>
    Please enable JavaScript to view comments.
</noscript>
<!-- End Disqus -->
</article>

<footer>
<p>
  &copy; 2010 - 2025 Morteza Zakeri. All rights reserved. Last update on 2025-05-29 11:51:20.495889 - This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/deed.en_US" target="_blank">Creative Commons Attribution-ShareAlike</a>
</p>
<p>
Built with <a href="http://getpelican.com" target="_blank">Pelican</a> using <a href="http://bit.ly/flex-pelican" target="_blank">Flex</a> theme
  <span class="footer-separator">|</span>
  Switch to the <a href="javascript:void(0)" onclick="theme.switch(`dark`)">dark</a> | <a href="javascript:void(0)" onclick="theme.switch(`light`)">light</a> | <a href="javascript:void(0)" onclick="theme.switch(`browser`)">browser</a> theme
  <script id="dark-theme-script"
          src="./theme/dark-theme/dark-theme.min.js"
          data-enable-auto-detect-theme="True"
          data-default-theme="light"
          type="text/javascript">
  </script>
</p><p>
  <a rel="license"
     href="http://creativecommons.org/licenses/by-sa/4.0/"
     target="_blank">
    <img alt="Creative Commons License"
         title="Creative Commons License"
         style="border-width:0"
           src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png"
         width="80"
         height="15"/>
  </a>
</p></footer>  </main>

<script type="application/ld+json">
{
  "@context" : "http://schema.org",
  "@type" : "Blog",
  "name": " Morteza Zakeri ",
  "url" : ".",
  "image": "/static/img/profile.png",
  "description": ""
}
</script>  <script>
    window.loadStorkIndex = function () {
      stork.initialize("./theme/stork/stork.wasm")
      stork.register("sitesearch", "./search-index.st", { showProgress: false });
    }
  </script>
  <script src="./theme/stork/stork.js"></script>

</body>
</html>